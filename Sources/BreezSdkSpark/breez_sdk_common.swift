// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(breez_sdk_sparkFFI)
import breez_sdk_sparkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_breez_sdk_common_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_breez_sdk_common_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol RestClient : AnyObject {
    
    /**
     * Makes a GET request and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which GET will be called
     * - `headers`: optional headers that will be set on the request
     */
    func get(url: String, headers: [String: String]?) async throws  -> RestResponse
    
    /**
     * Makes a POST request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which POST will be called
     * - `headers`: the optional POST headers
     * - `body`: the optional POST body
     */
    func post(url: String, headers: [String: String]?, body: String?) async throws  -> RestResponse
    
}

open class RestClientImpl:
    RestClient {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_common_fn_clone_restclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_common_fn_free_restclient(pointer, $0) }
    }

    

    
    /**
     * Makes a GET request and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which GET will be called
     * - `headers`: optional headers that will be set on the request
     */
open func get(url: String, headers: [String: String]?)async throws  -> RestResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_common_fn_method_restclient_get(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDictionaryStringString.lower(headers)
                )
            },
            pollFunc: ffi_breez_sdk_common_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_common_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_common_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRestResponse.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    
    /**
     * Makes a POST request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which POST will be called
     * - `headers`: the optional POST headers
     * - `body`: the optional POST body
     */
open func post(url: String, headers: [String: String]?, body: String?)async throws  -> RestResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_common_fn_method_restclient_post(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDictionaryStringString.lower(headers),FfiConverterOptionString.lower(body)
                )
            },
            pollFunc: ffi_breez_sdk_common_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_common_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_common_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRestResponse.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRestClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRestClient = UniffiVTableCallbackInterfaceRestClient(
        get: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            headers: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RestResponse in
                guard let uniffiObj = try? FfiConverterTypeRestClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.get(
                     url: try FfiConverterString.lift(url),
                     headers: try FfiConverterOptionDictionaryStringString.lift(headers)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RestResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRestResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        post: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            headers: RustBuffer,
            body: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RestResponse in
                guard let uniffiObj = try? FfiConverterTypeRestClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.post(
                     url: try FfiConverterString.lift(url),
                     headers: try FfiConverterOptionDictionaryStringString.lift(headers),
                     body: try FfiConverterOptionString.lift(body)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RestResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRestResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeRestClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RestClient: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRestClient() {
    uniffi_breez_sdk_common_fn_init_callback_vtable_restclient(&UniffiCallbackInterfaceRestClient.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRestClient: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<RestClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RestClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RestClient {
        return RestClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RestClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RestClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RestClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> RestClient {
    return try FfiConverterTypeRestClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestClient_lower(_ value: RestClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRestClient.lower(value)
}


/**
 * Payload of the AES success action, as received from the LNURL endpoint
 *
 * See [`AesSuccessActionDataDecrypted`] for a similar wrapper containing the decrypted payload
 */
public struct AesSuccessActionData {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
     */
    public var ciphertext: String
    /**
     * Base64, initialization vector, exactly 24 characters
     */
    public var iv: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
         */ciphertext: String, 
        /**
         * Base64, initialization vector, exactly 24 characters
         */iv: String) {
        self.description = description
        self.ciphertext = ciphertext
        self.iv = iv
    }
}



extension AesSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: AesSuccessActionData, rhs: AesSuccessActionData) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.ciphertext != rhs.ciphertext {
            return false
        }
        if lhs.iv != rhs.iv {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(ciphertext)
        hasher.combine(iv)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionData {
        return
            try AesSuccessActionData(
                description: FfiConverterString.read(from: &buf), 
                ciphertext: FfiConverterString.read(from: &buf), 
                iv: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.ciphertext, into: &buf)
        FfiConverterString.write(value.iv, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionData_lift(_ buf: RustBuffer) throws -> AesSuccessActionData {
    return try FfiConverterTypeAesSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionData_lower(_ value: AesSuccessActionData) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionData.lower(value)
}


/**
 * Wrapper for the decrypted [`AesSuccessActionData`] payload
 */
public struct AesSuccessActionDataDecrypted {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * Decrypted content
     */
    public var plaintext: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * Decrypted content
         */plaintext: String) {
        self.description = description
        self.plaintext = plaintext
    }
}



extension AesSuccessActionDataDecrypted: Equatable, Hashable {
    public static func ==(lhs: AesSuccessActionDataDecrypted, rhs: AesSuccessActionDataDecrypted) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.plaintext != rhs.plaintext {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(plaintext)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionDataDecrypted: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataDecrypted {
        return
            try AesSuccessActionDataDecrypted(
                description: FfiConverterString.read(from: &buf), 
                plaintext: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionDataDecrypted, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.plaintext, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataDecrypted_lift(_ buf: RustBuffer) throws -> AesSuccessActionDataDecrypted {
    return try FfiConverterTypeAesSuccessActionDataDecrypted.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataDecrypted_lower(_ value: AesSuccessActionDataDecrypted) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionDataDecrypted.lower(value)
}


public struct Bip21Details {
    public var amountSat: UInt64?
    public var assetId: String?
    public var uri: String
    public var extras: [Bip21Extra]
    public var label: String?
    public var message: String?
    public var paymentMethods: [InputType]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSat: UInt64?, assetId: String?, uri: String, extras: [Bip21Extra], label: String?, message: String?, paymentMethods: [InputType]) {
        self.amountSat = amountSat
        self.assetId = assetId
        self.uri = uri
        self.extras = extras
        self.label = label
        self.message = message
        self.paymentMethods = paymentMethods
    }
}



extension Bip21Details: Equatable, Hashable {
    public static func ==(lhs: Bip21Details, rhs: Bip21Details) -> Bool {
        if lhs.amountSat != rhs.amountSat {
            return false
        }
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.uri != rhs.uri {
            return false
        }
        if lhs.extras != rhs.extras {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.paymentMethods != rhs.paymentMethods {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSat)
        hasher.combine(assetId)
        hasher.combine(uri)
        hasher.combine(extras)
        hasher.combine(label)
        hasher.combine(message)
        hasher.combine(paymentMethods)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip21Details: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip21Details {
        return
            try Bip21Details(
                amountSat: FfiConverterOptionUInt64.read(from: &buf), 
                assetId: FfiConverterOptionString.read(from: &buf), 
                uri: FfiConverterString.read(from: &buf), 
                extras: FfiConverterSequenceTypeBip21Extra.read(from: &buf), 
                label: FfiConverterOptionString.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf), 
                paymentMethods: FfiConverterSequenceTypeInputType.read(from: &buf)
        )
    }

    public static func write(_ value: Bip21Details, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.amountSat, into: &buf)
        FfiConverterOptionString.write(value.assetId, into: &buf)
        FfiConverterString.write(value.uri, into: &buf)
        FfiConverterSequenceTypeBip21Extra.write(value.extras, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterSequenceTypeInputType.write(value.paymentMethods, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Details_lift(_ buf: RustBuffer) throws -> Bip21Details {
    return try FfiConverterTypeBip21Details.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Details_lower(_ value: Bip21Details) -> RustBuffer {
    return FfiConverterTypeBip21Details.lower(value)
}


public struct Bip21Extra {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}



extension Bip21Extra: Equatable, Hashable {
    public static func ==(lhs: Bip21Extra, rhs: Bip21Extra) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip21Extra: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip21Extra {
        return
            try Bip21Extra(
                key: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Bip21Extra, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Extra_lift(_ buf: RustBuffer) throws -> Bip21Extra {
    return try FfiConverterTypeBip21Extra.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Extra_lower(_ value: Bip21Extra) -> RustBuffer {
    return FfiConverterTypeBip21Extra.lower(value)
}


public struct BitcoinAddressDetails {
    public var address: String
    public var network: BitcoinNetwork
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, network: BitcoinNetwork, source: PaymentRequestSource) {
        self.address = address
        self.network = network
        self.source = source
    }
}



extension BitcoinAddressDetails: Equatable, Hashable {
    public static func ==(lhs: BitcoinAddressDetails, rhs: BitcoinAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(network)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinAddressDetails {
        return
            try BitcoinAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: BitcoinAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinAddressDetails_lift(_ buf: RustBuffer) throws -> BitcoinAddressDetails {
    return try FfiConverterTypeBitcoinAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinAddressDetails_lower(_ value: BitcoinAddressDetails) -> RustBuffer {
    return FfiConverterTypeBitcoinAddressDetails.lower(value)
}


public struct Bolt11Invoice {
    public var bolt11: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bolt11: String, source: PaymentRequestSource) {
        self.bolt11 = bolt11
        self.source = source
    }
}



extension Bolt11Invoice: Equatable, Hashable {
    public static func ==(lhs: Bolt11Invoice, rhs: Bolt11Invoice) -> Bool {
        if lhs.bolt11 != rhs.bolt11 {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bolt11)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11Invoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Invoice {
        return
            try Bolt11Invoice(
                bolt11: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11Invoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bolt11, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Invoice_lift(_ buf: RustBuffer) throws -> Bolt11Invoice {
    return try FfiConverterTypeBolt11Invoice.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Invoice_lower(_ value: Bolt11Invoice) -> RustBuffer {
    return FfiConverterTypeBolt11Invoice.lower(value)
}


public struct Bolt11InvoiceDetails {
    public var amountMsat: UInt64?
    public var description: String?
    public var descriptionHash: String?
    public var expiry: UInt64
    public var invoice: Bolt11Invoice
    public var minFinalCltvExpiryDelta: UInt64
    public var network: BitcoinNetwork
    public var payeePubkey: String
    public var paymentHash: String
    public var paymentSecret: String
    public var routingHints: [Bolt11RouteHint]
    public var timestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountMsat: UInt64?, description: String?, descriptionHash: String?, expiry: UInt64, invoice: Bolt11Invoice, minFinalCltvExpiryDelta: UInt64, network: BitcoinNetwork, payeePubkey: String, paymentHash: String, paymentSecret: String, routingHints: [Bolt11RouteHint], timestamp: UInt64) {
        self.amountMsat = amountMsat
        self.description = description
        self.descriptionHash = descriptionHash
        self.expiry = expiry
        self.invoice = invoice
        self.minFinalCltvExpiryDelta = minFinalCltvExpiryDelta
        self.network = network
        self.payeePubkey = payeePubkey
        self.paymentHash = paymentHash
        self.paymentSecret = paymentSecret
        self.routingHints = routingHints
        self.timestamp = timestamp
    }
}



extension Bolt11InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt11InvoiceDetails, rhs: Bolt11InvoiceDetails) -> Bool {
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.minFinalCltvExpiryDelta != rhs.minFinalCltvExpiryDelta {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.payeePubkey != rhs.payeePubkey {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.paymentSecret != rhs.paymentSecret {
            return false
        }
        if lhs.routingHints != rhs.routingHints {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountMsat)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(expiry)
        hasher.combine(invoice)
        hasher.combine(minFinalCltvExpiryDelta)
        hasher.combine(network)
        hasher.combine(payeePubkey)
        hasher.combine(paymentHash)
        hasher.combine(paymentSecret)
        hasher.combine(routingHints)
        hasher.combine(timestamp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11InvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11InvoiceDetails {
        return
            try Bolt11InvoiceDetails(
                amountMsat: FfiConverterOptionUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterUInt64.read(from: &buf), 
                invoice: FfiConverterTypeBolt11Invoice.read(from: &buf), 
                minFinalCltvExpiryDelta: FfiConverterUInt64.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                payeePubkey: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                paymentSecret: FfiConverterString.read(from: &buf), 
                routingHints: FfiConverterSequenceTypeBolt11RouteHint.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterUInt64.write(value.expiry, into: &buf)
        FfiConverterTypeBolt11Invoice.write(value.invoice, into: &buf)
        FfiConverterUInt64.write(value.minFinalCltvExpiryDelta, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterString.write(value.payeePubkey, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterString.write(value.paymentSecret, into: &buf)
        FfiConverterSequenceTypeBolt11RouteHint.write(value.routingHints, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11InvoiceDetails_lift(_ buf: RustBuffer) throws -> Bolt11InvoiceDetails {
    return try FfiConverterTypeBolt11InvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11InvoiceDetails_lower(_ value: Bolt11InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeBolt11InvoiceDetails.lower(value)
}


public struct Bolt11RouteHint {
    public var hops: [Bolt11RouteHintHop]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hops: [Bolt11RouteHintHop]) {
        self.hops = hops
    }
}



extension Bolt11RouteHint: Equatable, Hashable {
    public static func ==(lhs: Bolt11RouteHint, rhs: Bolt11RouteHint) -> Bool {
        if lhs.hops != rhs.hops {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hops)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11RouteHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11RouteHint {
        return
            try Bolt11RouteHint(
                hops: FfiConverterSequenceTypeBolt11RouteHintHop.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11RouteHint, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBolt11RouteHintHop.write(value.hops, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHint_lift(_ buf: RustBuffer) throws -> Bolt11RouteHint {
    return try FfiConverterTypeBolt11RouteHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHint_lower(_ value: Bolt11RouteHint) -> RustBuffer {
    return FfiConverterTypeBolt11RouteHint.lower(value)
}


public struct Bolt11RouteHintHop {
    /**
     * The `node_id` of the non-target end of the route
     */
    public var srcNodeId: String
    /**
     * The `short_channel_id` of this channel
     */
    public var shortChannelId: String
    /**
     * The fees which must be paid to use this channel
     */
    public var feesBaseMsat: UInt32
    public var feesProportionalMillionths: UInt32
    /**
     * The difference in CLTV values between this node and the next node.
     */
    public var cltvExpiryDelta: UInt16
    /**
     * The minimum value, in msat, which must be relayed to the next hop.
     */
    public var htlcMinimumMsat: UInt64?
    /**
     * The maximum value in msat available for routing with a single HTLC.
     */
    public var htlcMaximumMsat: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The `node_id` of the non-target end of the route
         */srcNodeId: String, 
        /**
         * The `short_channel_id` of this channel
         */shortChannelId: String, 
        /**
         * The fees which must be paid to use this channel
         */feesBaseMsat: UInt32, feesProportionalMillionths: UInt32, 
        /**
         * The difference in CLTV values between this node and the next node.
         */cltvExpiryDelta: UInt16, 
        /**
         * The minimum value, in msat, which must be relayed to the next hop.
         */htlcMinimumMsat: UInt64?, 
        /**
         * The maximum value in msat available for routing with a single HTLC.
         */htlcMaximumMsat: UInt64?) {
        self.srcNodeId = srcNodeId
        self.shortChannelId = shortChannelId
        self.feesBaseMsat = feesBaseMsat
        self.feesProportionalMillionths = feesProportionalMillionths
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
    }
}



extension Bolt11RouteHintHop: Equatable, Hashable {
    public static func ==(lhs: Bolt11RouteHintHop, rhs: Bolt11RouteHintHop) -> Bool {
        if lhs.srcNodeId != rhs.srcNodeId {
            return false
        }
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.feesBaseMsat != rhs.feesBaseMsat {
            return false
        }
        if lhs.feesProportionalMillionths != rhs.feesProportionalMillionths {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(srcNodeId)
        hasher.combine(shortChannelId)
        hasher.combine(feesBaseMsat)
        hasher.combine(feesProportionalMillionths)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11RouteHintHop: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11RouteHintHop {
        return
            try Bolt11RouteHintHop(
                srcNodeId: FfiConverterString.read(from: &buf), 
                shortChannelId: FfiConverterString.read(from: &buf), 
                feesBaseMsat: FfiConverterUInt32.read(from: &buf), 
                feesProportionalMillionths: FfiConverterUInt32.read(from: &buf), 
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf), 
                htlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                htlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11RouteHintHop, into buf: inout [UInt8]) {
        FfiConverterString.write(value.srcNodeId, into: &buf)
        FfiConverterString.write(value.shortChannelId, into: &buf)
        FfiConverterUInt32.write(value.feesBaseMsat, into: &buf)
        FfiConverterUInt32.write(value.feesProportionalMillionths, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMaximumMsat, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHintHop_lift(_ buf: RustBuffer) throws -> Bolt11RouteHintHop {
    return try FfiConverterTypeBolt11RouteHintHop.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHintHop_lower(_ value: Bolt11RouteHintHop) -> RustBuffer {
    return FfiConverterTypeBolt11RouteHintHop.lower(value)
}


public struct Bolt12Invoice {
    public var invoice: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(invoice: String, source: PaymentRequestSource) {
        self.invoice = invoice
        self.source = source
    }
}



extension Bolt12Invoice: Equatable, Hashable {
    public static func ==(lhs: Bolt12Invoice, rhs: Bolt12Invoice) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12Invoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Invoice {
        return
            try Bolt12Invoice(
                invoice: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12Invoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Invoice_lift(_ buf: RustBuffer) throws -> Bolt12Invoice {
    return try FfiConverterTypeBolt12Invoice.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Invoice_lower(_ value: Bolt12Invoice) -> RustBuffer {
    return FfiConverterTypeBolt12Invoice.lower(value)
}


public struct Bolt12InvoiceDetails {
    public var amountMsat: UInt64
    public var invoice: Bolt12Invoice

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountMsat: UInt64, invoice: Bolt12Invoice) {
        self.amountMsat = amountMsat
        self.invoice = invoice
    }
}



extension Bolt12InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12InvoiceDetails, rhs: Bolt12InvoiceDetails) -> Bool {
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountMsat)
        hasher.combine(invoice)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12InvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12InvoiceDetails {
        return
            try Bolt12InvoiceDetails(
                amountMsat: FfiConverterUInt64.read(from: &buf), 
                invoice: FfiConverterTypeBolt12Invoice.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountMsat, into: &buf)
        FfiConverterTypeBolt12Invoice.write(value.invoice, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceDetails_lift(_ buf: RustBuffer) throws -> Bolt12InvoiceDetails {
    return try FfiConverterTypeBolt12InvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceDetails_lower(_ value: Bolt12InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeBolt12InvoiceDetails.lower(value)
}


public struct Bolt12InvoiceRequestDetails {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension Bolt12InvoiceRequestDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12InvoiceRequestDetails, rhs: Bolt12InvoiceRequestDetails) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12InvoiceRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12InvoiceRequestDetails {
        return
            Bolt12InvoiceRequestDetails()
    }

    public static func write(_ value: Bolt12InvoiceRequestDetails, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceRequestDetails_lift(_ buf: RustBuffer) throws -> Bolt12InvoiceRequestDetails {
    return try FfiConverterTypeBolt12InvoiceRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceRequestDetails_lower(_ value: Bolt12InvoiceRequestDetails) -> RustBuffer {
    return FfiConverterTypeBolt12InvoiceRequestDetails.lower(value)
}


public struct Bolt12Offer {
    public var offer: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(offer: String, source: PaymentRequestSource) {
        self.offer = offer
        self.source = source
    }
}



extension Bolt12Offer: Equatable, Hashable {
    public static func ==(lhs: Bolt12Offer, rhs: Bolt12Offer) -> Bool {
        if lhs.offer != rhs.offer {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(offer)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12Offer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Offer {
        return
            try Bolt12Offer(
                offer: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12Offer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.offer, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Offer_lift(_ buf: RustBuffer) throws -> Bolt12Offer {
    return try FfiConverterTypeBolt12Offer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Offer_lower(_ value: Bolt12Offer) -> RustBuffer {
    return FfiConverterTypeBolt12Offer.lower(value)
}


public struct Bolt12OfferBlindedPath {
    public var blindedHops: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blindedHops: [String]) {
        self.blindedHops = blindedHops
    }
}



extension Bolt12OfferBlindedPath: Equatable, Hashable {
    public static func ==(lhs: Bolt12OfferBlindedPath, rhs: Bolt12OfferBlindedPath) -> Bool {
        if lhs.blindedHops != rhs.blindedHops {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blindedHops)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12OfferBlindedPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12OfferBlindedPath {
        return
            try Bolt12OfferBlindedPath(
                blindedHops: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12OfferBlindedPath, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.blindedHops, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferBlindedPath_lift(_ buf: RustBuffer) throws -> Bolt12OfferBlindedPath {
    return try FfiConverterTypeBolt12OfferBlindedPath.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferBlindedPath_lower(_ value: Bolt12OfferBlindedPath) -> RustBuffer {
    return FfiConverterTypeBolt12OfferBlindedPath.lower(value)
}


public struct Bolt12OfferDetails {
    public var absoluteExpiry: UInt64?
    public var chains: [String]
    public var description: String?
    public var issuer: String?
    public var minAmount: Amount?
    public var offer: Bolt12Offer
    public var paths: [Bolt12OfferBlindedPath]
    public var signingPubkey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(absoluteExpiry: UInt64?, chains: [String], description: String?, issuer: String?, minAmount: Amount?, offer: Bolt12Offer, paths: [Bolt12OfferBlindedPath], signingPubkey: String?) {
        self.absoluteExpiry = absoluteExpiry
        self.chains = chains
        self.description = description
        self.issuer = issuer
        self.minAmount = minAmount
        self.offer = offer
        self.paths = paths
        self.signingPubkey = signingPubkey
    }
}



extension Bolt12OfferDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12OfferDetails, rhs: Bolt12OfferDetails) -> Bool {
        if lhs.absoluteExpiry != rhs.absoluteExpiry {
            return false
        }
        if lhs.chains != rhs.chains {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.issuer != rhs.issuer {
            return false
        }
        if lhs.minAmount != rhs.minAmount {
            return false
        }
        if lhs.offer != rhs.offer {
            return false
        }
        if lhs.paths != rhs.paths {
            return false
        }
        if lhs.signingPubkey != rhs.signingPubkey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(absoluteExpiry)
        hasher.combine(chains)
        hasher.combine(description)
        hasher.combine(issuer)
        hasher.combine(minAmount)
        hasher.combine(offer)
        hasher.combine(paths)
        hasher.combine(signingPubkey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12OfferDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12OfferDetails {
        return
            try Bolt12OfferDetails(
                absoluteExpiry: FfiConverterOptionUInt64.read(from: &buf), 
                chains: FfiConverterSequenceString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                issuer: FfiConverterOptionString.read(from: &buf), 
                minAmount: FfiConverterOptionTypeAmount.read(from: &buf), 
                offer: FfiConverterTypeBolt12Offer.read(from: &buf), 
                paths: FfiConverterSequenceTypeBolt12OfferBlindedPath.read(from: &buf), 
                signingPubkey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12OfferDetails, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.absoluteExpiry, into: &buf)
        FfiConverterSequenceString.write(value.chains, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.issuer, into: &buf)
        FfiConverterOptionTypeAmount.write(value.minAmount, into: &buf)
        FfiConverterTypeBolt12Offer.write(value.offer, into: &buf)
        FfiConverterSequenceTypeBolt12OfferBlindedPath.write(value.paths, into: &buf)
        FfiConverterOptionString.write(value.signingPubkey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferDetails_lift(_ buf: RustBuffer) throws -> Bolt12OfferDetails {
    return try FfiConverterTypeBolt12OfferDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferDetails_lower(_ value: Bolt12OfferDetails) -> RustBuffer {
    return FfiConverterTypeBolt12OfferDetails.lower(value)
}


/**
 * Details about a supported currency in the fiat rate feed
 */
public struct CurrencyInfo {
    public var name: String
    public var fractionSize: UInt32
    public var spacing: UInt32?
    public var symbol: Symbol?
    public var uniqSymbol: Symbol?
    public var localizedName: [LocalizedName]
    public var localeOverrides: [LocaleOverrides]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, fractionSize: UInt32, spacing: UInt32?, symbol: Symbol?, uniqSymbol: Symbol?, localizedName: [LocalizedName], localeOverrides: [LocaleOverrides]) {
        self.name = name
        self.fractionSize = fractionSize
        self.spacing = spacing
        self.symbol = symbol
        self.uniqSymbol = uniqSymbol
        self.localizedName = localizedName
        self.localeOverrides = localeOverrides
    }
}



extension CurrencyInfo: Equatable, Hashable {
    public static func ==(lhs: CurrencyInfo, rhs: CurrencyInfo) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.fractionSize != rhs.fractionSize {
            return false
        }
        if lhs.spacing != rhs.spacing {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.uniqSymbol != rhs.uniqSymbol {
            return false
        }
        if lhs.localizedName != rhs.localizedName {
            return false
        }
        if lhs.localeOverrides != rhs.localeOverrides {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(fractionSize)
        hasher.combine(spacing)
        hasher.combine(symbol)
        hasher.combine(uniqSymbol)
        hasher.combine(localizedName)
        hasher.combine(localeOverrides)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCurrencyInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurrencyInfo {
        return
            try CurrencyInfo(
                name: FfiConverterString.read(from: &buf), 
                fractionSize: FfiConverterUInt32.read(from: &buf), 
                spacing: FfiConverterOptionUInt32.read(from: &buf), 
                symbol: FfiConverterOptionTypeSymbol.read(from: &buf), 
                uniqSymbol: FfiConverterOptionTypeSymbol.read(from: &buf), 
                localizedName: FfiConverterSequenceTypeLocalizedName.read(from: &buf), 
                localeOverrides: FfiConverterSequenceTypeLocaleOverrides.read(from: &buf)
        )
    }

    public static func write(_ value: CurrencyInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt32.write(value.fractionSize, into: &buf)
        FfiConverterOptionUInt32.write(value.spacing, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.symbol, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.uniqSymbol, into: &buf)
        FfiConverterSequenceTypeLocalizedName.write(value.localizedName, into: &buf)
        FfiConverterSequenceTypeLocaleOverrides.write(value.localeOverrides, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrencyInfo_lift(_ buf: RustBuffer) throws -> CurrencyInfo {
    return try FfiConverterTypeCurrencyInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrencyInfo_lower(_ value: CurrencyInfo) -> RustBuffer {
    return FfiConverterTypeCurrencyInfo.lower(value)
}


/**
 * Wrapper around the [`CurrencyInfo`] of a fiat currency
 */
public struct FiatCurrency {
    public var id: String
    public var info: CurrencyInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, info: CurrencyInfo) {
        self.id = id
        self.info = info
    }
}



extension FiatCurrency: Equatable, Hashable {
    public static func ==(lhs: FiatCurrency, rhs: FiatCurrency) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.info != rhs.info {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(info)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        return
            try FiatCurrency(
                id: FfiConverterString.read(from: &buf), 
                info: FfiConverterTypeCurrencyInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeCurrencyInfo.write(value.info, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}


public struct LightningAddressDetails {
    public var address: String
    public var payRequest: LnurlPayRequestDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, payRequest: LnurlPayRequestDetails) {
        self.address = address
        self.payRequest = payRequest
    }
}



extension LightningAddressDetails: Equatable, Hashable {
    public static func ==(lhs: LightningAddressDetails, rhs: LightningAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(payRequest)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningAddressDetails {
        return
            try LightningAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf)
        )
    }

    public static func write(_ value: LightningAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressDetails_lift(_ buf: RustBuffer) throws -> LightningAddressDetails {
    return try FfiConverterTypeLightningAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressDetails_lower(_ value: LightningAddressDetails) -> RustBuffer {
    return FfiConverterTypeLightningAddressDetails.lower(value)
}


/**
 * Wrapped in a [`LnurlAuth`], this is the result of [`parse`] when given a LNURL-auth endpoint.
 *
 * It represents the endpoint's parameters for the LNURL workflow.
 *
 * See <https://github.com/lnurl/luds/blob/luds/04.md>
 */
public struct LnurlAuthRequestDetails {
    /**
     * Hex encoded 32 bytes of challenge
     */
    public var k1: String
    /**
     * When available, one of: register, login, link, auth
     */
    public var action: String?
    /**
     * Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
     * auth confirmation, as per LUD-04 spec.
     */
    public var domain: String
    /**
     * Indicates the URL of the LNURL-auth service, including the query arguments. This will be
     * extended with the signed challenge and the linking key, then called in the second step of the workflow.
     */
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex encoded 32 bytes of challenge
         */k1: String, 
        /**
         * When available, one of: register, login, link, auth
         */action: String?, 
        /**
         * Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
         * auth confirmation, as per LUD-04 spec.
         */domain: String, 
        /**
         * Indicates the URL of the LNURL-auth service, including the query arguments. This will be
         * extended with the signed challenge and the linking key, then called in the second step of the workflow.
         */url: String) {
        self.k1 = k1
        self.action = action
        self.domain = domain
        self.url = url
    }
}



extension LnurlAuthRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlAuthRequestDetails, rhs: LnurlAuthRequestDetails) -> Bool {
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(k1)
        hasher.combine(action)
        hasher.combine(domain)
        hasher.combine(url)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlAuthRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlAuthRequestDetails {
        return
            try LnurlAuthRequestDetails(
                k1: FfiConverterString.read(from: &buf), 
                action: FfiConverterOptionString.read(from: &buf), 
                domain: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlAuthRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterOptionString.write(value.action, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlAuthRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlAuthRequestDetails {
    return try FfiConverterTypeLnurlAuthRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlAuthRequestDetails_lower(_ value: LnurlAuthRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlAuthRequestDetails.lower(value)
}


/**
 * Wrapped in a [`LnUrlError`], this represents a LNURL-endpoint error.
 */
public struct LnurlErrorDetails {
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(reason: String) {
        self.reason = reason
    }
}



extension LnurlErrorDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlErrorDetails, rhs: LnurlErrorDetails) -> Bool {
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reason)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlErrorDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlErrorDetails {
        return
            try LnurlErrorDetails(
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlErrorDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlErrorDetails_lift(_ buf: RustBuffer) throws -> LnurlErrorDetails {
    return try FfiConverterTypeLnurlErrorDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlErrorDetails_lower(_ value: LnurlErrorDetails) -> RustBuffer {
    return FfiConverterTypeLnurlErrorDetails.lower(value)
}


public struct LnurlPayRequestDetails {
    public var callback: String
    /**
     * The minimum amount, in millisats, that this LNURL-pay endpoint accepts
     */
    public var minSendable: UInt64
    /**
     * The maximum amount, in millisats, that this LNURL-pay endpoint accepts
     */
    public var maxSendable: UInt64
    /**
     * As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
     * Use `metadata_vec()` to get the parsed items.
     */
    public var metadataStr: String
    /**
     * The comment length accepted by this endpoint
     *
     * See <https://github.com/lnurl/luds/blob/luds/12.md>
     */
    public var commentAllowed: UInt16
    /**
     * Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
     * payment input, as per LUD-06 spec.
     *
     * Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
     */
    public var domain: String
    public var url: String
    /**
     * Optional lightning address if that was used to resolve the lnurl.
     */
    public var address: String?
    /**
     * Value indicating whether the recipient supports Nostr Zaps through NIP-57.
     *
     * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
     */
    public var allowsNostr: Bool
    /**
     * Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
     * valid BIP 340 public key in hex.
     *
     * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
     * See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
     */
    public var nostrPubkey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, 
        /**
         * The minimum amount, in millisats, that this LNURL-pay endpoint accepts
         */minSendable: UInt64, 
        /**
         * The maximum amount, in millisats, that this LNURL-pay endpoint accepts
         */maxSendable: UInt64, 
        /**
         * As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
         * Use `metadata_vec()` to get the parsed items.
         */metadataStr: String, 
        /**
         * The comment length accepted by this endpoint
         *
         * See <https://github.com/lnurl/luds/blob/luds/12.md>
         */commentAllowed: UInt16, 
        /**
         * Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
         * payment input, as per LUD-06 spec.
         *
         * Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
         */domain: String, url: String, 
        /**
         * Optional lightning address if that was used to resolve the lnurl.
         */address: String?, 
        /**
         * Value indicating whether the recipient supports Nostr Zaps through NIP-57.
         *
         * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
         */allowsNostr: Bool, 
        /**
         * Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
         * valid BIP 340 public key in hex.
         *
         * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
         * See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
         */nostrPubkey: String?) {
        self.callback = callback
        self.minSendable = minSendable
        self.maxSendable = maxSendable
        self.metadataStr = metadataStr
        self.commentAllowed = commentAllowed
        self.domain = domain
        self.url = url
        self.address = address
        self.allowsNostr = allowsNostr
        self.nostrPubkey = nostrPubkey
    }
}



extension LnurlPayRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlPayRequestDetails, rhs: LnurlPayRequestDetails) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.minSendable != rhs.minSendable {
            return false
        }
        if lhs.maxSendable != rhs.maxSendable {
            return false
        }
        if lhs.metadataStr != rhs.metadataStr {
            return false
        }
        if lhs.commentAllowed != rhs.commentAllowed {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.allowsNostr != rhs.allowsNostr {
            return false
        }
        if lhs.nostrPubkey != rhs.nostrPubkey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(minSendable)
        hasher.combine(maxSendable)
        hasher.combine(metadataStr)
        hasher.combine(commentAllowed)
        hasher.combine(domain)
        hasher.combine(url)
        hasher.combine(address)
        hasher.combine(allowsNostr)
        hasher.combine(nostrPubkey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayRequestDetails {
        return
            try LnurlPayRequestDetails(
                callback: FfiConverterString.read(from: &buf), 
                minSendable: FfiConverterUInt64.read(from: &buf), 
                maxSendable: FfiConverterUInt64.read(from: &buf), 
                metadataStr: FfiConverterString.read(from: &buf), 
                commentAllowed: FfiConverterUInt16.read(from: &buf), 
                domain: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                address: FfiConverterOptionString.read(from: &buf), 
                allowsNostr: FfiConverterBool.read(from: &buf), 
                nostrPubkey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterUInt64.write(value.minSendable, into: &buf)
        FfiConverterUInt64.write(value.maxSendable, into: &buf)
        FfiConverterString.write(value.metadataStr, into: &buf)
        FfiConverterUInt16.write(value.commentAllowed, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.address, into: &buf)
        FfiConverterBool.write(value.allowsNostr, into: &buf)
        FfiConverterOptionString.write(value.nostrPubkey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlPayRequestDetails {
    return try FfiConverterTypeLnurlPayRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequestDetails_lower(_ value: LnurlPayRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlPayRequestDetails.lower(value)
}


public struct LnurlWithdrawRequestDetails {
    public var callback: String
    public var k1: String
    public var defaultDescription: String
    /**
     * The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
     */
    public var minWithdrawable: UInt64
    /**
     * The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
     */
    public var maxWithdrawable: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, k1: String, defaultDescription: String, 
        /**
         * The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
         */minWithdrawable: UInt64, 
        /**
         * The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
         */maxWithdrawable: UInt64) {
        self.callback = callback
        self.k1 = k1
        self.defaultDescription = defaultDescription
        self.minWithdrawable = minWithdrawable
        self.maxWithdrawable = maxWithdrawable
    }
}



extension LnurlWithdrawRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawRequestDetails, rhs: LnurlWithdrawRequestDetails) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.defaultDescription != rhs.defaultDescription {
            return false
        }
        if lhs.minWithdrawable != rhs.minWithdrawable {
            return false
        }
        if lhs.maxWithdrawable != rhs.maxWithdrawable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(k1)
        hasher.combine(defaultDescription)
        hasher.combine(minWithdrawable)
        hasher.combine(maxWithdrawable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawRequestDetails {
        return
            try LnurlWithdrawRequestDetails(
                callback: FfiConverterString.read(from: &buf), 
                k1: FfiConverterString.read(from: &buf), 
                defaultDescription: FfiConverterString.read(from: &buf), 
                minWithdrawable: FfiConverterUInt64.read(from: &buf), 
                maxWithdrawable: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterString.write(value.defaultDescription, into: &buf)
        FfiConverterUInt64.write(value.minWithdrawable, into: &buf)
        FfiConverterUInt64.write(value.maxWithdrawable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlWithdrawRequestDetails {
    return try FfiConverterTypeLnurlWithdrawRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequestDetails_lower(_ value: LnurlWithdrawRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawRequestDetails.lower(value)
}


/**
 * Locale-specific settings for the representation of a currency
 */
public struct LocaleOverrides {
    public var locale: String
    public var spacing: UInt32?
    public var symbol: Symbol

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locale: String, spacing: UInt32?, symbol: Symbol) {
        self.locale = locale
        self.spacing = spacing
        self.symbol = symbol
    }
}



extension LocaleOverrides: Equatable, Hashable {
    public static func ==(lhs: LocaleOverrides, rhs: LocaleOverrides) -> Bool {
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.spacing != rhs.spacing {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locale)
        hasher.combine(spacing)
        hasher.combine(symbol)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocaleOverrides: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleOverrides {
        return
            try LocaleOverrides(
                locale: FfiConverterString.read(from: &buf), 
                spacing: FfiConverterOptionUInt32.read(from: &buf), 
                symbol: FfiConverterTypeSymbol.read(from: &buf)
        )
    }

    public static func write(_ value: LocaleOverrides, into buf: inout [UInt8]) {
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterOptionUInt32.write(value.spacing, into: &buf)
        FfiConverterTypeSymbol.write(value.symbol, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocaleOverrides_lift(_ buf: RustBuffer) throws -> LocaleOverrides {
    return try FfiConverterTypeLocaleOverrides.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocaleOverrides_lower(_ value: LocaleOverrides) -> RustBuffer {
    return FfiConverterTypeLocaleOverrides.lower(value)
}


/**
 * Localized name of a currency
 */
public struct LocalizedName {
    public var locale: String
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locale: String, name: String) {
        self.locale = locale
        self.name = name
    }
}



extension LocalizedName: Equatable, Hashable {
    public static func ==(lhs: LocalizedName, rhs: LocalizedName) -> Bool {
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locale)
        hasher.combine(name)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalizedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalizedName {
        return
            try LocalizedName(
                locale: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LocalizedName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalizedName_lift(_ buf: RustBuffer) throws -> LocalizedName {
    return try FfiConverterTypeLocalizedName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalizedName_lower(_ value: LocalizedName) -> RustBuffer {
    return FfiConverterTypeLocalizedName.lower(value)
}


public struct MessageSuccessActionData {
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String) {
        self.message = message
    }
}



extension MessageSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: MessageSuccessActionData, rhs: MessageSuccessActionData) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageSuccessActionData {
        return
            try MessageSuccessActionData(
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageSuccessActionData_lift(_ buf: RustBuffer) throws -> MessageSuccessActionData {
    return try FfiConverterTypeMessageSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageSuccessActionData_lower(_ value: MessageSuccessActionData) -> RustBuffer {
    return FfiConverterTypeMessageSuccessActionData.lower(value)
}


public struct PaymentRequestSource {
    public var bip21Uri: String?
    public var bip353Address: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bip21Uri: String?, bip353Address: String?) {
        self.bip21Uri = bip21Uri
        self.bip353Address = bip353Address
    }
}



extension PaymentRequestSource: Equatable, Hashable {
    public static func ==(lhs: PaymentRequestSource, rhs: PaymentRequestSource) -> Bool {
        if lhs.bip21Uri != rhs.bip21Uri {
            return false
        }
        if lhs.bip353Address != rhs.bip353Address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bip21Uri)
        hasher.combine(bip353Address)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentRequestSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentRequestSource {
        return
            try PaymentRequestSource(
                bip21Uri: FfiConverterOptionString.read(from: &buf), 
                bip353Address: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentRequestSource, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.bip21Uri, into: &buf)
        FfiConverterOptionString.write(value.bip353Address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentRequestSource_lift(_ buf: RustBuffer) throws -> PaymentRequestSource {
    return try FfiConverterTypePaymentRequestSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentRequestSource_lower(_ value: PaymentRequestSource) -> RustBuffer {
    return FfiConverterTypePaymentRequestSource.lower(value)
}


/**
 * Denominator in an exchange rate
 */
public struct Rate {
    public var coin: String
    public var value: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(coin: String, value: Double) {
        self.coin = coin
        self.value = value
    }
}



extension Rate: Equatable, Hashable {
    public static func ==(lhs: Rate, rhs: Rate) -> Bool {
        if lhs.coin != rhs.coin {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(coin)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rate {
        return
            try Rate(
                coin: FfiConverterString.read(from: &buf), 
                value: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Rate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.coin, into: &buf)
        FfiConverterDouble.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRate_lift(_ buf: RustBuffer) throws -> Rate {
    return try FfiConverterTypeRate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRate_lower(_ value: Rate) -> RustBuffer {
    return FfiConverterTypeRate.lower(value)
}


public struct RestResponse {
    public var status: UInt16
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(status: UInt16, body: String) {
        self.status = status
        self.body = body
    }
}



extension RestResponse: Equatable, Hashable {
    public static func ==(lhs: RestResponse, rhs: RestResponse) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(body)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRestResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RestResponse {
        return
            try RestResponse(
                status: FfiConverterUInt16.read(from: &buf), 
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RestResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.status, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestResponse_lift(_ buf: RustBuffer) throws -> RestResponse {
    return try FfiConverterTypeRestResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestResponse_lower(_ value: RestResponse) -> RustBuffer {
    return FfiConverterTypeRestResponse.lower(value)
}


public struct SatsPaymentDetails {
    public var amount: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: UInt64?) {
        self.amount = amount
    }
}



extension SatsPaymentDetails: Equatable, Hashable {
    public static func ==(lhs: SatsPaymentDetails, rhs: SatsPaymentDetails) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSatsPaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SatsPaymentDetails {
        return
            try SatsPaymentDetails(
                amount: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SatsPaymentDetails, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatsPaymentDetails_lift(_ buf: RustBuffer) throws -> SatsPaymentDetails {
    return try FfiConverterTypeSatsPaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSatsPaymentDetails_lower(_ value: SatsPaymentDetails) -> RustBuffer {
    return FfiConverterTypeSatsPaymentDetails.lower(value)
}


public struct SilentPaymentAddressDetails {
    public var address: String
    public var network: BitcoinNetwork
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, network: BitcoinNetwork, source: PaymentRequestSource) {
        self.address = address
        self.network = network
        self.source = source
    }
}



extension SilentPaymentAddressDetails: Equatable, Hashable {
    public static func ==(lhs: SilentPaymentAddressDetails, rhs: SilentPaymentAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(network)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSilentPaymentAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SilentPaymentAddressDetails {
        return
            try SilentPaymentAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: SilentPaymentAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSilentPaymentAddressDetails_lift(_ buf: RustBuffer) throws -> SilentPaymentAddressDetails {
    return try FfiConverterTypeSilentPaymentAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSilentPaymentAddressDetails_lower(_ value: SilentPaymentAddressDetails) -> RustBuffer {
    return FfiConverterTypeSilentPaymentAddressDetails.lower(value)
}


public struct SparkAddress {
    public var identityPublicKey: String
    public var network: BitcoinNetwork
    public var sparkInvoiceFields: SparkInvoiceFields?
    public var signature: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityPublicKey: String, network: BitcoinNetwork, sparkInvoiceFields: SparkInvoiceFields?, signature: String?) {
        self.identityPublicKey = identityPublicKey
        self.network = network
        self.sparkInvoiceFields = sparkInvoiceFields
        self.signature = signature
    }
}



extension SparkAddress: Equatable, Hashable {
    public static func ==(lhs: SparkAddress, rhs: SparkAddress) -> Bool {
        if lhs.identityPublicKey != rhs.identityPublicKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.sparkInvoiceFields != rhs.sparkInvoiceFields {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityPublicKey)
        hasher.combine(network)
        hasher.combine(sparkInvoiceFields)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkAddress {
        return
            try SparkAddress(
                identityPublicKey: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                sparkInvoiceFields: FfiConverterOptionTypeSparkInvoiceFields.read(from: &buf), 
                signature: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparkAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identityPublicKey, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterOptionTypeSparkInvoiceFields.write(value.sparkInvoiceFields, into: &buf)
        FfiConverterOptionString.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddress_lift(_ buf: RustBuffer) throws -> SparkAddress {
    return try FfiConverterTypeSparkAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddress_lower(_ value: SparkAddress) -> RustBuffer {
    return FfiConverterTypeSparkAddress.lower(value)
}


public struct SparkAddressDetails {
    public var address: String
    public var decodedAddress: SparkAddress
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, decodedAddress: SparkAddress, source: PaymentRequestSource) {
        self.address = address
        self.decodedAddress = decodedAddress
        self.source = source
    }
}



extension SparkAddressDetails: Equatable, Hashable {
    public static func ==(lhs: SparkAddressDetails, rhs: SparkAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.decodedAddress != rhs.decodedAddress {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(decodedAddress)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkAddressDetails {
        return
            try SparkAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                decodedAddress: FfiConverterTypeSparkAddress.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: SparkAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeSparkAddress.write(value.decodedAddress, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddressDetails_lift(_ buf: RustBuffer) throws -> SparkAddressDetails {
    return try FfiConverterTypeSparkAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddressDetails_lower(_ value: SparkAddressDetails) -> RustBuffer {
    return FfiConverterTypeSparkAddressDetails.lower(value)
}


public struct SparkInvoiceFields {
    public var id: String
    public var version: UInt32
    public var memo: String?
    public var senderPublicKey: String?
    public var expiryTime: UInt64?
    public var paymentType: SparkAddressPaymentType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, version: UInt32, memo: String?, senderPublicKey: String?, expiryTime: UInt64?, paymentType: SparkAddressPaymentType?) {
        self.id = id
        self.version = version
        self.memo = memo
        self.senderPublicKey = senderPublicKey
        self.expiryTime = expiryTime
        self.paymentType = paymentType
    }
}



extension SparkInvoiceFields: Equatable, Hashable {
    public static func ==(lhs: SparkInvoiceFields, rhs: SparkInvoiceFields) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.memo != rhs.memo {
            return false
        }
        if lhs.senderPublicKey != rhs.senderPublicKey {
            return false
        }
        if lhs.expiryTime != rhs.expiryTime {
            return false
        }
        if lhs.paymentType != rhs.paymentType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(version)
        hasher.combine(memo)
        hasher.combine(senderPublicKey)
        hasher.combine(expiryTime)
        hasher.combine(paymentType)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkInvoiceFields: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkInvoiceFields {
        return
            try SparkInvoiceFields(
                id: FfiConverterString.read(from: &buf), 
                version: FfiConverterUInt32.read(from: &buf), 
                memo: FfiConverterOptionString.read(from: &buf), 
                senderPublicKey: FfiConverterOptionString.read(from: &buf), 
                expiryTime: FfiConverterOptionUInt64.read(from: &buf), 
                paymentType: FfiConverterOptionTypeSparkAddressPaymentType.read(from: &buf)
        )
    }

    public static func write(_ value: SparkInvoiceFields, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterUInt32.write(value.version, into: &buf)
        FfiConverterOptionString.write(value.memo, into: &buf)
        FfiConverterOptionString.write(value.senderPublicKey, into: &buf)
        FfiConverterOptionUInt64.write(value.expiryTime, into: &buf)
        FfiConverterOptionTypeSparkAddressPaymentType.write(value.paymentType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoiceFields_lift(_ buf: RustBuffer) throws -> SparkInvoiceFields {
    return try FfiConverterTypeSparkInvoiceFields.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoiceFields_lower(_ value: SparkInvoiceFields) -> RustBuffer {
    return FfiConverterTypeSparkInvoiceFields.lower(value)
}


/**
 * Settings for the symbol representation of a currency
 */
public struct Symbol {
    public var grapheme: String?
    public var template: String?
    public var rtl: Bool?
    public var position: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(grapheme: String?, template: String?, rtl: Bool?, position: UInt32?) {
        self.grapheme = grapheme
        self.template = template
        self.rtl = rtl
        self.position = position
    }
}



extension Symbol: Equatable, Hashable {
    public static func ==(lhs: Symbol, rhs: Symbol) -> Bool {
        if lhs.grapheme != rhs.grapheme {
            return false
        }
        if lhs.template != rhs.template {
            return false
        }
        if lhs.rtl != rhs.rtl {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(grapheme)
        hasher.combine(template)
        hasher.combine(rtl)
        hasher.combine(position)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSymbol: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Symbol {
        return
            try Symbol(
                grapheme: FfiConverterOptionString.read(from: &buf), 
                template: FfiConverterOptionString.read(from: &buf), 
                rtl: FfiConverterOptionBool.read(from: &buf), 
                position: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Symbol, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.grapheme, into: &buf)
        FfiConverterOptionString.write(value.template, into: &buf)
        FfiConverterOptionBool.write(value.rtl, into: &buf)
        FfiConverterOptionUInt32.write(value.position, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSymbol_lift(_ buf: RustBuffer) throws -> Symbol {
    return try FfiConverterTypeSymbol.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSymbol_lower(_ value: Symbol) -> RustBuffer {
    return FfiConverterTypeSymbol.lower(value)
}


public struct TokensPaymentDetails {
    public var tokenIdentifier: String?
    public var amount: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokenIdentifier: String?, amount: UInt64?) {
        self.tokenIdentifier = tokenIdentifier
        self.amount = amount
    }
}



extension TokensPaymentDetails: Equatable, Hashable {
    public static func ==(lhs: TokensPaymentDetails, rhs: TokensPaymentDetails) -> Bool {
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokenIdentifier)
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokensPaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokensPaymentDetails {
        return
            try TokensPaymentDetails(
                tokenIdentifier: FfiConverterOptionString.read(from: &buf), 
                amount: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TokensPaymentDetails, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
        FfiConverterOptionUInt64.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokensPaymentDetails_lift(_ buf: RustBuffer) throws -> TokensPaymentDetails {
    return try FfiConverterTypeTokensPaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokensPaymentDetails_lower(_ value: TokensPaymentDetails) -> RustBuffer {
    return FfiConverterTypeTokensPaymentDetails.lower(value)
}


public struct UrlSuccessActionData {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * URL of the success action
     */
    public var url: String
    /**
     * Indicates the success URL domain matches the LNURL callback domain.
     *
     * See <https://github.com/lnurl/luds/blob/luds/09.md>
     */
    public var matchesCallbackDomain: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * URL of the success action
         */url: String, 
        /**
         * Indicates the success URL domain matches the LNURL callback domain.
         *
         * See <https://github.com/lnurl/luds/blob/luds/09.md>
         */matchesCallbackDomain: Bool) {
        self.description = description
        self.url = url
        self.matchesCallbackDomain = matchesCallbackDomain
    }
}



extension UrlSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: UrlSuccessActionData, rhs: UrlSuccessActionData) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.matchesCallbackDomain != rhs.matchesCallbackDomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(matchesCallbackDomain)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUrlSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlSuccessActionData {
        return
            try UrlSuccessActionData(
                description: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                matchesCallbackDomain: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UrlSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterBool.write(value.matchesCallbackDomain, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrlSuccessActionData_lift(_ buf: RustBuffer) throws -> UrlSuccessActionData {
    return try FfiConverterTypeUrlSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrlSuccessActionData_lower(_ value: UrlSuccessActionData) -> RustBuffer {
    return FfiConverterTypeUrlSuccessActionData.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of decryption of [`AesSuccessActionData`] payload
 */

public enum AesSuccessActionDataResult {
    
    case decrypted(data: AesSuccessActionDataDecrypted
    )
    case errorStatus(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionDataResult: FfiConverterRustBuffer {
    typealias SwiftType = AesSuccessActionDataResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .decrypted(data: try FfiConverterTypeAesSuccessActionDataDecrypted.read(from: &buf)
        )
        
        case 2: return .errorStatus(reason: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AesSuccessActionDataResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .decrypted(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataDecrypted.write(data, into: &buf)
            
        
        case let .errorStatus(reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataResult_lift(_ buf: RustBuffer) throws -> AesSuccessActionDataResult {
    return try FfiConverterTypeAesSuccessActionDataResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataResult_lower(_ value: AesSuccessActionDataResult) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionDataResult.lower(value)
}



extension AesSuccessActionDataResult: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Amount {
    
    case bitcoin(amountMsat: UInt64
    )
    /**
     * An amount of currency specified using ISO 4712.
     */
    case currency(
        /**
         * The currency that the amount is denominated in.
         */iso4217Code: String, 
        /**
         * The amount in the currency unit adjusted by the ISO 4712 exponent (e.g., USD cents).
         */fractionalAmount: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin(amountMsat: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .currency(iso4217Code: try FfiConverterString.read(from: &buf), fractionalAmount: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoin(amountMsat):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amountMsat, into: &buf)
            
        
        case let .currency(iso4217Code,fractionalAmount):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(iso4217Code, into: &buf)
            FfiConverterUInt64.write(fractionalAmount, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ buf: RustBuffer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> RustBuffer {
    return FfiConverterTypeAmount.lower(value)
}



extension Amount: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BitcoinNetwork {
    
    /**
     * Mainnet
     */
    case bitcoin
    case testnet3
    case testnet4
    case signet
    case regtest
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinNetwork: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet3
        
        case 3: return .testnet4
        
        case 4: return .signet
        
        case 5: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinNetwork, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet3:
            writeInt(&buf, Int32(2))
        
        
        case .testnet4:
            writeInt(&buf, Int32(3))
        
        
        case .signet:
            writeInt(&buf, Int32(4))
        
        
        case .regtest:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinNetwork_lift(_ buf: RustBuffer) throws -> BitcoinNetwork {
    return try FfiConverterTypeBitcoinNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinNetwork_lower(_ value: BitcoinNetwork) -> RustBuffer {
    return FfiConverterTypeBitcoinNetwork.lower(value)
}



extension BitcoinNetwork: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum InputType {
    
    case bitcoinAddress(BitcoinAddressDetails
    )
    case bolt11Invoice(Bolt11InvoiceDetails
    )
    case bolt12Invoice(Bolt12InvoiceDetails
    )
    case bolt12Offer(Bolt12OfferDetails
    )
    case lightningAddress(LightningAddressDetails
    )
    case lnurlPay(LnurlPayRequestDetails
    )
    case silentPaymentAddress(SilentPaymentAddressDetails
    )
    case lnurlAuth(LnurlAuthRequestDetails
    )
    case url(String
    )
    case bip21(Bip21Details
    )
    case bolt12InvoiceRequest(Bolt12InvoiceRequestDetails
    )
    case lnurlWithdraw(LnurlWithdrawRequestDetails
    )
    case sparkAddress(SparkAddressDetails
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = InputType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(try FfiConverterTypeBitcoinAddressDetails.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(try FfiConverterTypeBolt11InvoiceDetails.read(from: &buf)
        )
        
        case 3: return .bolt12Invoice(try FfiConverterTypeBolt12InvoiceDetails.read(from: &buf)
        )
        
        case 4: return .bolt12Offer(try FfiConverterTypeBolt12OfferDetails.read(from: &buf)
        )
        
        case 5: return .lightningAddress(try FfiConverterTypeLightningAddressDetails.read(from: &buf)
        )
        
        case 6: return .lnurlPay(try FfiConverterTypeLnurlPayRequestDetails.read(from: &buf)
        )
        
        case 7: return .silentPaymentAddress(try FfiConverterTypeSilentPaymentAddressDetails.read(from: &buf)
        )
        
        case 8: return .lnurlAuth(try FfiConverterTypeLnurlAuthRequestDetails.read(from: &buf)
        )
        
        case 9: return .url(try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .bip21(try FfiConverterTypeBip21Details.read(from: &buf)
        )
        
        case 11: return .bolt12InvoiceRequest(try FfiConverterTypeBolt12InvoiceRequestDetails.read(from: &buf)
        )
        
        case 12: return .lnurlWithdraw(try FfiConverterTypeLnurlWithdrawRequestDetails.read(from: &buf)
        )
        
        case 13: return .sparkAddress(try FfiConverterTypeSparkAddressDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InputType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressDetails.write(v1, into: &buf)
            
        
        case let .bolt11Invoice(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBolt11InvoiceDetails.write(v1, into: &buf)
            
        
        case let .bolt12Invoice(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBolt12InvoiceDetails.write(v1, into: &buf)
            
        
        case let .bolt12Offer(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBolt12OfferDetails.write(v1, into: &buf)
            
        
        case let .lightningAddress(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeLightningAddressDetails.write(v1, into: &buf)
            
        
        case let .lnurlPay(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLnurlPayRequestDetails.write(v1, into: &buf)
            
        
        case let .silentPaymentAddress(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeSilentPaymentAddressDetails.write(v1, into: &buf)
            
        
        case let .lnurlAuth(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeLnurlAuthRequestDetails.write(v1, into: &buf)
            
        
        case let .url(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .bip21(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeBip21Details.write(v1, into: &buf)
            
        
        case let .bolt12InvoiceRequest(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeBolt12InvoiceRequestDetails.write(v1, into: &buf)
            
        
        case let .lnurlWithdraw(v1):
            writeInt(&buf, Int32(12))
            FfiConverterTypeLnurlWithdrawRequestDetails.write(v1, into: &buf)
            
        
        case let .sparkAddress(v1):
            writeInt(&buf, Int32(13))
            FfiConverterTypeSparkAddressDetails.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputType_lift(_ buf: RustBuffer) throws -> InputType {
    return try FfiConverterTypeInputType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputType_lower(_ value: InputType) -> RustBuffer {
    return FfiConverterTypeInputType.lower(value)
}



extension InputType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Contains the result of the entire LNURL interaction, as reported by the LNURL endpoint.
 *
 * * `Ok` indicates the interaction with the endpoint was valid, and the endpoint
 * - started to pay the invoice asynchronously in the case of LNURL-withdraw,
 * - verified the client signature in the case of LNURL-auth
 * * `Error` indicates a generic issue the LNURL endpoint encountered, including a freetext
 * description of the reason.
 *
 * Both cases are described in LUD-03 <https://github.com/lnurl/luds/blob/luds/03.md> & LUD-04: <https://github.com/lnurl/luds/blob/luds/04.md>
 */

public enum LnurlCallbackStatus {
    
    /**
     * On-wire format is: `{"status": "OK"}`
     */
    case ok
    /**
     * On-wire format is: `{"status": "ERROR", "reason": "error details..."}`
     */
    case errorStatus(errorDetails: LnurlErrorDetails
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlCallbackStatus: FfiConverterRustBuffer {
    typealias SwiftType = LnurlCallbackStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlCallbackStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ok
        
        case 2: return .errorStatus(errorDetails: try FfiConverterTypeLnurlErrorDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnurlCallbackStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ok:
            writeInt(&buf, Int32(1))
        
        
        case let .errorStatus(errorDetails):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnurlErrorDetails.write(errorDetails, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlCallbackStatus_lift(_ buf: RustBuffer) throws -> LnurlCallbackStatus {
    return try FfiConverterTypeLnurlCallbackStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlCallbackStatus_lower(_ value: LnurlCallbackStatus) -> RustBuffer {
    return FfiConverterTypeLnurlCallbackStatus.lower(value)
}



extension LnurlCallbackStatus: Equatable, Hashable {}




public enum ServiceConnectivityError {

    
    
    case Builder(String
    )
    case Redirect(String
    )
    case Status(status: UInt16, body: String
    )
    case Timeout(String
    )
    case Request(String
    )
    case Connect(String
    )
    case Body(String
    )
    case Decode(String
    )
    case Json(String
    )
    case Other(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServiceConnectivityError: FfiConverterRustBuffer {
    typealias SwiftType = ServiceConnectivityError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServiceConnectivityError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Builder(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Redirect(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Status(
            status: try FfiConverterUInt16.read(from: &buf), 
            body: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Timeout(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Request(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .Connect(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .Body(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .Decode(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .Json(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .Other(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ServiceConnectivityError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Builder(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Redirect(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Status(status,body):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(status, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .Timeout(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Request(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Connect(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Body(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Decode(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Json(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Other(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ServiceConnectivityError: Equatable, Hashable {}

extension ServiceConnectivityError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparkAddressPaymentType {
    
    case tokensPayment(TokensPaymentDetails
    )
    case satsPayment(SatsPaymentDetails
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkAddressPaymentType: FfiConverterRustBuffer {
    typealias SwiftType = SparkAddressPaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkAddressPaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .tokensPayment(try FfiConverterTypeTokensPaymentDetails.read(from: &buf)
        )
        
        case 2: return .satsPayment(try FfiConverterTypeSatsPaymentDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparkAddressPaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .tokensPayment(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTokensPaymentDetails.write(v1, into: &buf)
            
        
        case let .satsPayment(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSatsPaymentDetails.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddressPaymentType_lift(_ buf: RustBuffer) throws -> SparkAddressPaymentType {
    return try FfiConverterTypeSparkAddressPaymentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddressPaymentType_lower(_ value: SparkAddressPaymentType) -> RustBuffer {
    return FfiConverterTypeSparkAddressPaymentType.lower(value)
}



extension SparkAddressPaymentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported success action types
 *
 * Receiving any other (unsupported) success action type will result in a failed parsing,
 * which will abort the LNURL-pay workflow, as per LUD-09.
 */

public enum SuccessAction {
    
    /**
     * AES type, described in LUD-10
     */
    case aes(data: AesSuccessActionData
    )
    /**
     * Message type, described in LUD-09
     */
    case message(data: MessageSuccessActionData
    )
    /**
     * URL type, described in LUD-09
     */
    case url(data: UrlSuccessActionData
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSuccessAction: FfiConverterRustBuffer {
    typealias SwiftType = SuccessAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .aes(data: try FfiConverterTypeAesSuccessActionData.read(from: &buf)
        )
        
        case 2: return .message(data: try FfiConverterTypeMessageSuccessActionData.read(from: &buf)
        )
        
        case 3: return .url(data: try FfiConverterTypeUrlSuccessActionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .aes(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionData.write(data, into: &buf)
            
        
        case let .message(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(data, into: &buf)
            
        
        case let .url(data):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(data, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessAction_lift(_ buf: RustBuffer) throws -> SuccessAction {
    return try FfiConverterTypeSuccessAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessAction_lower(_ value: SuccessAction) -> RustBuffer {
    return FfiConverterTypeSuccessAction.lower(value)
}



extension SuccessAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * [`SuccessAction`] where contents are ready to be consumed by the caller
 *
 * Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
 */

public enum SuccessActionProcessed {
    
    /**
     * See [`SuccessAction::Aes`] for received payload
     *
     * See [`AesSuccessActionDataDecrypted`] for decrypted payload
     */
    case aes(result: AesSuccessActionDataResult
    )
    /**
     * See [`SuccessAction::Message`]
     */
    case message(data: MessageSuccessActionData
    )
    /**
     * See [`SuccessAction::Url`]
     */
    case url(data: UrlSuccessActionData
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessActionProcessed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .aes(result: try FfiConverterTypeAesSuccessActionDataResult.read(from: &buf)
        )
        
        case 2: return .message(data: try FfiConverterTypeMessageSuccessActionData.read(from: &buf)
        )
        
        case 3: return .url(data: try FfiConverterTypeUrlSuccessActionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessActionProcessed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .aes(result):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataResult.write(result, into: &buf)
            
        
        case let .message(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(data, into: &buf)
            
        
        case let .url(data):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(data, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessActionProcessed_lift(_ buf: RustBuffer) throws -> SuccessActionProcessed {
    return try FfiConverterTypeSuccessActionProcessed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessActionProcessed_lower(_ value: SuccessActionProcessed) -> RustBuffer {
    return FfiConverterTypeSuccessActionProcessed.lower(value)
}



extension SuccessActionProcessed: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkInvoiceFields: FfiConverterRustBuffer {
    typealias SwiftType = SparkInvoiceFields?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkInvoiceFields.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkInvoiceFields.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSymbol: FfiConverterRustBuffer {
    typealias SwiftType = Symbol?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSymbol.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSymbol.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkAddressPaymentType: FfiConverterRustBuffer {
    typealias SwiftType = SparkAddressPaymentType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkAddressPaymentType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkAddressPaymentType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBip21Extra: FfiConverterRustBuffer {
    typealias SwiftType = [Bip21Extra]

    public static func write(_ value: [Bip21Extra], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBip21Extra.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip21Extra] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip21Extra]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBip21Extra.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt11RouteHint: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt11RouteHint]

    public static func write(_ value: [Bolt11RouteHint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt11RouteHint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt11RouteHint] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt11RouteHint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt11RouteHint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt11RouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt11RouteHintHop]

    public static func write(_ value: [Bolt11RouteHintHop], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt11RouteHintHop.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt11RouteHintHop] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt11RouteHintHop]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt11RouteHintHop.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt12OfferBlindedPath: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt12OfferBlindedPath]

    public static func write(_ value: [Bolt12OfferBlindedPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt12OfferBlindedPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt12OfferBlindedPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt12OfferBlindedPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt12OfferBlindedPath.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]

    public static func write(_ value: [LocaleOverrides], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocaleOverrides.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocaleOverrides] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocaleOverrides]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocaleOverrides.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]

    public static func write(_ value: [LocalizedName], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalizedName.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalizedName] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalizedName]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalizedName.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = [InputType]

    public static func write(_ value: [InputType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInputType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [InputType] {
        let len: Int32 = try readInt(&buf)
        var seq = [InputType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInputType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountBreezSdkCommon() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_breez_sdk_common_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_breez_sdk_common_checksum_method_restclient_get() != 32450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_common_checksum_method_restclient_post() != 14213) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitRestClient()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all