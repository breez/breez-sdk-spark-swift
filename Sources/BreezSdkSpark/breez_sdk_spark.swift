// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation
import BigNumber

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(breez_sdk_sparkFFI)
import breez_sdk_sparkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_breez_sdk_spark_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_breez_sdk_spark_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol BitcoinChainService : AnyObject {
    
    func getAddressUtxos(address: String) async throws  -> [Utxo]
    
    func getTransactionStatus(txid: String) async throws  -> TxStatus
    
    func getTransactionHex(txid: String) async throws  -> String
    
    func broadcastTransaction(tx: String) async throws 
    
    func recommendedFees() async throws  -> RecommendedFees
    
}

open class BitcoinChainServiceImpl:
    BitcoinChainService {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(pointer, $0) }
    }

    

    
open func getAddressUtxos(address: String)async throws  -> [Utxo] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(address)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUtxo.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func getTransactionStatus(txid: String)async throws  -> TxStatus {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTxStatus.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func getTransactionHex(txid: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func broadcastTransaction(tx: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(tx)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func recommendedFees()async throws  -> RecommendedFees {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRecommendedFees.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBitcoinChainService {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBitcoinChainService = UniffiVTableCallbackInterfaceBitcoinChainService(
        getAddressUtxos: { (
            uniffiHandle: UInt64,
            address: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Utxo] in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getAddressUtxos(
                     address: try FfiConverterString.lift(address)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Utxo]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeUtxo.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getTransactionStatus: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> TxStatus in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getTransactionStatus(
                     txid: try FfiConverterString.lift(txid)
                )
            }

            let uniffiHandleSuccess = { (returnValue: TxStatus) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeTxStatus.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getTransactionHex: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getTransactionHex(
                     txid: try FfiConverterString.lift(txid)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        broadcastTransaction: { (
            uniffiHandle: UInt64,
            tx: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.broadcastTransaction(
                     tx: try FfiConverterString.lift(tx)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        recommendedFees: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RecommendedFees in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.recommendedFees(
                )
            }

            let uniffiHandleSuccess = { (returnValue: RecommendedFees) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRecommendedFees.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeBitcoinChainService.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BitcoinChainService: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBitcoinChainService() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(&UniffiCallbackInterfaceBitcoinChainService.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinChainService: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<BitcoinChainService>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BitcoinChainService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinChainService {
        return BitcoinChainServiceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BitcoinChainService) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinChainService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BitcoinChainService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinChainService_lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinChainService {
    return try FfiConverterTypeBitcoinChainService.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinChainService_lower(_ value: BitcoinChainService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBitcoinChainService.lower(value)
}




/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
public protocol BreezSdkProtocol : AnyObject {
    
    /**
     * Registers a listener to receive SDK events
     *
     * # Arguments
     *
     * * `listener` - An implementation of the `EventListener` trait
     *
     * # Returns
     *
     * A unique identifier for the listener, which can be used to remove it later
     */
    func addEventListener(listener: EventListener) async  -> String
    
    func checkLightningAddressAvailable(req: CheckLightningAddressRequest) async throws  -> Bool
    
    /**
     * Verifies a message signature against the provided public key. The message
     * is SHA256 hashed before verification. The signature can be hex encoded
     * in either DER or compact format.
     */
    func checkMessage(request: CheckMessageRequest) async throws  -> CheckMessageResponse
    
    func claimDeposit(request: ClaimDepositRequest) async throws  -> ClaimDepositResponse
    
    func claimHtlcPayment(request: ClaimHtlcPaymentRequest) async throws  -> ClaimHtlcPaymentResponse
    
    func deleteLightningAddress() async throws 
    
    /**
     * Stops the SDK's background tasks
     *
     * This method stops the background tasks started by the `start()` method.
     * It should be called before your application terminates to ensure proper cleanup.
     *
     * # Returns
     *
     * Result containing either success or an `SdkError` if the background task couldn't be stopped
     */
    func disconnect() async throws 
    
    /**
     * Returns the balance of the wallet in satoshis
     */
    func getInfo(request: GetInfoRequest) async throws  -> GetInfoResponse
    
    func getLightningAddress() async throws  -> LightningAddressInfo?
    
    func getPayment(request: GetPaymentRequest) async throws  -> GetPaymentResponse
    
    /**
     * Returns an instance of the [`TokenIssuer`] for managing token issuance.
     */
    func getTokenIssuer()  -> TokenIssuer
    
    /**
     * Returns the metadata for the given token identifiers.
     *
     * Results are not guaranteed to be in the same order as the input token identifiers.
     *
     * If the metadata is not found locally in cache, it will be queried from
     * the Spark network and then cached.
     */
    func getTokensMetadata(request: GetTokensMetadataRequest) async throws  -> GetTokensMetadataResponse
    
    /**
     * Returns the user settings for the wallet.
     *
     * Some settings are fetched from the Spark network so network requests are performed.
     */
    func getUserSettings() async throws  -> UserSettings
    
    /**
     * List fiat currencies for which there is a known exchange rate,
     * sorted by the canonical name of the currency.
     */
    func listFiatCurrencies() async throws  -> ListFiatCurrenciesResponse
    
    /**
     * List the latest rates of fiat currencies, sorted by name.
     */
    func listFiatRates() async throws  -> ListFiatRatesResponse
    
    /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
    func listPayments(request: ListPaymentsRequest) async throws  -> ListPaymentsResponse
    
    func listUnclaimedDeposits(request: ListUnclaimedDepositsRequest) async throws  -> ListUnclaimedDepositsResponse
    
    func lnurlPay(request: LnurlPayRequest) async throws  -> LnurlPayResponse
    
    /**
     * Performs an LNURL withdraw operation for the amount of satoshis to
     * withdraw and the LNURL withdraw request details. The LNURL withdraw request
     * details can be obtained from calling [`BreezSdk::parse`].
     *
     * The method generates a Lightning invoice for the withdraw amount, stores
     * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
     * invoice.
     *
     * If the `completion_timeout_secs` parameter is provided and greater than 0, the
     * method will wait for the payment to be completed within that period. If the
     * withdraw is completed within the timeout, the `payment` field in the response
     * will be set with the payment details. If the `completion_timeout_secs`
     * parameter is not provided or set to 0, the method will not wait for the payment
     * to be completed. If the withdraw is not completed within the
     * timeout, the `payment` field will be empty.
     *
     * # Arguments
     *
     * * `request` - The LNURL withdraw request
     *
     * # Returns
     *
     * Result containing either:
     * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
     * * `SdkError` - If there was an error during the withdraw process
     */
    func lnurlWithdraw(request: LnurlWithdrawRequest) async throws  -> LnurlWithdrawResponse
    
    func parse(input: String) async throws  -> InputType
    
    func prepareLnurlPay(request: PrepareLnurlPayRequest) async throws  -> PrepareLnurlPayResponse
    
    func prepareSendPayment(request: PrepareSendPaymentRequest) async throws  -> PrepareSendPaymentResponse
    
    func receivePayment(request: ReceivePaymentRequest) async throws  -> ReceivePaymentResponse
    
    /**
     * Get the recommended BTC fees based on the configured chain service.
     */
    func recommendedFees() async throws  -> RecommendedFees
    
    func refundDeposit(request: RefundDepositRequest) async throws  -> RefundDepositResponse
    
    func registerLightningAddress(request: RegisterLightningAddressRequest) async throws  -> LightningAddressInfo
    
    /**
     * Removes a previously registered event listener
     *
     * # Arguments
     *
     * * `id` - The listener ID returned from `add_event_listener`
     *
     * # Returns
     *
     * `true` if the listener was found and removed, `false` otherwise
     */
    func removeEventListener(id: String) async  -> Bool
    
    func sendPayment(request: SendPaymentRequest) async throws  -> SendPaymentResponse
    
    /**
     * Signs a message with the wallet's identity key. The message is SHA256
     * hashed before signing. The returned signature will be hex encoded in
     * DER format by default, or compact format if specified.
     */
    func signMessage(request: SignMessageRequest) async throws  -> SignMessageResponse
    
    /**
     * Synchronizes the wallet with the Spark network
     */
    func syncWallet(request: SyncWalletRequest) async throws  -> SyncWalletResponse
    
    /**
     * Updates the user settings for the wallet.
     *
     * Some settings are updated on the Spark network so network requests may be performed.
     */
    func updateUserSettings(request: UpdateUserSettingsRequest) async throws 
    
}

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
open class BreezSdk:
    BreezSdkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_breezsdk(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_breezsdk(pointer, $0) }
    }

    

    
    /**
     * Registers a listener to receive SDK events
     *
     * # Arguments
     *
     * * `listener` - An implementation of the `EventListener` trait
     *
     * # Returns
     *
     * A unique identifier for the listener, which can be used to remove it later
     */
open func addEventListener(listener: EventListener)async  -> String {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceEventListener.lower(listener)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}
    
open func checkLightningAddressAvailable(req: CheckLightningAddressRequest)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCheckLightningAddressRequest.lower(req)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_i8,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_i8,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Verifies a message signature against the provided public key. The message
     * is SHA256 hashed before verification. The signature can be hex encoded
     * in either DER or compact format.
     */
open func checkMessage(request: CheckMessageRequest)async throws  -> CheckMessageResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCheckMessageRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeCheckMessageResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func claimDeposit(request: ClaimDepositRequest)async throws  -> ClaimDepositResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClaimDepositRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeClaimDepositResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func claimHtlcPayment(request: ClaimHtlcPaymentRequest)async throws  -> ClaimHtlcPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClaimHtlcPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeClaimHtlcPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func deleteLightningAddress()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Stops the SDK's background tasks
     *
     * This method stops the background tasks started by the `start()` method.
     * It should be called before your application terminates to ensure proper cleanup.
     *
     * # Returns
     *
     * Result containing either success or an `SdkError` if the background task couldn't be stopped
     */
open func disconnect()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns the balance of the wallet in satoshis
     */
open func getInfo(request: GetInfoRequest)async throws  -> GetInfoResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetInfoRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetInfoResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func getLightningAddress()async throws  -> LightningAddressInfo? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeLightningAddressInfo.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func getPayment(request: GetPaymentRequest)async throws  -> GetPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns an instance of the [`TokenIssuer`] for managing token issuance.
     */
open func getTokenIssuer() -> TokenIssuer {
    return try!  FfiConverterTypeTokenIssuer.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the metadata for the given token identifiers.
     *
     * Results are not guaranteed to be in the same order as the input token identifiers.
     *
     * If the metadata is not found locally in cache, it will be queried from
     * the Spark network and then cached.
     */
open func getTokensMetadata(request: GetTokensMetadataRequest)async throws  -> GetTokensMetadataResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetTokensMetadataRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetTokensMetadataResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns the user settings for the wallet.
     *
     * Some settings are fetched from the Spark network so network requests are performed.
     */
open func getUserSettings()async throws  -> UserSettings {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserSettings.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * List fiat currencies for which there is a known exchange rate,
     * sorted by the canonical name of the currency.
     */
open func listFiatCurrencies()async throws  -> ListFiatCurrenciesResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListFiatCurrenciesResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * List the latest rates of fiat currencies, sorted by name.
     */
open func listFiatRates()async throws  -> ListFiatRatesResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListFiatRatesResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
open func listPayments(request: ListPaymentsRequest)async throws  -> ListPaymentsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListPaymentsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListPaymentsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func listUnclaimedDeposits(request: ListUnclaimedDepositsRequest)async throws  -> ListUnclaimedDepositsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListUnclaimedDepositsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListUnclaimedDepositsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func lnurlPay(request: LnurlPayRequest)async throws  -> LnurlPayResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLnurlPayRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLnurlPayResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Performs an LNURL withdraw operation for the amount of satoshis to
     * withdraw and the LNURL withdraw request details. The LNURL withdraw request
     * details can be obtained from calling [`BreezSdk::parse`].
     *
     * The method generates a Lightning invoice for the withdraw amount, stores
     * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
     * invoice.
     *
     * If the `completion_timeout_secs` parameter is provided and greater than 0, the
     * method will wait for the payment to be completed within that period. If the
     * withdraw is completed within the timeout, the `payment` field in the response
     * will be set with the payment details. If the `completion_timeout_secs`
     * parameter is not provided or set to 0, the method will not wait for the payment
     * to be completed. If the withdraw is not completed within the
     * timeout, the `payment` field will be empty.
     *
     * # Arguments
     *
     * * `request` - The LNURL withdraw request
     *
     * # Returns
     *
     * Result containing either:
     * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
     * * `SdkError` - If there was an error during the withdraw process
     */
open func lnurlWithdraw(request: LnurlWithdrawRequest)async throws  -> LnurlWithdrawResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLnurlWithdrawRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLnurlWithdrawResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func parse(input: String)async throws  -> InputType {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(input)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeInputType.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func prepareLnurlPay(request: PrepareLnurlPayRequest)async throws  -> PrepareLnurlPayResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrepareLnurlPayRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrepareLnurlPayResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func prepareSendPayment(request: PrepareSendPaymentRequest)async throws  -> PrepareSendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrepareSendPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrepareSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func receivePayment(request: ReceivePaymentRequest)async throws  -> ReceivePaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReceivePaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReceivePaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Get the recommended BTC fees based on the configured chain service.
     */
open func recommendedFees()async throws  -> RecommendedFees {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRecommendedFees.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func refundDeposit(request: RefundDepositRequest)async throws  -> RefundDepositResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRefundDepositRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRefundDepositResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func registerLightningAddress(request: RegisterLightningAddressRequest)async throws  -> LightningAddressInfo {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRegisterLightningAddressRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLightningAddressInfo.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Removes a previously registered event listener
     *
     * # Arguments
     *
     * * `id` - The listener ID returned from `add_event_listener`
     *
     * # Returns
     *
     * `true` if the listener was found and removed, `false` otherwise
     */
open func removeEventListener(id: String)async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_i8,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_i8,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
open func sendPayment(request: SendPaymentRequest)async throws  -> SendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Signs a message with the wallet's identity key. The message is SHA256
     * hashed before signing. The returned signature will be hex encoded in
     * DER format by default, or compact format if specified.
     */
open func signMessage(request: SignMessageRequest)async throws  -> SignMessageResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSignMessageRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignMessageResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Synchronizes the wallet with the Spark network
     */
open func syncWallet(request: SyncWalletRequest)async throws  -> SyncWalletResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSyncWalletRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSyncWalletResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Updates the user settings for the wallet.
     *
     * Some settings are updated on the Spark network so network requests may be performed.
     */
open func updateUserSettings(request: UpdateUserSettingsRequest)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUpdateUserSettingsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBreezSdk: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BreezSdk

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BreezSdk {
        return BreezSdk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BreezSdk) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezSdk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BreezSdk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdk_lift(_ pointer: UnsafeMutableRawPointer) throws -> BreezSdk {
    return try FfiConverterTypeBreezSdk.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdk_lower(_ value: BreezSdk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBreezSdk.lower(value)
}




/**
 * Trait covering fiat-related functionality
 */
public protocol FiatService : AnyObject {
    
    /**
     * List all supported fiat currencies for which there is a known exchange rate.
     */
    func fetchFiatCurrencies() async throws  -> [FiatCurrency]
    
    /**
     * Get the live rates from the server.
     */
    func fetchFiatRates() async throws  -> [Rate]
    
}

/**
 * Trait covering fiat-related functionality
 */
open class FiatServiceImpl:
    FiatService {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_fiatservice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_fiatservice(pointer, $0) }
    }

    

    
    /**
     * List all supported fiat currencies for which there is a known exchange rate.
     */
open func fetchFiatCurrencies()async throws  -> [FiatCurrency] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFiatCurrency.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    
    /**
     * Get the live rates from the server.
     */
open func fetchFiatRates()async throws  -> [Rate] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeRate.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFiatService {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFiatService = UniffiVTableCallbackInterfaceFiatService(
        fetchFiatCurrencies: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [FiatCurrency] in
                guard let uniffiObj = try? FfiConverterTypeFiatService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.fetchFiatCurrencies(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [FiatCurrency]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeFiatCurrency.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        fetchFiatRates: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Rate] in
                guard let uniffiObj = try? FfiConverterTypeFiatService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.fetchFiatRates(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Rate]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeRate.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFiatService.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FiatService: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFiatService() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(&UniffiCallbackInterfaceFiatService.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatService: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<FiatService>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FiatService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatService {
        return FiatServiceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FiatService) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FiatService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatService_lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatService {
    return try FfiConverterTypeFiatService.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatService_lower(_ value: FiatService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFiatService.lower(value)
}




/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
public protocol PaymentObserver : AnyObject {
    
    /**
     * Called before Lightning, Spark or onchain Bitcoin payments are made
     */
    func beforeSend(payments: [ProvisionalPayment]) async throws 
    
}

/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
open class PaymentObserverImpl:
    PaymentObserver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_paymentobserver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_paymentobserver(pointer, $0) }
    }

    

    
    /**
     * Called before Lightning, Spark or onchain Bitcoin payments are made
     */
open func beforeSend(payments: [ProvisionalPayment])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeProvisionalPayment.lower(payments)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypePaymentObserverError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePaymentObserver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfacePaymentObserver = UniffiVTableCallbackInterfacePaymentObserver(
        beforeSend: { (
            uniffiHandle: UInt64,
            payments: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypePaymentObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.beforeSend(
                     payments: try FfiConverterSequenceTypeProvisionalPayment.lift(payments)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypePaymentObserverError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypePaymentObserver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PaymentObserver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitPaymentObserver() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(&UniffiCallbackInterfacePaymentObserver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentObserver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<PaymentObserver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaymentObserver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaymentObserver {
        return PaymentObserverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaymentObserver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentObserver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaymentObserver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentObserver_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaymentObserver {
    return try FfiConverterTypePaymentObserver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentObserver_lower(_ value: PaymentObserver) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaymentObserver.lower(value)
}




public protocol RestClient : AnyObject {
    
    /**
     * Makes a GET request and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which GET will be called
     * - `headers`: optional headers that will be set on the request
     */
    func getRequest(url: String, headers: [String: String]?) async throws  -> RestResponse
    
    /**
     * Makes a POST request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which POST will be called
     * - `headers`: the optional POST headers
     * - `body`: the optional POST body
     */
    func postRequest(url: String, headers: [String: String]?, body: String?) async throws  -> RestResponse
    
    /**
     * Makes a DELETE request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which DELETE will be called
     * - `headers`: the optional DELETE headers
     * - `body`: the optional DELETE body
     */
    func deleteRequest(url: String, headers: [String: String]?, body: String?) async throws  -> RestResponse
    
}

open class RestClientImpl:
    RestClient {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_restclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_restclient(pointer, $0) }
    }

    

    
    /**
     * Makes a GET request and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which GET will be called
     * - `headers`: optional headers that will be set on the request
     */
open func getRequest(url: String, headers: [String: String]?)async throws  -> RestResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_restclient_get_request(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDictionaryStringString.lower(headers)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRestResponse.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    
    /**
     * Makes a POST request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which POST will be called
     * - `headers`: the optional POST headers
     * - `body`: the optional POST body
     */
open func postRequest(url: String, headers: [String: String]?, body: String?)async throws  -> RestResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_restclient_post_request(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDictionaryStringString.lower(headers),FfiConverterOptionString.lower(body)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRestResponse.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    
    /**
     * Makes a DELETE request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which DELETE will be called
     * - `headers`: the optional DELETE headers
     * - `body`: the optional DELETE body
     */
open func deleteRequest(url: String, headers: [String: String]?, body: String?)async throws  -> RestResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_restclient_delete_request(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDictionaryStringString.lower(headers),FfiConverterOptionString.lower(body)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRestResponse.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRestClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRestClient = UniffiVTableCallbackInterfaceRestClient(
        getRequest: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            headers: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RestResponse in
                guard let uniffiObj = try? FfiConverterTypeRestClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getRequest(
                     url: try FfiConverterString.lift(url),
                     headers: try FfiConverterOptionDictionaryStringString.lift(headers)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RestResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRestResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        postRequest: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            headers: RustBuffer,
            body: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RestResponse in
                guard let uniffiObj = try? FfiConverterTypeRestClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.postRequest(
                     url: try FfiConverterString.lift(url),
                     headers: try FfiConverterOptionDictionaryStringString.lift(headers),
                     body: try FfiConverterOptionString.lift(body)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RestResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRestResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteRequest: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            headers: RustBuffer,
            body: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RestResponse in
                guard let uniffiObj = try? FfiConverterTypeRestClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteRequest(
                     url: try FfiConverterString.lift(url),
                     headers: try FfiConverterOptionDictionaryStringString.lift(headers),
                     body: try FfiConverterOptionString.lift(body)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RestResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRestResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeRestClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RestClient: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRestClient() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(&UniffiCallbackInterfaceRestClient.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRestClient: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<RestClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RestClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RestClient {
        return RestClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RestClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RestClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RestClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> RestClient {
    return try FfiConverterTypeRestClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestClient_lower(_ value: RestClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRestClient.lower(value)
}




/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
public protocol SdkBuilderProtocol : AnyObject {
    
    /**
     * Builds the `BreezSdk` instance with the configured components.
     */
    func build() async throws  -> BreezSdk
    
    /**
     * Sets the chain service to be used by the SDK.
     * Arguments:
     * - `chain_service`: The chain service to be used.
     */
    func withChainService(chainService: BitcoinChainService) async 
    
    /**
     * Sets the root storage directory to initialize the default storage with.
     * This initializes both storage and real-time sync storage with the
     * default implementations.
     * Arguments:
     * - `storage_dir`: The data directory for storage.
     */
    func withDefaultStorage(storageDir: String) async 
    
    /**
     * Sets the fiat service to be used by the SDK.
     * Arguments:
     * - `fiat_service`: The fiat service to be used.
     */
    func withFiatService(fiatService: FiatService) async 
    
    /**
     * Sets the key set type to be used by the SDK.
     * Arguments:
     * - `key_set_type`: The key set type which determines the derivation path.
     * - `use_address_index`: Controls the structure of the BIP derivation path.
     */
    func withKeySet(keySetType: KeySetType, useAddressIndex: Bool, accountNumber: UInt32?) async 
    
    func withLnurlClient(lnurlClient: RestClient) async 
    
    /**
     * Sets the payment observer to be used by the SDK.
     * Arguments:
     * - `payment_observer`: The payment observer to be used.
     */
    func withPaymentObserver(paymentObserver: PaymentObserver) async 
    
    /**
     * Sets the real-time sync storage implementation to be used by the SDK.
     * Arguments:
     * - `storage`: The sync storage implementation to be used.
     */
    func withRealTimeSyncStorage(storage: SyncStorage) async 
    
    /**
     * Sets the REST chain service to be used by the SDK.
     * Arguments:
     * - `url`: The base URL of the REST API.
     * - `api_type`: The API type to be used.
     * - `credentials`: Optional credentials for basic authentication.
     */
    func withRestChainService(url: String, apiType: ChainApiType, credentials: Credentials?) async 
    
    /**
     * Sets the storage implementation to be used by the SDK.
     * Arguments:
     * - `storage`: The storage implementation to be used.
     */
    func withStorage(storage: Storage) async 
    
}

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
open class SdkBuilder:
    SdkBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_sdkbuilder(self.pointer, $0) }
    }
    /**
     * Creates a new `SdkBuilder` with the provided configuration.
     * Arguments:
     * - `config`: The configuration to be used.
     * - `seed`: The seed for wallet generation.
     */
public convenience init(config: Config, seed: Seed) {
    let pointer =
        try! rustCall() {
    uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
        FfiConverterTypeConfig.lower(config),
        FfiConverterTypeSeed.lower(seed),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_sdkbuilder(pointer, $0) }
    }

    

    
    /**
     * Builds the `BreezSdk` instance with the configured components.
     */
open func build()async throws  -> BreezSdk {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBreezSdk.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Sets the chain service to be used by the SDK.
     * Arguments:
     * - `chain_service`: The chain service to be used.
     */
open func withChainService(chainService: BitcoinChainService)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBitcoinChainService.lower(chainService)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the root storage directory to initialize the default storage with.
     * This initializes both storage and real-time sync storage with the
     * default implementations.
     * Arguments:
     * - `storage_dir`: The data directory for storage.
     */
open func withDefaultStorage(storageDir: String)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(storageDir)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the fiat service to be used by the SDK.
     * Arguments:
     * - `fiat_service`: The fiat service to be used.
     */
open func withFiatService(fiatService: FiatService)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFiatService.lower(fiatService)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the key set type to be used by the SDK.
     * Arguments:
     * - `key_set_type`: The key set type which determines the derivation path.
     * - `use_address_index`: Controls the structure of the BIP derivation path.
     */
open func withKeySet(keySetType: KeySetType, useAddressIndex: Bool, accountNumber: UInt32?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKeySetType.lower(keySetType),FfiConverterBool.lower(useAddressIndex),FfiConverterOptionUInt32.lower(accountNumber)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func withLnurlClient(lnurlClient: RestClient)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRestClient.lower(lnurlClient)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the payment observer to be used by the SDK.
     * Arguments:
     * - `payment_observer`: The payment observer to be used.
     */
open func withPaymentObserver(paymentObserver: PaymentObserver)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
                    self.uniffiClonePointer(),
                    FfiConverterTypePaymentObserver.lower(paymentObserver)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the real-time sync storage implementation to be used by the SDK.
     * Arguments:
     * - `storage`: The sync storage implementation to be used.
     */
open func withRealTimeSyncStorage(storage: SyncStorage)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSyncStorage.lower(storage)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the REST chain service to be used by the SDK.
     * Arguments:
     * - `url`: The base URL of the REST API.
     * - `api_type`: The API type to be used.
     * - `credentials`: Optional credentials for basic authentication.
     */
open func withRestChainService(url: String, apiType: ChainApiType, credentials: Credentials?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterTypeChainApiType.lower(apiType),FfiConverterOptionTypeCredentials.lower(credentials)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the storage implementation to be used by the SDK.
     * Arguments:
     * - `storage`: The storage implementation to be used.
     */
open func withStorage(storage: Storage)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(
                    self.uniffiClonePointer(),
                    FfiConverterTypeStorage.lower(storage)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SdkBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SdkBuilder {
        return SdkBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SdkBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SdkBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SdkBuilder {
    return try FfiConverterTypeSdkBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkBuilder_lower(_ value: SdkBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSdkBuilder.lower(value)
}




/**
 * Trait for persistent storage
 */
public protocol Storage : AnyObject {
    
    func deleteCachedItem(key: String) async throws 
    
    func getCachedItem(key: String) async throws  -> String?
    
    func setCachedItem(key: String, value: String) async throws 
    
    /**
     * Lists payments with optional filters and pagination
     *
     * # Arguments
     *
     * * `list_payments_request` - The request to list payments
     *
     * # Returns
     *
     * A vector of payments or a `StorageError`
     */
    func listPayments(request: ListPaymentsRequest) async throws  -> [Payment]
    
    /**
     * Inserts a payment into storage
     *
     * # Arguments
     *
     * * `payment` - The payment to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func insertPayment(payment: Payment) async throws 
    
    /**
     * Inserts payment metadata into storage
     *
     * # Arguments
     *
     * * `payment_id` - The ID of the payment
     * * `metadata` - The metadata to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func setPaymentMetadata(paymentId: String, metadata: PaymentMetadata) async throws 
    
    /**
     * Gets a payment by its ID
     * # Arguments
     *
     * * `id` - The ID of the payment to retrieve
     *
     * # Returns
     *
     * The payment if found or None if not found
     */
    func getPaymentById(id: String) async throws  -> Payment
    
    /**
     * Gets a payment by its invoice
     * # Arguments
     *
     * * `invoice` - The invoice of the payment to retrieve
     * # Returns
     *
     * The payment if found or None if not found
     */
    func getPaymentByInvoice(invoice: String) async throws  -> Payment?
    
    /**
     * Add a deposit to storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `amount_sats` - The amount of the deposit in sats
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func addDeposit(txid: String, vout: UInt32, amountSats: UInt64) async throws 
    
    /**
     * Removes an unclaimed deposit from storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func deleteDeposit(txid: String, vout: UInt32) async throws 
    
    /**
     * Lists all unclaimed deposits from storage
     * # Returns
     *
     * A vector of `DepositInfo` or a `StorageError`
     */
    func listDeposits() async throws  -> [DepositInfo]
    
    /**
     * Updates or inserts unclaimed deposit details
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `payload` - The payload for the update
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func updateDeposit(txid: String, vout: UInt32, payload: UpdateDepositPayload) async throws 
    
    func setLnurlMetadata(metadata: [SetLnurlMetadataItem]) async throws 
    
}

/**
 * Trait for persistent storage
 */
open class StorageImpl:
    Storage {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_storage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_storage(pointer, $0) }
    }

    

    
open func deleteCachedItem(key: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func getCachedItem(key: String)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func setCachedItem(key: String, value: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key),FfiConverterString.lower(value)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Lists payments with optional filters and pagination
     *
     * # Arguments
     *
     * * `list_payments_request` - The request to list payments
     *
     * # Returns
     *
     * A vector of payments or a `StorageError`
     */
open func listPayments(request: ListPaymentsRequest)async throws  -> [Payment] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_list_payments(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListPaymentsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Inserts a payment into storage
     *
     * # Arguments
     *
     * * `payment` - The payment to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func insertPayment(payment: Payment)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayment.lower(payment)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Inserts payment metadata into storage
     *
     * # Arguments
     *
     * * `payment_id` - The ID of the payment
     * * `metadata` - The metadata to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func setPaymentMetadata(paymentId: String, metadata: PaymentMetadata)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(paymentId),FfiConverterTypePaymentMetadata.lower(metadata)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Gets a payment by its ID
     * # Arguments
     *
     * * `id` - The ID of the payment to retrieve
     *
     * # Returns
     *
     * The payment if found or None if not found
     */
open func getPaymentById(id: String)async throws  -> Payment {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Gets a payment by its invoice
     * # Arguments
     *
     * * `invoice` - The invoice of the payment to retrieve
     * # Returns
     *
     * The payment if found or None if not found
     */
open func getPaymentByInvoice(invoice: String)async throws  -> Payment? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(invoice)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Add a deposit to storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `amount_sats` - The amount of the deposit in sats
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func addDeposit(txid: String, vout: UInt32, amountSats: UInt64)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterUInt64.lower(amountSats)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Removes an unclaimed deposit from storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func deleteDeposit(txid: String, vout: UInt32)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Lists all unclaimed deposits from storage
     * # Returns
     *
     * A vector of `DepositInfo` or a `StorageError`
     */
open func listDeposits()async throws  -> [DepositInfo] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeDepositInfo.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Updates or inserts unclaimed deposit details
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `payload` - The payload for the update
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func updateDeposit(txid: String, vout: UInt32, payload: UpdateDepositPayload)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterTypeUpdateDepositPayload.lower(payload)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func setLnurlMetadata(metadata: [SetLnurlMetadataItem])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSetLnurlMetadataItem.lower(metadata)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceStorage {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceStorage = UniffiVTableCallbackInterfaceStorage(
        deleteCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteCachedItem(
                     key: try FfiConverterString.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String? in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getCachedItem(
                     key: try FfiConverterString.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setCachedItem(
                     key: try FfiConverterString.lift(key),
                     value: try FfiConverterString.lift(value)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listPayments: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Payment] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listPayments(
                     request: try FfiConverterTypeListPaymentsRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Payment]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        insertPayment: { (
            uniffiHandle: UInt64,
            payment: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.insertPayment(
                     payment: try FfiConverterTypePayment.lift(payment)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setPaymentMetadata: { (
            uniffiHandle: UInt64,
            paymentId: RustBuffer,
            metadata: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setPaymentMetadata(
                     paymentId: try FfiConverterString.lift(paymentId),
                     metadata: try FfiConverterTypePaymentMetadata.lift(metadata)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPaymentById: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Payment in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPaymentById(
                     id: try FfiConverterString.lift(id)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Payment) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPaymentByInvoice: { (
            uniffiHandle: UInt64,
            invoice: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Payment? in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPaymentByInvoice(
                     invoice: try FfiConverterString.lift(invoice)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Payment?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        addDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            amountSats: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.addDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout),
                     amountSats: try FfiConverterUInt64.lift(amountSats)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listDeposits: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [DepositInfo] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listDeposits(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [DepositInfo]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeDepositInfo.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        updateDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            payload: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.updateDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout),
                     payload: try FfiConverterTypeUpdateDepositPayload.lift(payload)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setLnurlMetadata: { (
            uniffiHandle: UInt64,
            metadata: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setLnurlMetadata(
                     metadata: try FfiConverterSequenceTypeSetLnurlMetadataItem.lift(metadata)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Storage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitStorage() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(&UniffiCallbackInterfaceStorage.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<Storage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Storage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Storage {
        return StorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Storage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Storage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Storage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> Storage {
    return try FfiConverterTypeStorage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorage_lower(_ value: Storage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStorage.lower(value)
}




public protocol SyncStorage : AnyObject {
    
    func addOutgoingChange(record: UnversionedRecordChange) async throws  -> UInt64
    
    func completeOutgoingSync(record: Record) async throws 
    
    func getPendingOutgoingChanges(limit: UInt32) async throws  -> [OutgoingChange]
    
    /**
     * Get the revision number of the last synchronized record
     */
    func getLastRevision() async throws  -> UInt64
    
    /**
     * Insert incoming records from remote sync
     */
    func insertIncomingRecords(records: [Record]) async throws 
    
    /**
     * Delete an incoming record after it has been processed
     */
    func deleteIncomingRecord(record: Record) async throws 
    
    /**
     * Update revision numbers of pending outgoing records to be higher than the given revision
     */
    func rebasePendingOutgoingRecords(revision: UInt64) async throws 
    
    /**
     * Get incoming records that need to be processed, up to the specified limit
     */
    func getIncomingRecords(limit: UInt32) async throws  -> [IncomingChange]
    
    /**
     * Get the latest outgoing record if any exists
     */
    func getLatestOutgoingChange() async throws  -> OutgoingChange?
    
    /**
     * Update the sync state record from an incoming record
     */
    func updateRecordFromIncoming(record: Record) async throws 
    
}

open class SyncStorageImpl:
    SyncStorage {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_syncstorage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_syncstorage(pointer, $0) }
    }

    

    
open func addOutgoingChange(record: UnversionedRecordChange)async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_add_outgoing_change(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnversionedRecordChange.lower(record)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_u64,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_u64,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
open func completeOutgoingSync(record: Record)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_complete_outgoing_sync(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRecord.lower(record)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
open func getPendingOutgoingChanges(limit: UInt32)async throws  -> [OutgoingChange] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_get_pending_outgoing_changes(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(limit)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOutgoingChange.lift,
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
    /**
     * Get the revision number of the last synchronized record
     */
open func getLastRevision()async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_get_last_revision(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_u64,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_u64,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
    /**
     * Insert incoming records from remote sync
     */
open func insertIncomingRecords(records: [Record])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_insert_incoming_records(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRecord.lower(records)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
    /**
     * Delete an incoming record after it has been processed
     */
open func deleteIncomingRecord(record: Record)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_delete_incoming_record(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRecord.lower(record)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
    /**
     * Update revision numbers of pending outgoing records to be higher than the given revision
     */
open func rebasePendingOutgoingRecords(revision: UInt64)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_rebase_pending_outgoing_records(
                    self.uniffiClonePointer(),
                    FfiConverterUInt64.lower(revision)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
    /**
     * Get incoming records that need to be processed, up to the specified limit
     */
open func getIncomingRecords(limit: UInt32)async throws  -> [IncomingChange] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_get_incoming_records(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(limit)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeIncomingChange.lift,
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
    /**
     * Get the latest outgoing record if any exists
     */
open func getLatestOutgoingChange()async throws  -> OutgoingChange? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_get_latest_outgoing_change(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeOutgoingChange.lift,
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    
    /**
     * Update the sync state record from an incoming record
     */
open func updateRecordFromIncoming(record: Record)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_syncstorage_update_record_from_incoming(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRecord.lower(record)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSyncStorageError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncStorage {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSyncStorage = UniffiVTableCallbackInterfaceSyncStorage(
        addOutgoingChange: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteU64,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.addOutgoingChange(
                     record: try FfiConverterTypeUnversionedRecordChange.lift(record)
                )
            }

            let uniffiHandleSuccess = { (returnValue: UInt64) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: FfiConverterUInt64.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        completeOutgoingSync: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.completeOutgoingSync(
                     record: try FfiConverterTypeRecord.lift(record)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPendingOutgoingChanges: { (
            uniffiHandle: UInt64,
            limit: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [OutgoingChange] in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPendingOutgoingChanges(
                     limit: try FfiConverterUInt32.lift(limit)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [OutgoingChange]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeOutgoingChange.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getLastRevision: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteU64,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getLastRevision(
                )
            }

            let uniffiHandleSuccess = { (returnValue: UInt64) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: FfiConverterUInt64.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        insertIncomingRecords: { (
            uniffiHandle: UInt64,
            records: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.insertIncomingRecords(
                     records: try FfiConverterSequenceTypeRecord.lift(records)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteIncomingRecord: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteIncomingRecord(
                     record: try FfiConverterTypeRecord.lift(record)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        rebasePendingOutgoingRecords: { (
            uniffiHandle: UInt64,
            revision: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.rebasePendingOutgoingRecords(
                     revision: try FfiConverterUInt64.lift(revision)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getIncomingRecords: { (
            uniffiHandle: UInt64,
            limit: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [IncomingChange] in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getIncomingRecords(
                     limit: try FfiConverterUInt32.lift(limit)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [IncomingChange]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeIncomingChange.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getLatestOutgoingChange: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> OutgoingChange? in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getLatestOutgoingChange(
                )
            }

            let uniffiHandleSuccess = { (returnValue: OutgoingChange?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeOutgoingChange.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        updateRecordFromIncoming: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSyncStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.updateRecordFromIncoming(
                     record: try FfiConverterTypeRecord.lift(record)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSyncStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeSyncStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncStorage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSyncStorage() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_syncstorage(&UniffiCallbackInterfaceSyncStorage.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<SyncStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncStorage {
        return SyncStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncStorage {
    return try FfiConverterTypeSyncStorage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncStorage_lower(_ value: SyncStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncStorage.lower(value)
}




public protocol TokenIssuerProtocol : AnyObject {
    
    /**
     * Burns supply of the issuer token
     *
     * # Arguments
     *
     * * `request`: The request containing the amount of the supply to burn
     *
     * # Returns
     *
     * Result containing either:
     * * `Payment` - The payment representing the burn transaction
     * * `SdkError` - If there was an error during the burn process
     */
    func burnIssuerToken(request: BurnIssuerTokenRequest) async throws  -> Payment
    
    /**
     * Creates a new issuer token
     *
     * # Arguments
     *
     * * `request`: The request containing the token parameters
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenMetadata` - The metadata of the created token
     * * `SdkError` - If there was an error during the token creation
     */
    func createIssuerToken(request: CreateIssuerTokenRequest) async throws  -> TokenMetadata
    
    /**
     * Freezes tokens held at the specified address
     *
     * # Arguments
     *
     * * `request`: The request containing the spark address where the tokens to be frozen are held
     *
     * # Returns
     *
     * Result containing either:
     * * `FreezeIssuerTokenResponse` - The response containing details of the freeze operation
     * * `SdkError` - If there was an error during the freeze process
     */
    func freezeIssuerToken(request: FreezeIssuerTokenRequest) async throws  -> FreezeIssuerTokenResponse
    
    /**
     * Gets the issuer token balance
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenBalance` - The balance of the issuer token
     * * `SdkError` - If there was an error during the retrieval or no issuer token exists
     */
    func getIssuerTokenBalance() async throws  -> TokenBalance
    
    /**
     * Gets the issuer token metadata
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenMetadata` - The metadata of the issuer token
     * * `SdkError` - If there was an error during the retrieval or no issuer token exists
     */
    func getIssuerTokenMetadata() async throws  -> TokenMetadata
    
    /**
     * Mints supply for the issuer token
     *
     * # Arguments
     *
     * * `request`: The request contiaining the amount of the supply to mint
     *
     * # Returns
     *
     * Result containing either:
     * * `Payment` - The payment representing the minting transaction
     * * `SdkError` - If there was an error during the minting process
     */
    func mintIssuerToken(request: MintIssuerTokenRequest) async throws  -> Payment
    
    /**
     * Unfreezes tokens held at the specified address
     *
     * # Arguments
     *
     * * `request`: The request containing the spark address where the tokens to be unfrozen are held
     *
     * # Returns
     *
     * Result containing either:
     * * `UnfreezeIssuerTokenResponse` - The response containing details of the unfreeze operation
     * * `SdkError` - If there was an error during the unfreeze process
     */
    func unfreezeIssuerToken(request: UnfreezeIssuerTokenRequest) async throws  -> UnfreezeIssuerTokenResponse
    
}

open class TokenIssuer:
    TokenIssuerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_tokenissuer(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_tokenissuer(pointer, $0) }
    }

    

    
    /**
     * Burns supply of the issuer token
     *
     * # Arguments
     *
     * * `request`: The request containing the amount of the supply to burn
     *
     * # Returns
     *
     * Result containing either:
     * * `Payment` - The payment representing the burn transaction
     * * `SdkError` - If there was an error during the burn process
     */
open func burnIssuerToken(request: BurnIssuerTokenRequest)async throws  -> Payment {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBurnIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayment.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Creates a new issuer token
     *
     * # Arguments
     *
     * * `request`: The request containing the token parameters
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenMetadata` - The metadata of the created token
     * * `SdkError` - If there was an error during the token creation
     */
open func createIssuerToken(request: CreateIssuerTokenRequest)async throws  -> TokenMetadata {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTokenMetadata.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Freezes tokens held at the specified address
     *
     * # Arguments
     *
     * * `request`: The request containing the spark address where the tokens to be frozen are held
     *
     * # Returns
     *
     * Result containing either:
     * * `FreezeIssuerTokenResponse` - The response containing details of the freeze operation
     * * `SdkError` - If there was an error during the freeze process
     */
open func freezeIssuerToken(request: FreezeIssuerTokenRequest)async throws  -> FreezeIssuerTokenResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFreezeIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFreezeIssuerTokenResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Gets the issuer token balance
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenBalance` - The balance of the issuer token
     * * `SdkError` - If there was an error during the retrieval or no issuer token exists
     */
open func getIssuerTokenBalance()async throws  -> TokenBalance {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTokenBalance.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Gets the issuer token metadata
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenMetadata` - The metadata of the issuer token
     * * `SdkError` - If there was an error during the retrieval or no issuer token exists
     */
open func getIssuerTokenMetadata()async throws  -> TokenMetadata {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTokenMetadata.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Mints supply for the issuer token
     *
     * # Arguments
     *
     * * `request`: The request contiaining the amount of the supply to mint
     *
     * # Returns
     *
     * Result containing either:
     * * `Payment` - The payment representing the minting transaction
     * * `SdkError` - If there was an error during the minting process
     */
open func mintIssuerToken(request: MintIssuerTokenRequest)async throws  -> Payment {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMintIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayment.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Unfreezes tokens held at the specified address
     *
     * # Arguments
     *
     * * `request`: The request containing the spark address where the tokens to be unfrozen are held
     *
     * # Returns
     *
     * Result containing either:
     * * `UnfreezeIssuerTokenResponse` - The response containing details of the unfreeze operation
     * * `SdkError` - If there was an error during the unfreeze process
     */
open func unfreezeIssuerToken(request: UnfreezeIssuerTokenRequest)async throws  -> UnfreezeIssuerTokenResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnfreezeIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUnfreezeIssuerTokenResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenIssuer: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TokenIssuer

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenIssuer {
        return TokenIssuer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TokenIssuer) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenIssuer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TokenIssuer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenIssuer_lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenIssuer {
    return try FfiConverterTypeTokenIssuer.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenIssuer_lower(_ value: TokenIssuer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTokenIssuer.lower(value)
}


/**
 * Payload of the AES success action, as received from the LNURL endpoint
 *
 * See [`AesSuccessActionDataDecrypted`] for a similar wrapper containing the decrypted payload
 */
public struct AesSuccessActionData {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
     */
    public var ciphertext: String
    /**
     * Base64, initialization vector, exactly 24 characters
     */
    public var iv: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
         */ciphertext: String, 
        /**
         * Base64, initialization vector, exactly 24 characters
         */iv: String) {
        self.description = description
        self.ciphertext = ciphertext
        self.iv = iv
    }
}



extension AesSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: AesSuccessActionData, rhs: AesSuccessActionData) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.ciphertext != rhs.ciphertext {
            return false
        }
        if lhs.iv != rhs.iv {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(ciphertext)
        hasher.combine(iv)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionData {
        return
            try AesSuccessActionData(
                description: FfiConverterString.read(from: &buf), 
                ciphertext: FfiConverterString.read(from: &buf), 
                iv: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.ciphertext, into: &buf)
        FfiConverterString.write(value.iv, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionData_lift(_ buf: RustBuffer) throws -> AesSuccessActionData {
    return try FfiConverterTypeAesSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionData_lower(_ value: AesSuccessActionData) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionData.lower(value)
}


/**
 * Wrapper for the decrypted [`AesSuccessActionData`] payload
 */
public struct AesSuccessActionDataDecrypted {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * Decrypted content
     */
    public var plaintext: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * Decrypted content
         */plaintext: String) {
        self.description = description
        self.plaintext = plaintext
    }
}



extension AesSuccessActionDataDecrypted: Equatable, Hashable {
    public static func ==(lhs: AesSuccessActionDataDecrypted, rhs: AesSuccessActionDataDecrypted) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.plaintext != rhs.plaintext {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(plaintext)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionDataDecrypted: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataDecrypted {
        return
            try AesSuccessActionDataDecrypted(
                description: FfiConverterString.read(from: &buf), 
                plaintext: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionDataDecrypted, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.plaintext, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataDecrypted_lift(_ buf: RustBuffer) throws -> AesSuccessActionDataDecrypted {
    return try FfiConverterTypeAesSuccessActionDataDecrypted.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataDecrypted_lower(_ value: AesSuccessActionDataDecrypted) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionDataDecrypted.lower(value)
}


public struct Bip21Details {
    public var amountSat: UInt64?
    public var assetId: String?
    public var uri: String
    public var extras: [Bip21Extra]
    public var label: String?
    public var message: String?
    public var paymentMethods: [InputType]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSat: UInt64?, assetId: String?, uri: String, extras: [Bip21Extra], label: String?, message: String?, paymentMethods: [InputType]) {
        self.amountSat = amountSat
        self.assetId = assetId
        self.uri = uri
        self.extras = extras
        self.label = label
        self.message = message
        self.paymentMethods = paymentMethods
    }
}



extension Bip21Details: Equatable, Hashable {
    public static func ==(lhs: Bip21Details, rhs: Bip21Details) -> Bool {
        if lhs.amountSat != rhs.amountSat {
            return false
        }
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.uri != rhs.uri {
            return false
        }
        if lhs.extras != rhs.extras {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.paymentMethods != rhs.paymentMethods {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSat)
        hasher.combine(assetId)
        hasher.combine(uri)
        hasher.combine(extras)
        hasher.combine(label)
        hasher.combine(message)
        hasher.combine(paymentMethods)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip21Details: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip21Details {
        return
            try Bip21Details(
                amountSat: FfiConverterOptionUInt64.read(from: &buf), 
                assetId: FfiConverterOptionString.read(from: &buf), 
                uri: FfiConverterString.read(from: &buf), 
                extras: FfiConverterSequenceTypeBip21Extra.read(from: &buf), 
                label: FfiConverterOptionString.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf), 
                paymentMethods: FfiConverterSequenceTypeInputType.read(from: &buf)
        )
    }

    public static func write(_ value: Bip21Details, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.amountSat, into: &buf)
        FfiConverterOptionString.write(value.assetId, into: &buf)
        FfiConverterString.write(value.uri, into: &buf)
        FfiConverterSequenceTypeBip21Extra.write(value.extras, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterSequenceTypeInputType.write(value.paymentMethods, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Details_lift(_ buf: RustBuffer) throws -> Bip21Details {
    return try FfiConverterTypeBip21Details.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Details_lower(_ value: Bip21Details) -> RustBuffer {
    return FfiConverterTypeBip21Details.lower(value)
}


public struct Bip21Extra {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}



extension Bip21Extra: Equatable, Hashable {
    public static func ==(lhs: Bip21Extra, rhs: Bip21Extra) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip21Extra: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip21Extra {
        return
            try Bip21Extra(
                key: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Bip21Extra, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Extra_lift(_ buf: RustBuffer) throws -> Bip21Extra {
    return try FfiConverterTypeBip21Extra.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Extra_lower(_ value: Bip21Extra) -> RustBuffer {
    return FfiConverterTypeBip21Extra.lower(value)
}


public struct BitcoinAddressDetails {
    public var address: String
    public var network: BitcoinNetwork
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, network: BitcoinNetwork, source: PaymentRequestSource) {
        self.address = address
        self.network = network
        self.source = source
    }
}



extension BitcoinAddressDetails: Equatable, Hashable {
    public static func ==(lhs: BitcoinAddressDetails, rhs: BitcoinAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(network)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinAddressDetails {
        return
            try BitcoinAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: BitcoinAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinAddressDetails_lift(_ buf: RustBuffer) throws -> BitcoinAddressDetails {
    return try FfiConverterTypeBitcoinAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinAddressDetails_lower(_ value: BitcoinAddressDetails) -> RustBuffer {
    return FfiConverterTypeBitcoinAddressDetails.lower(value)
}


public struct Bolt11Invoice {
    public var bolt11: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bolt11: String, source: PaymentRequestSource) {
        self.bolt11 = bolt11
        self.source = source
    }
}



extension Bolt11Invoice: Equatable, Hashable {
    public static func ==(lhs: Bolt11Invoice, rhs: Bolt11Invoice) -> Bool {
        if lhs.bolt11 != rhs.bolt11 {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bolt11)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11Invoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Invoice {
        return
            try Bolt11Invoice(
                bolt11: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11Invoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bolt11, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Invoice_lift(_ buf: RustBuffer) throws -> Bolt11Invoice {
    return try FfiConverterTypeBolt11Invoice.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Invoice_lower(_ value: Bolt11Invoice) -> RustBuffer {
    return FfiConverterTypeBolt11Invoice.lower(value)
}


public struct Bolt11InvoiceDetails {
    public var amountMsat: UInt64?
    public var description: String?
    public var descriptionHash: String?
    public var expiry: UInt64
    public var invoice: Bolt11Invoice
    public var minFinalCltvExpiryDelta: UInt64
    public var network: BitcoinNetwork
    public var payeePubkey: String
    public var paymentHash: String
    public var paymentSecret: String
    public var routingHints: [Bolt11RouteHint]
    public var timestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountMsat: UInt64?, description: String?, descriptionHash: String?, expiry: UInt64, invoice: Bolt11Invoice, minFinalCltvExpiryDelta: UInt64, network: BitcoinNetwork, payeePubkey: String, paymentHash: String, paymentSecret: String, routingHints: [Bolt11RouteHint], timestamp: UInt64) {
        self.amountMsat = amountMsat
        self.description = description
        self.descriptionHash = descriptionHash
        self.expiry = expiry
        self.invoice = invoice
        self.minFinalCltvExpiryDelta = minFinalCltvExpiryDelta
        self.network = network
        self.payeePubkey = payeePubkey
        self.paymentHash = paymentHash
        self.paymentSecret = paymentSecret
        self.routingHints = routingHints
        self.timestamp = timestamp
    }
}



extension Bolt11InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt11InvoiceDetails, rhs: Bolt11InvoiceDetails) -> Bool {
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.minFinalCltvExpiryDelta != rhs.minFinalCltvExpiryDelta {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.payeePubkey != rhs.payeePubkey {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.paymentSecret != rhs.paymentSecret {
            return false
        }
        if lhs.routingHints != rhs.routingHints {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountMsat)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(expiry)
        hasher.combine(invoice)
        hasher.combine(minFinalCltvExpiryDelta)
        hasher.combine(network)
        hasher.combine(payeePubkey)
        hasher.combine(paymentHash)
        hasher.combine(paymentSecret)
        hasher.combine(routingHints)
        hasher.combine(timestamp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11InvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11InvoiceDetails {
        return
            try Bolt11InvoiceDetails(
                amountMsat: FfiConverterOptionUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterUInt64.read(from: &buf), 
                invoice: FfiConverterTypeBolt11Invoice.read(from: &buf), 
                minFinalCltvExpiryDelta: FfiConverterUInt64.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                payeePubkey: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                paymentSecret: FfiConverterString.read(from: &buf), 
                routingHints: FfiConverterSequenceTypeBolt11RouteHint.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterUInt64.write(value.expiry, into: &buf)
        FfiConverterTypeBolt11Invoice.write(value.invoice, into: &buf)
        FfiConverterUInt64.write(value.minFinalCltvExpiryDelta, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterString.write(value.payeePubkey, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterString.write(value.paymentSecret, into: &buf)
        FfiConverterSequenceTypeBolt11RouteHint.write(value.routingHints, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11InvoiceDetails_lift(_ buf: RustBuffer) throws -> Bolt11InvoiceDetails {
    return try FfiConverterTypeBolt11InvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11InvoiceDetails_lower(_ value: Bolt11InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeBolt11InvoiceDetails.lower(value)
}


public struct Bolt11RouteHint {
    public var hops: [Bolt11RouteHintHop]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hops: [Bolt11RouteHintHop]) {
        self.hops = hops
    }
}



extension Bolt11RouteHint: Equatable, Hashable {
    public static func ==(lhs: Bolt11RouteHint, rhs: Bolt11RouteHint) -> Bool {
        if lhs.hops != rhs.hops {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hops)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11RouteHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11RouteHint {
        return
            try Bolt11RouteHint(
                hops: FfiConverterSequenceTypeBolt11RouteHintHop.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11RouteHint, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBolt11RouteHintHop.write(value.hops, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHint_lift(_ buf: RustBuffer) throws -> Bolt11RouteHint {
    return try FfiConverterTypeBolt11RouteHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHint_lower(_ value: Bolt11RouteHint) -> RustBuffer {
    return FfiConverterTypeBolt11RouteHint.lower(value)
}


public struct Bolt11RouteHintHop {
    /**
     * The `node_id` of the non-target end of the route
     */
    public var srcNodeId: String
    /**
     * The `short_channel_id` of this channel
     */
    public var shortChannelId: String
    /**
     * The fees which must be paid to use this channel
     */
    public var feesBaseMsat: UInt32
    public var feesProportionalMillionths: UInt32
    /**
     * The difference in CLTV values between this node and the next node.
     */
    public var cltvExpiryDelta: UInt16
    /**
     * The minimum value, in msat, which must be relayed to the next hop.
     */
    public var htlcMinimumMsat: UInt64?
    /**
     * The maximum value in msat available for routing with a single HTLC.
     */
    public var htlcMaximumMsat: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The `node_id` of the non-target end of the route
         */srcNodeId: String, 
        /**
         * The `short_channel_id` of this channel
         */shortChannelId: String, 
        /**
         * The fees which must be paid to use this channel
         */feesBaseMsat: UInt32, feesProportionalMillionths: UInt32, 
        /**
         * The difference in CLTV values between this node and the next node.
         */cltvExpiryDelta: UInt16, 
        /**
         * The minimum value, in msat, which must be relayed to the next hop.
         */htlcMinimumMsat: UInt64?, 
        /**
         * The maximum value in msat available for routing with a single HTLC.
         */htlcMaximumMsat: UInt64?) {
        self.srcNodeId = srcNodeId
        self.shortChannelId = shortChannelId
        self.feesBaseMsat = feesBaseMsat
        self.feesProportionalMillionths = feesProportionalMillionths
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
    }
}



extension Bolt11RouteHintHop: Equatable, Hashable {
    public static func ==(lhs: Bolt11RouteHintHop, rhs: Bolt11RouteHintHop) -> Bool {
        if lhs.srcNodeId != rhs.srcNodeId {
            return false
        }
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.feesBaseMsat != rhs.feesBaseMsat {
            return false
        }
        if lhs.feesProportionalMillionths != rhs.feesProportionalMillionths {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(srcNodeId)
        hasher.combine(shortChannelId)
        hasher.combine(feesBaseMsat)
        hasher.combine(feesProportionalMillionths)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11RouteHintHop: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11RouteHintHop {
        return
            try Bolt11RouteHintHop(
                srcNodeId: FfiConverterString.read(from: &buf), 
                shortChannelId: FfiConverterString.read(from: &buf), 
                feesBaseMsat: FfiConverterUInt32.read(from: &buf), 
                feesProportionalMillionths: FfiConverterUInt32.read(from: &buf), 
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf), 
                htlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                htlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11RouteHintHop, into buf: inout [UInt8]) {
        FfiConverterString.write(value.srcNodeId, into: &buf)
        FfiConverterString.write(value.shortChannelId, into: &buf)
        FfiConverterUInt32.write(value.feesBaseMsat, into: &buf)
        FfiConverterUInt32.write(value.feesProportionalMillionths, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMaximumMsat, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHintHop_lift(_ buf: RustBuffer) throws -> Bolt11RouteHintHop {
    return try FfiConverterTypeBolt11RouteHintHop.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHintHop_lower(_ value: Bolt11RouteHintHop) -> RustBuffer {
    return FfiConverterTypeBolt11RouteHintHop.lower(value)
}


public struct Bolt12Invoice {
    public var invoice: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(invoice: String, source: PaymentRequestSource) {
        self.invoice = invoice
        self.source = source
    }
}



extension Bolt12Invoice: Equatable, Hashable {
    public static func ==(lhs: Bolt12Invoice, rhs: Bolt12Invoice) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12Invoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Invoice {
        return
            try Bolt12Invoice(
                invoice: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12Invoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Invoice_lift(_ buf: RustBuffer) throws -> Bolt12Invoice {
    return try FfiConverterTypeBolt12Invoice.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Invoice_lower(_ value: Bolt12Invoice) -> RustBuffer {
    return FfiConverterTypeBolt12Invoice.lower(value)
}


public struct Bolt12InvoiceDetails {
    public var amountMsat: UInt64
    public var invoice: Bolt12Invoice

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountMsat: UInt64, invoice: Bolt12Invoice) {
        self.amountMsat = amountMsat
        self.invoice = invoice
    }
}



extension Bolt12InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12InvoiceDetails, rhs: Bolt12InvoiceDetails) -> Bool {
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountMsat)
        hasher.combine(invoice)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12InvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12InvoiceDetails {
        return
            try Bolt12InvoiceDetails(
                amountMsat: FfiConverterUInt64.read(from: &buf), 
                invoice: FfiConverterTypeBolt12Invoice.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountMsat, into: &buf)
        FfiConverterTypeBolt12Invoice.write(value.invoice, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceDetails_lift(_ buf: RustBuffer) throws -> Bolt12InvoiceDetails {
    return try FfiConverterTypeBolt12InvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceDetails_lower(_ value: Bolt12InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeBolt12InvoiceDetails.lower(value)
}


public struct Bolt12InvoiceRequestDetails {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension Bolt12InvoiceRequestDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12InvoiceRequestDetails, rhs: Bolt12InvoiceRequestDetails) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12InvoiceRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12InvoiceRequestDetails {
        return
            Bolt12InvoiceRequestDetails()
    }

    public static func write(_ value: Bolt12InvoiceRequestDetails, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceRequestDetails_lift(_ buf: RustBuffer) throws -> Bolt12InvoiceRequestDetails {
    return try FfiConverterTypeBolt12InvoiceRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceRequestDetails_lower(_ value: Bolt12InvoiceRequestDetails) -> RustBuffer {
    return FfiConverterTypeBolt12InvoiceRequestDetails.lower(value)
}


public struct Bolt12Offer {
    public var offer: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(offer: String, source: PaymentRequestSource) {
        self.offer = offer
        self.source = source
    }
}



extension Bolt12Offer: Equatable, Hashable {
    public static func ==(lhs: Bolt12Offer, rhs: Bolt12Offer) -> Bool {
        if lhs.offer != rhs.offer {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(offer)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12Offer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Offer {
        return
            try Bolt12Offer(
                offer: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12Offer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.offer, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Offer_lift(_ buf: RustBuffer) throws -> Bolt12Offer {
    return try FfiConverterTypeBolt12Offer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Offer_lower(_ value: Bolt12Offer) -> RustBuffer {
    return FfiConverterTypeBolt12Offer.lower(value)
}


public struct Bolt12OfferBlindedPath {
    public var blindedHops: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blindedHops: [String]) {
        self.blindedHops = blindedHops
    }
}



extension Bolt12OfferBlindedPath: Equatable, Hashable {
    public static func ==(lhs: Bolt12OfferBlindedPath, rhs: Bolt12OfferBlindedPath) -> Bool {
        if lhs.blindedHops != rhs.blindedHops {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blindedHops)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12OfferBlindedPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12OfferBlindedPath {
        return
            try Bolt12OfferBlindedPath(
                blindedHops: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12OfferBlindedPath, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.blindedHops, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferBlindedPath_lift(_ buf: RustBuffer) throws -> Bolt12OfferBlindedPath {
    return try FfiConverterTypeBolt12OfferBlindedPath.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferBlindedPath_lower(_ value: Bolt12OfferBlindedPath) -> RustBuffer {
    return FfiConverterTypeBolt12OfferBlindedPath.lower(value)
}


public struct Bolt12OfferDetails {
    public var absoluteExpiry: UInt64?
    public var chains: [String]
    public var description: String?
    public var issuer: String?
    public var minAmount: Amount?
    public var offer: Bolt12Offer
    public var paths: [Bolt12OfferBlindedPath]
    public var signingPubkey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(absoluteExpiry: UInt64?, chains: [String], description: String?, issuer: String?, minAmount: Amount?, offer: Bolt12Offer, paths: [Bolt12OfferBlindedPath], signingPubkey: String?) {
        self.absoluteExpiry = absoluteExpiry
        self.chains = chains
        self.description = description
        self.issuer = issuer
        self.minAmount = minAmount
        self.offer = offer
        self.paths = paths
        self.signingPubkey = signingPubkey
    }
}



extension Bolt12OfferDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12OfferDetails, rhs: Bolt12OfferDetails) -> Bool {
        if lhs.absoluteExpiry != rhs.absoluteExpiry {
            return false
        }
        if lhs.chains != rhs.chains {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.issuer != rhs.issuer {
            return false
        }
        if lhs.minAmount != rhs.minAmount {
            return false
        }
        if lhs.offer != rhs.offer {
            return false
        }
        if lhs.paths != rhs.paths {
            return false
        }
        if lhs.signingPubkey != rhs.signingPubkey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(absoluteExpiry)
        hasher.combine(chains)
        hasher.combine(description)
        hasher.combine(issuer)
        hasher.combine(minAmount)
        hasher.combine(offer)
        hasher.combine(paths)
        hasher.combine(signingPubkey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12OfferDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12OfferDetails {
        return
            try Bolt12OfferDetails(
                absoluteExpiry: FfiConverterOptionUInt64.read(from: &buf), 
                chains: FfiConverterSequenceString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                issuer: FfiConverterOptionString.read(from: &buf), 
                minAmount: FfiConverterOptionTypeAmount.read(from: &buf), 
                offer: FfiConverterTypeBolt12Offer.read(from: &buf), 
                paths: FfiConverterSequenceTypeBolt12OfferBlindedPath.read(from: &buf), 
                signingPubkey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12OfferDetails, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.absoluteExpiry, into: &buf)
        FfiConverterSequenceString.write(value.chains, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.issuer, into: &buf)
        FfiConverterOptionTypeAmount.write(value.minAmount, into: &buf)
        FfiConverterTypeBolt12Offer.write(value.offer, into: &buf)
        FfiConverterSequenceTypeBolt12OfferBlindedPath.write(value.paths, into: &buf)
        FfiConverterOptionString.write(value.signingPubkey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferDetails_lift(_ buf: RustBuffer) throws -> Bolt12OfferDetails {
    return try FfiConverterTypeBolt12OfferDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferDetails_lower(_ value: Bolt12OfferDetails) -> RustBuffer {
    return FfiConverterTypeBolt12OfferDetails.lower(value)
}


public struct BurnIssuerTokenRequest {
    public var amount: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: U128) {
        self.amount = amount
    }
}



extension BurnIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: BurnIssuerTokenRequest, rhs: BurnIssuerTokenRequest) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBurnIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BurnIssuerTokenRequest {
        return
            try BurnIssuerTokenRequest(
                amount: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: BurnIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterTypeu128.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBurnIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> BurnIssuerTokenRequest {
    return try FfiConverterTypeBurnIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBurnIssuerTokenRequest_lower(_ value: BurnIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeBurnIssuerTokenRequest.lower(value)
}


public struct CheckLightningAddressRequest {
    public var username: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String) {
        self.username = username
    }
}



extension CheckLightningAddressRequest: Equatable, Hashable {
    public static func ==(lhs: CheckLightningAddressRequest, rhs: CheckLightningAddressRequest) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckLightningAddressRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckLightningAddressRequest {
        return
            try CheckLightningAddressRequest(
                username: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CheckLightningAddressRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckLightningAddressRequest_lift(_ buf: RustBuffer) throws -> CheckLightningAddressRequest {
    return try FfiConverterTypeCheckLightningAddressRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckLightningAddressRequest_lower(_ value: CheckLightningAddressRequest) -> RustBuffer {
    return FfiConverterTypeCheckLightningAddressRequest.lower(value)
}


public struct CheckMessageRequest {
    /**
     * The message that was signed
     */
    public var message: String
    /**
     * The public key that signed the message
     */
    public var pubkey: String
    /**
     * The DER or compact hex encoded signature
     */
    public var signature: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The message that was signed
         */message: String, 
        /**
         * The public key that signed the message
         */pubkey: String, 
        /**
         * The DER or compact hex encoded signature
         */signature: String) {
        self.message = message
        self.pubkey = pubkey
        self.signature = signature
    }
}



extension CheckMessageRequest: Equatable, Hashable {
    public static func ==(lhs: CheckMessageRequest, rhs: CheckMessageRequest) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(pubkey)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckMessageRequest {
        return
            try CheckMessageRequest(
                message: FfiConverterString.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CheckMessageRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageRequest_lift(_ buf: RustBuffer) throws -> CheckMessageRequest {
    return try FfiConverterTypeCheckMessageRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageRequest_lower(_ value: CheckMessageRequest) -> RustBuffer {
    return FfiConverterTypeCheckMessageRequest.lower(value)
}


public struct CheckMessageResponse {
    public var isValid: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isValid: Bool) {
        self.isValid = isValid
    }
}



extension CheckMessageResponse: Equatable, Hashable {
    public static func ==(lhs: CheckMessageResponse, rhs: CheckMessageResponse) -> Bool {
        if lhs.isValid != rhs.isValid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isValid)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckMessageResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckMessageResponse {
        return
            try CheckMessageResponse(
                isValid: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CheckMessageResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isValid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageResponse_lift(_ buf: RustBuffer) throws -> CheckMessageResponse {
    return try FfiConverterTypeCheckMessageResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageResponse_lower(_ value: CheckMessageResponse) -> RustBuffer {
    return FfiConverterTypeCheckMessageResponse.lower(value)
}


public struct ClaimDepositRequest {
    public var txid: String
    public var vout: UInt32
    public var maxFee: Fee?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, maxFee: Fee? = nil) {
        self.txid = txid
        self.vout = vout
        self.maxFee = maxFee
    }
}



extension ClaimDepositRequest: Equatable, Hashable {
    public static func ==(lhs: ClaimDepositRequest, rhs: ClaimDepositRequest) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.maxFee != rhs.maxFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(maxFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimDepositRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimDepositRequest {
        return
            try ClaimDepositRequest(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                maxFee: FfiConverterOptionTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimDepositRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterOptionTypeFee.write(value.maxFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositRequest_lift(_ buf: RustBuffer) throws -> ClaimDepositRequest {
    return try FfiConverterTypeClaimDepositRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositRequest_lower(_ value: ClaimDepositRequest) -> RustBuffer {
    return FfiConverterTypeClaimDepositRequest.lower(value)
}


public struct ClaimDepositResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension ClaimDepositResponse: Equatable, Hashable {
    public static func ==(lhs: ClaimDepositResponse, rhs: ClaimDepositResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimDepositResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimDepositResponse {
        return
            try ClaimDepositResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimDepositResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositResponse_lift(_ buf: RustBuffer) throws -> ClaimDepositResponse {
    return try FfiConverterTypeClaimDepositResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositResponse_lower(_ value: ClaimDepositResponse) -> RustBuffer {
    return FfiConverterTypeClaimDepositResponse.lower(value)
}


public struct ClaimHtlcPaymentRequest {
    public var preimage: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(preimage: String) {
        self.preimage = preimage
    }
}



extension ClaimHtlcPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: ClaimHtlcPaymentRequest, rhs: ClaimHtlcPaymentRequest) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimHtlcPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimHtlcPaymentRequest {
        return
            try ClaimHtlcPaymentRequest(
                preimage: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimHtlcPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimHtlcPaymentRequest_lift(_ buf: RustBuffer) throws -> ClaimHtlcPaymentRequest {
    return try FfiConverterTypeClaimHtlcPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimHtlcPaymentRequest_lower(_ value: ClaimHtlcPaymentRequest) -> RustBuffer {
    return FfiConverterTypeClaimHtlcPaymentRequest.lower(value)
}


public struct ClaimHtlcPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension ClaimHtlcPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: ClaimHtlcPaymentResponse, rhs: ClaimHtlcPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimHtlcPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimHtlcPaymentResponse {
        return
            try ClaimHtlcPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimHtlcPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimHtlcPaymentResponse_lift(_ buf: RustBuffer) throws -> ClaimHtlcPaymentResponse {
    return try FfiConverterTypeClaimHtlcPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimHtlcPaymentResponse_lower(_ value: ClaimHtlcPaymentResponse) -> RustBuffer {
    return FfiConverterTypeClaimHtlcPaymentResponse.lower(value)
}


public struct Config {
    public var apiKey: String?
    public var network: Network
    public var syncIntervalSecs: UInt32
    public var maxDepositClaimFee: Fee?
    /**
     * The domain used for receiving through lnurl-pay and lightning address.
     */
    public var lnurlDomain: String?
    /**
     * When this is set to `true` we will prefer to use spark payments over
     * lightning when sending and receiving. This has the benefit of lower fees
     * but is at the cost of privacy.
     */
    public var preferSparkOverLightning: Bool
    /**
     * A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
     * is not recognized. See [`ExternalInputParser`] for more details on how to configure
     * external parsing.
     */
    public var externalInputParsers: [ExternalInputParser]?
    /**
     * The SDK includes some default external input parsers
     * ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
     * Set this to false in order to prevent their use.
     */
    public var useDefaultExternalInputParsers: Bool
    /**
     * Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
     */
    public var realTimeSyncServerUrl: String?
    /**
     * Whether the Spark private mode is enabled by default.
     *
     * If set to true, the Spark private mode will be enabled on the first initialization of the SDK.
     * If set to false, no changes will be made to the Spark private mode.
     */
    public var privateEnabledDefault: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(apiKey: String?, network: Network, syncIntervalSecs: UInt32, maxDepositClaimFee: Fee?, 
        /**
         * The domain used for receiving through lnurl-pay and lightning address.
         */lnurlDomain: String?, 
        /**
         * When this is set to `true` we will prefer to use spark payments over
         * lightning when sending and receiving. This has the benefit of lower fees
         * but is at the cost of privacy.
         */preferSparkOverLightning: Bool, 
        /**
         * A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
         * is not recognized. See [`ExternalInputParser`] for more details on how to configure
         * external parsing.
         */externalInputParsers: [ExternalInputParser]?, 
        /**
         * The SDK includes some default external input parsers
         * ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
         * Set this to false in order to prevent their use.
         */useDefaultExternalInputParsers: Bool, 
        /**
         * Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
         */realTimeSyncServerUrl: String?, 
        /**
         * Whether the Spark private mode is enabled by default.
         *
         * If set to true, the Spark private mode will be enabled on the first initialization of the SDK.
         * If set to false, no changes will be made to the Spark private mode.
         */privateEnabledDefault: Bool) {
        self.apiKey = apiKey
        self.network = network
        self.syncIntervalSecs = syncIntervalSecs
        self.maxDepositClaimFee = maxDepositClaimFee
        self.lnurlDomain = lnurlDomain
        self.preferSparkOverLightning = preferSparkOverLightning
        self.externalInputParsers = externalInputParsers
        self.useDefaultExternalInputParsers = useDefaultExternalInputParsers
        self.realTimeSyncServerUrl = realTimeSyncServerUrl
        self.privateEnabledDefault = privateEnabledDefault
    }
}



extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.apiKey != rhs.apiKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.syncIntervalSecs != rhs.syncIntervalSecs {
            return false
        }
        if lhs.maxDepositClaimFee != rhs.maxDepositClaimFee {
            return false
        }
        if lhs.lnurlDomain != rhs.lnurlDomain {
            return false
        }
        if lhs.preferSparkOverLightning != rhs.preferSparkOverLightning {
            return false
        }
        if lhs.externalInputParsers != rhs.externalInputParsers {
            return false
        }
        if lhs.useDefaultExternalInputParsers != rhs.useDefaultExternalInputParsers {
            return false
        }
        if lhs.realTimeSyncServerUrl != rhs.realTimeSyncServerUrl {
            return false
        }
        if lhs.privateEnabledDefault != rhs.privateEnabledDefault {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(apiKey)
        hasher.combine(network)
        hasher.combine(syncIntervalSecs)
        hasher.combine(maxDepositClaimFee)
        hasher.combine(lnurlDomain)
        hasher.combine(preferSparkOverLightning)
        hasher.combine(externalInputParsers)
        hasher.combine(useDefaultExternalInputParsers)
        hasher.combine(realTimeSyncServerUrl)
        hasher.combine(privateEnabledDefault)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                apiKey: FfiConverterOptionString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                syncIntervalSecs: FfiConverterUInt32.read(from: &buf), 
                maxDepositClaimFee: FfiConverterOptionTypeFee.read(from: &buf), 
                lnurlDomain: FfiConverterOptionString.read(from: &buf), 
                preferSparkOverLightning: FfiConverterBool.read(from: &buf), 
                externalInputParsers: FfiConverterOptionSequenceTypeExternalInputParser.read(from: &buf), 
                useDefaultExternalInputParsers: FfiConverterBool.read(from: &buf), 
                realTimeSyncServerUrl: FfiConverterOptionString.read(from: &buf), 
                privateEnabledDefault: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.apiKey, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.syncIntervalSecs, into: &buf)
        FfiConverterOptionTypeFee.write(value.maxDepositClaimFee, into: &buf)
        FfiConverterOptionString.write(value.lnurlDomain, into: &buf)
        FfiConverterBool.write(value.preferSparkOverLightning, into: &buf)
        FfiConverterOptionSequenceTypeExternalInputParser.write(value.externalInputParsers, into: &buf)
        FfiConverterBool.write(value.useDefaultExternalInputParsers, into: &buf)
        FfiConverterOptionString.write(value.realTimeSyncServerUrl, into: &buf)
        FfiConverterBool.write(value.privateEnabledDefault, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct ConnectRequest {
    public var config: Config
    public var seed: Seed
    public var storageDir: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(config: Config, seed: Seed, storageDir: String) {
        self.config = config
        self.seed = seed
        self.storageDir = storageDir
    }
}



extension ConnectRequest: Equatable, Hashable {
    public static func ==(lhs: ConnectRequest, rhs: ConnectRequest) -> Bool {
        if lhs.config != rhs.config {
            return false
        }
        if lhs.seed != rhs.seed {
            return false
        }
        if lhs.storageDir != rhs.storageDir {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(config)
        hasher.combine(seed)
        hasher.combine(storageDir)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectRequest {
        return
            try ConnectRequest(
                config: FfiConverterTypeConfig.read(from: &buf), 
                seed: FfiConverterTypeSeed.read(from: &buf), 
                storageDir: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ConnectRequest, into buf: inout [UInt8]) {
        FfiConverterTypeConfig.write(value.config, into: &buf)
        FfiConverterTypeSeed.write(value.seed, into: &buf)
        FfiConverterString.write(value.storageDir, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectRequest_lift(_ buf: RustBuffer) throws -> ConnectRequest {
    return try FfiConverterTypeConnectRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectRequest_lower(_ value: ConnectRequest) -> RustBuffer {
    return FfiConverterTypeConnectRequest.lower(value)
}


public struct CreateIssuerTokenRequest {
    public var name: String
    public var ticker: String
    public var decimals: UInt32
    public var isFreezable: Bool
    public var maxSupply: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, ticker: String, decimals: UInt32, isFreezable: Bool, maxSupply: U128) {
        self.name = name
        self.ticker = ticker
        self.decimals = decimals
        self.isFreezable = isFreezable
        self.maxSupply = maxSupply
    }
}



extension CreateIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: CreateIssuerTokenRequest, rhs: CreateIssuerTokenRequest) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.isFreezable != rhs.isFreezable {
            return false
        }
        if lhs.maxSupply != rhs.maxSupply {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(ticker)
        hasher.combine(decimals)
        hasher.combine(isFreezable)
        hasher.combine(maxSupply)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateIssuerTokenRequest {
        return
            try CreateIssuerTokenRequest(
                name: FfiConverterString.read(from: &buf), 
                ticker: FfiConverterString.read(from: &buf), 
                decimals: FfiConverterUInt32.read(from: &buf), 
                isFreezable: FfiConverterBool.read(from: &buf), 
                maxSupply: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: CreateIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.ticker, into: &buf)
        FfiConverterUInt32.write(value.decimals, into: &buf)
        FfiConverterBool.write(value.isFreezable, into: &buf)
        FfiConverterTypeu128.write(value.maxSupply, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> CreateIssuerTokenRequest {
    return try FfiConverterTypeCreateIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateIssuerTokenRequest_lower(_ value: CreateIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeCreateIssuerTokenRequest.lower(value)
}


public struct Credentials {
    public var username: String
    public var password: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String, password: String) {
        self.username = username
        self.password = password
    }
}



extension Credentials: Equatable, Hashable {
    public static func ==(lhs: Credentials, rhs: Credentials) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentials: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Credentials {
        return
            try Credentials(
                username: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Credentials, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentials_lift(_ buf: RustBuffer) throws -> Credentials {
    return try FfiConverterTypeCredentials.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentials_lower(_ value: Credentials) -> RustBuffer {
    return FfiConverterTypeCredentials.lower(value)
}


/**
 * Details about a supported currency in the fiat rate feed
 */
public struct CurrencyInfo {
    public var name: String
    public var fractionSize: UInt32
    public var spacing: UInt32?
    public var symbol: Symbol?
    public var uniqSymbol: Symbol?
    public var localizedName: [LocalizedName]
    public var localeOverrides: [LocaleOverrides]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, fractionSize: UInt32, spacing: UInt32?, symbol: Symbol?, uniqSymbol: Symbol?, localizedName: [LocalizedName], localeOverrides: [LocaleOverrides]) {
        self.name = name
        self.fractionSize = fractionSize
        self.spacing = spacing
        self.symbol = symbol
        self.uniqSymbol = uniqSymbol
        self.localizedName = localizedName
        self.localeOverrides = localeOverrides
    }
}



extension CurrencyInfo: Equatable, Hashable {
    public static func ==(lhs: CurrencyInfo, rhs: CurrencyInfo) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.fractionSize != rhs.fractionSize {
            return false
        }
        if lhs.spacing != rhs.spacing {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.uniqSymbol != rhs.uniqSymbol {
            return false
        }
        if lhs.localizedName != rhs.localizedName {
            return false
        }
        if lhs.localeOverrides != rhs.localeOverrides {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(fractionSize)
        hasher.combine(spacing)
        hasher.combine(symbol)
        hasher.combine(uniqSymbol)
        hasher.combine(localizedName)
        hasher.combine(localeOverrides)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCurrencyInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurrencyInfo {
        return
            try CurrencyInfo(
                name: FfiConverterString.read(from: &buf), 
                fractionSize: FfiConverterUInt32.read(from: &buf), 
                spacing: FfiConverterOptionUInt32.read(from: &buf), 
                symbol: FfiConverterOptionTypeSymbol.read(from: &buf), 
                uniqSymbol: FfiConverterOptionTypeSymbol.read(from: &buf), 
                localizedName: FfiConverterSequenceTypeLocalizedName.read(from: &buf), 
                localeOverrides: FfiConverterSequenceTypeLocaleOverrides.read(from: &buf)
        )
    }

    public static func write(_ value: CurrencyInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt32.write(value.fractionSize, into: &buf)
        FfiConverterOptionUInt32.write(value.spacing, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.symbol, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.uniqSymbol, into: &buf)
        FfiConverterSequenceTypeLocalizedName.write(value.localizedName, into: &buf)
        FfiConverterSequenceTypeLocaleOverrides.write(value.localeOverrides, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrencyInfo_lift(_ buf: RustBuffer) throws -> CurrencyInfo {
    return try FfiConverterTypeCurrencyInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrencyInfo_lower(_ value: CurrencyInfo) -> RustBuffer {
    return FfiConverterTypeCurrencyInfo.lower(value)
}


public struct DepositInfo {
    public var txid: String
    public var vout: UInt32
    public var amountSats: UInt64
    public var refundTx: String?
    public var refundTxId: String?
    public var claimError: DepositClaimError?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, amountSats: UInt64, refundTx: String?, refundTxId: String?, claimError: DepositClaimError?) {
        self.txid = txid
        self.vout = vout
        self.amountSats = amountSats
        self.refundTx = refundTx
        self.refundTxId = refundTxId
        self.claimError = claimError
    }
}



extension DepositInfo: Equatable, Hashable {
    public static func ==(lhs: DepositInfo, rhs: DepositInfo) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.refundTx != rhs.refundTx {
            return false
        }
        if lhs.refundTxId != rhs.refundTxId {
            return false
        }
        if lhs.claimError != rhs.claimError {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(amountSats)
        hasher.combine(refundTx)
        hasher.combine(refundTxId)
        hasher.combine(claimError)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositInfo {
        return
            try DepositInfo(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                amountSats: FfiConverterUInt64.read(from: &buf), 
                refundTx: FfiConverterOptionString.read(from: &buf), 
                refundTxId: FfiConverterOptionString.read(from: &buf), 
                claimError: FfiConverterOptionTypeDepositClaimError.read(from: &buf)
        )
    }

    public static func write(_ value: DepositInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.refundTx, into: &buf)
        FfiConverterOptionString.write(value.refundTxId, into: &buf)
        FfiConverterOptionTypeDepositClaimError.write(value.claimError, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositInfo_lift(_ buf: RustBuffer) throws -> DepositInfo {
    return try FfiConverterTypeDepositInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositInfo_lower(_ value: DepositInfo) -> RustBuffer {
    return FfiConverterTypeDepositInfo.lower(value)
}


/**
 * Configuration for an external input parser
 */
public struct ExternalInputParser {
    /**
     * An arbitrary parser provider id
     */
    public var providerId: String
    /**
     * The external parser will be used when an input conforms to this regex
     */
    public var inputRegex: String
    /**
     * The URL of the parser containing a placeholder `<input>` that will be replaced with the
     * input to be parsed. The input is sanitized using percent encoding.
     */
    public var parserUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * An arbitrary parser provider id
         */providerId: String, 
        /**
         * The external parser will be used when an input conforms to this regex
         */inputRegex: String, 
        /**
         * The URL of the parser containing a placeholder `<input>` that will be replaced with the
         * input to be parsed. The input is sanitized using percent encoding.
         */parserUrl: String) {
        self.providerId = providerId
        self.inputRegex = inputRegex
        self.parserUrl = parserUrl
    }
}



extension ExternalInputParser: Equatable, Hashable {
    public static func ==(lhs: ExternalInputParser, rhs: ExternalInputParser) -> Bool {
        if lhs.providerId != rhs.providerId {
            return false
        }
        if lhs.inputRegex != rhs.inputRegex {
            return false
        }
        if lhs.parserUrl != rhs.parserUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(providerId)
        hasher.combine(inputRegex)
        hasher.combine(parserUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalInputParser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalInputParser {
        return
            try ExternalInputParser(
                providerId: FfiConverterString.read(from: &buf), 
                inputRegex: FfiConverterString.read(from: &buf), 
                parserUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalInputParser, into buf: inout [UInt8]) {
        FfiConverterString.write(value.providerId, into: &buf)
        FfiConverterString.write(value.inputRegex, into: &buf)
        FfiConverterString.write(value.parserUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalInputParser_lift(_ buf: RustBuffer) throws -> ExternalInputParser {
    return try FfiConverterTypeExternalInputParser.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalInputParser_lower(_ value: ExternalInputParser) -> RustBuffer {
    return FfiConverterTypeExternalInputParser.lower(value)
}


/**
 * Wrapper around the [`CurrencyInfo`] of a fiat currency
 */
public struct FiatCurrency {
    public var id: String
    public var info: CurrencyInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, info: CurrencyInfo) {
        self.id = id
        self.info = info
    }
}



extension FiatCurrency: Equatable, Hashable {
    public static func ==(lhs: FiatCurrency, rhs: FiatCurrency) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.info != rhs.info {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(info)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        return
            try FiatCurrency(
                id: FfiConverterString.read(from: &buf), 
                info: FfiConverterTypeCurrencyInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeCurrencyInfo.write(value.info, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}


public struct FreezeIssuerTokenRequest {
    public var address: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String) {
        self.address = address
    }
}



extension FreezeIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: FreezeIssuerTokenRequest, rhs: FreezeIssuerTokenRequest) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFreezeIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FreezeIssuerTokenRequest {
        return
            try FreezeIssuerTokenRequest(
                address: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FreezeIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFreezeIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> FreezeIssuerTokenRequest {
    return try FfiConverterTypeFreezeIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFreezeIssuerTokenRequest_lower(_ value: FreezeIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeFreezeIssuerTokenRequest.lower(value)
}


public struct FreezeIssuerTokenResponse {
    public var impactedOutputIds: [String]
    public var impactedTokenAmount: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(impactedOutputIds: [String], impactedTokenAmount: U128) {
        self.impactedOutputIds = impactedOutputIds
        self.impactedTokenAmount = impactedTokenAmount
    }
}



extension FreezeIssuerTokenResponse: Equatable, Hashable {
    public static func ==(lhs: FreezeIssuerTokenResponse, rhs: FreezeIssuerTokenResponse) -> Bool {
        if lhs.impactedOutputIds != rhs.impactedOutputIds {
            return false
        }
        if lhs.impactedTokenAmount != rhs.impactedTokenAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(impactedOutputIds)
        hasher.combine(impactedTokenAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFreezeIssuerTokenResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FreezeIssuerTokenResponse {
        return
            try FreezeIssuerTokenResponse(
                impactedOutputIds: FfiConverterSequenceString.read(from: &buf), 
                impactedTokenAmount: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: FreezeIssuerTokenResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.impactedOutputIds, into: &buf)
        FfiConverterTypeu128.write(value.impactedTokenAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFreezeIssuerTokenResponse_lift(_ buf: RustBuffer) throws -> FreezeIssuerTokenResponse {
    return try FfiConverterTypeFreezeIssuerTokenResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFreezeIssuerTokenResponse_lower(_ value: FreezeIssuerTokenResponse) -> RustBuffer {
    return FfiConverterTypeFreezeIssuerTokenResponse.lower(value)
}


/**
 * Request to get the balance of the wallet
 */
public struct GetInfoRequest {
    public var ensureSynced: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ensureSynced: Bool?) {
        self.ensureSynced = ensureSynced
    }
}



extension GetInfoRequest: Equatable, Hashable {
    public static func ==(lhs: GetInfoRequest, rhs: GetInfoRequest) -> Bool {
        if lhs.ensureSynced != rhs.ensureSynced {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ensureSynced)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoRequest {
        return
            try GetInfoRequest(
                ensureSynced: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoRequest, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.ensureSynced, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoRequest_lift(_ buf: RustBuffer) throws -> GetInfoRequest {
    return try FfiConverterTypeGetInfoRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoRequest_lower(_ value: GetInfoRequest) -> RustBuffer {
    return FfiConverterTypeGetInfoRequest.lower(value)
}


/**
 * Response containing the balance of the wallet
 */
public struct GetInfoResponse {
    /**
     * The balance in satoshis
     */
    public var balanceSats: UInt64
    /**
     * The balances of the tokens in the wallet keyed by the token identifier
     */
    public var tokenBalances: [String: TokenBalance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The balance in satoshis
         */balanceSats: UInt64, 
        /**
         * The balances of the tokens in the wallet keyed by the token identifier
         */tokenBalances: [String: TokenBalance]) {
        self.balanceSats = balanceSats
        self.tokenBalances = tokenBalances
    }
}



extension GetInfoResponse: Equatable, Hashable {
    public static func ==(lhs: GetInfoResponse, rhs: GetInfoResponse) -> Bool {
        if lhs.balanceSats != rhs.balanceSats {
            return false
        }
        if lhs.tokenBalances != rhs.tokenBalances {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balanceSats)
        hasher.combine(tokenBalances)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoResponse {
        return
            try GetInfoResponse(
                balanceSats: FfiConverterUInt64.read(from: &buf), 
                tokenBalances: FfiConverterDictionaryStringTypeTokenBalance.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.balanceSats, into: &buf)
        FfiConverterDictionaryStringTypeTokenBalance.write(value.tokenBalances, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lift(_ buf: RustBuffer) throws -> GetInfoResponse {
    return try FfiConverterTypeGetInfoResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lower(_ value: GetInfoResponse) -> RustBuffer {
    return FfiConverterTypeGetInfoResponse.lower(value)
}


public struct GetPaymentRequest {
    public var paymentId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentId: String) {
        self.paymentId = paymentId
    }
}



extension GetPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: GetPaymentRequest, rhs: GetPaymentRequest) -> Bool {
        if lhs.paymentId != rhs.paymentId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPaymentRequest {
        return
            try GetPaymentRequest(
                paymentId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GetPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentRequest_lift(_ buf: RustBuffer) throws -> GetPaymentRequest {
    return try FfiConverterTypeGetPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentRequest_lower(_ value: GetPaymentRequest) -> RustBuffer {
    return FfiConverterTypeGetPaymentRequest.lower(value)
}


public struct GetPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension GetPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: GetPaymentResponse, rhs: GetPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPaymentResponse {
        return
            try GetPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: GetPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentResponse_lift(_ buf: RustBuffer) throws -> GetPaymentResponse {
    return try FfiConverterTypeGetPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentResponse_lower(_ value: GetPaymentResponse) -> RustBuffer {
    return FfiConverterTypeGetPaymentResponse.lower(value)
}


public struct GetTokensMetadataRequest {
    public var tokenIdentifiers: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokenIdentifiers: [String]) {
        self.tokenIdentifiers = tokenIdentifiers
    }
}



extension GetTokensMetadataRequest: Equatable, Hashable {
    public static func ==(lhs: GetTokensMetadataRequest, rhs: GetTokensMetadataRequest) -> Bool {
        if lhs.tokenIdentifiers != rhs.tokenIdentifiers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokenIdentifiers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetTokensMetadataRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetTokensMetadataRequest {
        return
            try GetTokensMetadataRequest(
                tokenIdentifiers: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GetTokensMetadataRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.tokenIdentifiers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataRequest_lift(_ buf: RustBuffer) throws -> GetTokensMetadataRequest {
    return try FfiConverterTypeGetTokensMetadataRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataRequest_lower(_ value: GetTokensMetadataRequest) -> RustBuffer {
    return FfiConverterTypeGetTokensMetadataRequest.lower(value)
}


public struct GetTokensMetadataResponse {
    public var tokensMetadata: [TokenMetadata]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokensMetadata: [TokenMetadata]) {
        self.tokensMetadata = tokensMetadata
    }
}



extension GetTokensMetadataResponse: Equatable, Hashable {
    public static func ==(lhs: GetTokensMetadataResponse, rhs: GetTokensMetadataResponse) -> Bool {
        if lhs.tokensMetadata != rhs.tokensMetadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokensMetadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetTokensMetadataResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetTokensMetadataResponse {
        return
            try GetTokensMetadataResponse(
                tokensMetadata: FfiConverterSequenceTypeTokenMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: GetTokensMetadataResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTokenMetadata.write(value.tokensMetadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataResponse_lift(_ buf: RustBuffer) throws -> GetTokensMetadataResponse {
    return try FfiConverterTypeGetTokensMetadataResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataResponse_lower(_ value: GetTokensMetadataResponse) -> RustBuffer {
    return FfiConverterTypeGetTokensMetadataResponse.lower(value)
}


public struct IncomingChange {
    public var newState: Record
    public var oldState: Record?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(newState: Record, oldState: Record?) {
        self.newState = newState
        self.oldState = oldState
    }
}



extension IncomingChange: Equatable, Hashable {
    public static func ==(lhs: IncomingChange, rhs: IncomingChange) -> Bool {
        if lhs.newState != rhs.newState {
            return false
        }
        if lhs.oldState != rhs.oldState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(newState)
        hasher.combine(oldState)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIncomingChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IncomingChange {
        return
            try IncomingChange(
                newState: FfiConverterTypeRecord.read(from: &buf), 
                oldState: FfiConverterOptionTypeRecord.read(from: &buf)
        )
    }

    public static func write(_ value: IncomingChange, into buf: inout [UInt8]) {
        FfiConverterTypeRecord.write(value.newState, into: &buf)
        FfiConverterOptionTypeRecord.write(value.oldState, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIncomingChange_lift(_ buf: RustBuffer) throws -> IncomingChange {
    return try FfiConverterTypeIncomingChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIncomingChange_lower(_ value: IncomingChange) -> RustBuffer {
    return FfiConverterTypeIncomingChange.lower(value)
}


public struct LightningAddressDetails {
    public var address: String
    public var payRequest: LnurlPayRequestDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, payRequest: LnurlPayRequestDetails) {
        self.address = address
        self.payRequest = payRequest
    }
}



extension LightningAddressDetails: Equatable, Hashable {
    public static func ==(lhs: LightningAddressDetails, rhs: LightningAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(payRequest)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningAddressDetails {
        return
            try LightningAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf)
        )
    }

    public static func write(_ value: LightningAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressDetails_lift(_ buf: RustBuffer) throws -> LightningAddressDetails {
    return try FfiConverterTypeLightningAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressDetails_lower(_ value: LightningAddressDetails) -> RustBuffer {
    return FfiConverterTypeLightningAddressDetails.lower(value)
}


public struct LightningAddressInfo {
    public var description: String
    public var lightningAddress: String
    public var lnurl: String
    public var username: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String, lightningAddress: String, lnurl: String, username: String) {
        self.description = description
        self.lightningAddress = lightningAddress
        self.lnurl = lnurl
        self.username = username
    }
}



extension LightningAddressInfo: Equatable, Hashable {
    public static func ==(lhs: LightningAddressInfo, rhs: LightningAddressInfo) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.lightningAddress != rhs.lightningAddress {
            return false
        }
        if lhs.lnurl != rhs.lnurl {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(lightningAddress)
        hasher.combine(lnurl)
        hasher.combine(username)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningAddressInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningAddressInfo {
        return
            try LightningAddressInfo(
                description: FfiConverterString.read(from: &buf), 
                lightningAddress: FfiConverterString.read(from: &buf), 
                lnurl: FfiConverterString.read(from: &buf), 
                username: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LightningAddressInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.lightningAddress, into: &buf)
        FfiConverterString.write(value.lnurl, into: &buf)
        FfiConverterString.write(value.username, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressInfo_lift(_ buf: RustBuffer) throws -> LightningAddressInfo {
    return try FfiConverterTypeLightningAddressInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressInfo_lower(_ value: LightningAddressInfo) -> RustBuffer {
    return FfiConverterTypeLightningAddressInfo.lower(value)
}


/**
 * Response from listing fiat currencies
 */
public struct ListFiatCurrenciesResponse {
    /**
     * The list of fiat currencies
     */
    public var currencies: [FiatCurrency]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of fiat currencies
         */currencies: [FiatCurrency]) {
        self.currencies = currencies
    }
}



extension ListFiatCurrenciesResponse: Equatable, Hashable {
    public static func ==(lhs: ListFiatCurrenciesResponse, rhs: ListFiatCurrenciesResponse) -> Bool {
        if lhs.currencies != rhs.currencies {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currencies)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListFiatCurrenciesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListFiatCurrenciesResponse {
        return
            try ListFiatCurrenciesResponse(
                currencies: FfiConverterSequenceTypeFiatCurrency.read(from: &buf)
        )
    }

    public static func write(_ value: ListFiatCurrenciesResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFiatCurrency.write(value.currencies, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatCurrenciesResponse_lift(_ buf: RustBuffer) throws -> ListFiatCurrenciesResponse {
    return try FfiConverterTypeListFiatCurrenciesResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatCurrenciesResponse_lower(_ value: ListFiatCurrenciesResponse) -> RustBuffer {
    return FfiConverterTypeListFiatCurrenciesResponse.lower(value)
}


/**
 * Response from listing fiat rates
 */
public struct ListFiatRatesResponse {
    /**
     * The list of fiat rates
     */
    public var rates: [Rate]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of fiat rates
         */rates: [Rate]) {
        self.rates = rates
    }
}



extension ListFiatRatesResponse: Equatable, Hashable {
    public static func ==(lhs: ListFiatRatesResponse, rhs: ListFiatRatesResponse) -> Bool {
        if lhs.rates != rhs.rates {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rates)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListFiatRatesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListFiatRatesResponse {
        return
            try ListFiatRatesResponse(
                rates: FfiConverterSequenceTypeRate.read(from: &buf)
        )
    }

    public static func write(_ value: ListFiatRatesResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRate.write(value.rates, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatRatesResponse_lift(_ buf: RustBuffer) throws -> ListFiatRatesResponse {
    return try FfiConverterTypeListFiatRatesResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatRatesResponse_lower(_ value: ListFiatRatesResponse) -> RustBuffer {
    return FfiConverterTypeListFiatRatesResponse.lower(value)
}


/**
 * Request to list payments with optional filters and pagination
 */
public struct ListPaymentsRequest {
    public var typeFilter: [PaymentType]?
    public var statusFilter: [PaymentStatus]?
    public var assetFilter: AssetFilter?
    /**
     * Only include payments with specific Spark HTLC statuses
     */
    public var sparkHtlcStatusFilter: [SparkHtlcStatus]?
    /**
     * Only include payments created after this timestamp (inclusive)
     */
    public var fromTimestamp: UInt64?
    /**
     * Only include payments created before this timestamp (exclusive)
     */
    public var toTimestamp: UInt64?
    /**
     * Number of records to skip
     */
    public var offset: UInt32?
    /**
     * Maximum number of records to return
     */
    public var limit: UInt32?
    public var sortAscending: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typeFilter: [PaymentType]? = nil, statusFilter: [PaymentStatus]? = nil, assetFilter: AssetFilter? = nil, 
        /**
         * Only include payments with specific Spark HTLC statuses
         */sparkHtlcStatusFilter: [SparkHtlcStatus]? = nil, 
        /**
         * Only include payments created after this timestamp (inclusive)
         */fromTimestamp: UInt64? = nil, 
        /**
         * Only include payments created before this timestamp (exclusive)
         */toTimestamp: UInt64? = nil, 
        /**
         * Number of records to skip
         */offset: UInt32? = nil, 
        /**
         * Maximum number of records to return
         */limit: UInt32? = nil, sortAscending: Bool? = nil) {
        self.typeFilter = typeFilter
        self.statusFilter = statusFilter
        self.assetFilter = assetFilter
        self.sparkHtlcStatusFilter = sparkHtlcStatusFilter
        self.fromTimestamp = fromTimestamp
        self.toTimestamp = toTimestamp
        self.offset = offset
        self.limit = limit
        self.sortAscending = sortAscending
    }
}



extension ListPaymentsRequest: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsRequest, rhs: ListPaymentsRequest) -> Bool {
        if lhs.typeFilter != rhs.typeFilter {
            return false
        }
        if lhs.statusFilter != rhs.statusFilter {
            return false
        }
        if lhs.assetFilter != rhs.assetFilter {
            return false
        }
        if lhs.sparkHtlcStatusFilter != rhs.sparkHtlcStatusFilter {
            return false
        }
        if lhs.fromTimestamp != rhs.fromTimestamp {
            return false
        }
        if lhs.toTimestamp != rhs.toTimestamp {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.sortAscending != rhs.sortAscending {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typeFilter)
        hasher.combine(statusFilter)
        hasher.combine(assetFilter)
        hasher.combine(sparkHtlcStatusFilter)
        hasher.combine(fromTimestamp)
        hasher.combine(toTimestamp)
        hasher.combine(offset)
        hasher.combine(limit)
        hasher.combine(sortAscending)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListPaymentsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsRequest {
        return
            try ListPaymentsRequest(
                typeFilter: FfiConverterOptionSequenceTypePaymentType.read(from: &buf), 
                statusFilter: FfiConverterOptionSequenceTypePaymentStatus.read(from: &buf), 
                assetFilter: FfiConverterOptionTypeAssetFilter.read(from: &buf), 
                sparkHtlcStatusFilter: FfiConverterOptionSequenceTypeSparkHtlcStatus.read(from: &buf), 
                fromTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                toTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                offset: FfiConverterOptionUInt32.read(from: &buf), 
                limit: FfiConverterOptionUInt32.read(from: &buf), 
                sortAscending: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsRequest, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypePaymentType.write(value.typeFilter, into: &buf)
        FfiConverterOptionSequenceTypePaymentStatus.write(value.statusFilter, into: &buf)
        FfiConverterOptionTypeAssetFilter.write(value.assetFilter, into: &buf)
        FfiConverterOptionSequenceTypeSparkHtlcStatus.write(value.sparkHtlcStatusFilter, into: &buf)
        FfiConverterOptionUInt64.write(value.fromTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.toTimestamp, into: &buf)
        FfiConverterOptionUInt32.write(value.offset, into: &buf)
        FfiConverterOptionUInt32.write(value.limit, into: &buf)
        FfiConverterOptionBool.write(value.sortAscending, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsRequest_lift(_ buf: RustBuffer) throws -> ListPaymentsRequest {
    return try FfiConverterTypeListPaymentsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsRequest_lower(_ value: ListPaymentsRequest) -> RustBuffer {
    return FfiConverterTypeListPaymentsRequest.lower(value)
}


/**
 * Response from listing payments
 */
public struct ListPaymentsResponse {
    /**
     * The list of payments
     */
    public var payments: [Payment]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of payments
         */payments: [Payment]) {
        self.payments = payments
    }
}



extension ListPaymentsResponse: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsResponse, rhs: ListPaymentsResponse) -> Bool {
        if lhs.payments != rhs.payments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payments)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListPaymentsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsResponse {
        return
            try ListPaymentsResponse(
                payments: FfiConverterSequenceTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePayment.write(value.payments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsResponse_lift(_ buf: RustBuffer) throws -> ListPaymentsResponse {
    return try FfiConverterTypeListPaymentsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsResponse_lower(_ value: ListPaymentsResponse) -> RustBuffer {
    return FfiConverterTypeListPaymentsResponse.lower(value)
}


public struct ListUnclaimedDepositsRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension ListUnclaimedDepositsRequest: Equatable, Hashable {
    public static func ==(lhs: ListUnclaimedDepositsRequest, rhs: ListUnclaimedDepositsRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUnclaimedDepositsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUnclaimedDepositsRequest {
        return
            ListUnclaimedDepositsRequest()
    }

    public static func write(_ value: ListUnclaimedDepositsRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsRequest_lift(_ buf: RustBuffer) throws -> ListUnclaimedDepositsRequest {
    return try FfiConverterTypeListUnclaimedDepositsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsRequest_lower(_ value: ListUnclaimedDepositsRequest) -> RustBuffer {
    return FfiConverterTypeListUnclaimedDepositsRequest.lower(value)
}


public struct ListUnclaimedDepositsResponse {
    public var deposits: [DepositInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deposits: [DepositInfo]) {
        self.deposits = deposits
    }
}



extension ListUnclaimedDepositsResponse: Equatable, Hashable {
    public static func ==(lhs: ListUnclaimedDepositsResponse, rhs: ListUnclaimedDepositsResponse) -> Bool {
        if lhs.deposits != rhs.deposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deposits)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUnclaimedDepositsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUnclaimedDepositsResponse {
        return
            try ListUnclaimedDepositsResponse(
                deposits: FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ListUnclaimedDepositsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeDepositInfo.write(value.deposits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsResponse_lift(_ buf: RustBuffer) throws -> ListUnclaimedDepositsResponse {
    return try FfiConverterTypeListUnclaimedDepositsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsResponse_lower(_ value: ListUnclaimedDepositsResponse) -> RustBuffer {
    return FfiConverterTypeListUnclaimedDepositsResponse.lower(value)
}


/**
 * Wrapped in a [`InputType::LnurlAuth`], this is the result of [`parse`](breez_sdk_common::input::parse) when given a LNURL-auth endpoint.
 *
 * It represents the endpoint's parameters for the LNURL workflow.
 *
 * See <https://github.com/lnurl/luds/blob/luds/04.md>
 */
public struct LnurlAuthRequestDetails {
    /**
     * Hex encoded 32 bytes of challenge
     */
    public var k1: String
    /**
     * When available, one of: register, login, link, auth
     */
    public var action: String?
    /**
     * Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
     * auth confirmation, as per LUD-04 spec.
     */
    public var domain: String
    /**
     * Indicates the URL of the LNURL-auth service, including the query arguments. This will be
     * extended with the signed challenge and the linking key, then called in the second step of the workflow.
     */
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex encoded 32 bytes of challenge
         */k1: String, 
        /**
         * When available, one of: register, login, link, auth
         */action: String?, 
        /**
         * Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
         * auth confirmation, as per LUD-04 spec.
         */domain: String, 
        /**
         * Indicates the URL of the LNURL-auth service, including the query arguments. This will be
         * extended with the signed challenge and the linking key, then called in the second step of the workflow.
         */url: String) {
        self.k1 = k1
        self.action = action
        self.domain = domain
        self.url = url
    }
}



extension LnurlAuthRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlAuthRequestDetails, rhs: LnurlAuthRequestDetails) -> Bool {
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(k1)
        hasher.combine(action)
        hasher.combine(domain)
        hasher.combine(url)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlAuthRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlAuthRequestDetails {
        return
            try LnurlAuthRequestDetails(
                k1: FfiConverterString.read(from: &buf), 
                action: FfiConverterOptionString.read(from: &buf), 
                domain: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlAuthRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterOptionString.write(value.action, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlAuthRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlAuthRequestDetails {
    return try FfiConverterTypeLnurlAuthRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlAuthRequestDetails_lower(_ value: LnurlAuthRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlAuthRequestDetails.lower(value)
}


/**
 * Represents the payment LNURL info
 */
public struct LnurlPayInfo {
    public var lnAddress: String?
    public var comment: String?
    public var domain: String?
    public var metadata: String?
    public var processedSuccessAction: SuccessActionProcessed?
    public var rawSuccessAction: SuccessAction?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lnAddress: String?, comment: String?, domain: String?, metadata: String?, processedSuccessAction: SuccessActionProcessed?, rawSuccessAction: SuccessAction?) {
        self.lnAddress = lnAddress
        self.comment = comment
        self.domain = domain
        self.metadata = metadata
        self.processedSuccessAction = processedSuccessAction
        self.rawSuccessAction = rawSuccessAction
    }
}



extension LnurlPayInfo: Equatable, Hashable {
    public static func ==(lhs: LnurlPayInfo, rhs: LnurlPayInfo) -> Bool {
        if lhs.lnAddress != rhs.lnAddress {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.processedSuccessAction != rhs.processedSuccessAction {
            return false
        }
        if lhs.rawSuccessAction != rhs.rawSuccessAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lnAddress)
        hasher.combine(comment)
        hasher.combine(domain)
        hasher.combine(metadata)
        hasher.combine(processedSuccessAction)
        hasher.combine(rawSuccessAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayInfo {
        return
            try LnurlPayInfo(
                lnAddress: FfiConverterOptionString.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                domain: FfiConverterOptionString.read(from: &buf), 
                metadata: FfiConverterOptionString.read(from: &buf), 
                processedSuccessAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf), 
                rawSuccessAction: FfiConverterOptionTypeSuccessAction.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.lnAddress, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterOptionString.write(value.domain, into: &buf)
        FfiConverterOptionString.write(value.metadata, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.processedSuccessAction, into: &buf)
        FfiConverterOptionTypeSuccessAction.write(value.rawSuccessAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayInfo_lift(_ buf: RustBuffer) throws -> LnurlPayInfo {
    return try FfiConverterTypeLnurlPayInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayInfo_lower(_ value: LnurlPayInfo) -> RustBuffer {
    return FfiConverterTypeLnurlPayInfo.lower(value)
}


public struct LnurlPayRequest {
    public var prepareResponse: PrepareLnurlPayResponse
    /**
     * If set, providing the same idempotency key for multiple requests will ensure that only one
     * payment is made. If an idempotency key is re-used, the same payment will be returned.
     * The idempotency key must be a valid UUID.
     */
    public var idempotencyKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prepareResponse: PrepareLnurlPayResponse, 
        /**
         * If set, providing the same idempotency key for multiple requests will ensure that only one
         * payment is made. If an idempotency key is re-used, the same payment will be returned.
         * The idempotency key must be a valid UUID.
         */idempotencyKey: String? = nil) {
        self.prepareResponse = prepareResponse
        self.idempotencyKey = idempotencyKey
    }
}



extension LnurlPayRequest: Equatable, Hashable {
    public static func ==(lhs: LnurlPayRequest, rhs: LnurlPayRequest) -> Bool {
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        if lhs.idempotencyKey != rhs.idempotencyKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prepareResponse)
        hasher.combine(idempotencyKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayRequest {
        return
            try LnurlPayRequest(
                prepareResponse: FfiConverterTypePrepareLnurlPayResponse.read(from: &buf), 
                idempotencyKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayRequest, into buf: inout [UInt8]) {
        FfiConverterTypePrepareLnurlPayResponse.write(value.prepareResponse, into: &buf)
        FfiConverterOptionString.write(value.idempotencyKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequest_lift(_ buf: RustBuffer) throws -> LnurlPayRequest {
    return try FfiConverterTypeLnurlPayRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequest_lower(_ value: LnurlPayRequest) -> RustBuffer {
    return FfiConverterTypeLnurlPayRequest.lower(value)
}


public struct LnurlPayRequestDetails {
    public var callback: String
    /**
     * The minimum amount, in millisats, that this LNURL-pay endpoint accepts
     */
    public var minSendable: UInt64
    /**
     * The maximum amount, in millisats, that this LNURL-pay endpoint accepts
     */
    public var maxSendable: UInt64
    /**
     * As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
     * Use `metadata_vec()` to get the parsed items.
     */
    public var metadataStr: String
    /**
     * The comment length accepted by this endpoint
     *
     * See <https://github.com/lnurl/luds/blob/luds/12.md>
     */
    public var commentAllowed: UInt16
    /**
     * Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
     * payment input, as per LUD-06 spec.
     *
     * Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
     */
    public var domain: String
    public var url: String
    /**
     * Optional lightning address if that was used to resolve the lnurl.
     */
    public var address: String?
    /**
     * Value indicating whether the recipient supports Nostr Zaps through NIP-57.
     *
     * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
     */
    public var allowsNostr: Bool?
    /**
     * Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
     * valid BIP 340 public key in hex.
     *
     * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
     * See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
     */
    public var nostrPubkey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, 
        /**
         * The minimum amount, in millisats, that this LNURL-pay endpoint accepts
         */minSendable: UInt64, 
        /**
         * The maximum amount, in millisats, that this LNURL-pay endpoint accepts
         */maxSendable: UInt64, 
        /**
         * As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
         * Use `metadata_vec()` to get the parsed items.
         */metadataStr: String, 
        /**
         * The comment length accepted by this endpoint
         *
         * See <https://github.com/lnurl/luds/blob/luds/12.md>
         */commentAllowed: UInt16, 
        /**
         * Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
         * payment input, as per LUD-06 spec.
         *
         * Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
         */domain: String, url: String, 
        /**
         * Optional lightning address if that was used to resolve the lnurl.
         */address: String?, 
        /**
         * Value indicating whether the recipient supports Nostr Zaps through NIP-57.
         *
         * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
         */allowsNostr: Bool?, 
        /**
         * Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
         * valid BIP 340 public key in hex.
         *
         * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
         * See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
         */nostrPubkey: String?) {
        self.callback = callback
        self.minSendable = minSendable
        self.maxSendable = maxSendable
        self.metadataStr = metadataStr
        self.commentAllowed = commentAllowed
        self.domain = domain
        self.url = url
        self.address = address
        self.allowsNostr = allowsNostr
        self.nostrPubkey = nostrPubkey
    }
}



extension LnurlPayRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlPayRequestDetails, rhs: LnurlPayRequestDetails) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.minSendable != rhs.minSendable {
            return false
        }
        if lhs.maxSendable != rhs.maxSendable {
            return false
        }
        if lhs.metadataStr != rhs.metadataStr {
            return false
        }
        if lhs.commentAllowed != rhs.commentAllowed {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.allowsNostr != rhs.allowsNostr {
            return false
        }
        if lhs.nostrPubkey != rhs.nostrPubkey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(minSendable)
        hasher.combine(maxSendable)
        hasher.combine(metadataStr)
        hasher.combine(commentAllowed)
        hasher.combine(domain)
        hasher.combine(url)
        hasher.combine(address)
        hasher.combine(allowsNostr)
        hasher.combine(nostrPubkey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayRequestDetails {
        return
            try LnurlPayRequestDetails(
                callback: FfiConverterString.read(from: &buf), 
                minSendable: FfiConverterUInt64.read(from: &buf), 
                maxSendable: FfiConverterUInt64.read(from: &buf), 
                metadataStr: FfiConverterString.read(from: &buf), 
                commentAllowed: FfiConverterUInt16.read(from: &buf), 
                domain: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                address: FfiConverterOptionString.read(from: &buf), 
                allowsNostr: FfiConverterOptionBool.read(from: &buf), 
                nostrPubkey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterUInt64.write(value.minSendable, into: &buf)
        FfiConverterUInt64.write(value.maxSendable, into: &buf)
        FfiConverterString.write(value.metadataStr, into: &buf)
        FfiConverterUInt16.write(value.commentAllowed, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.address, into: &buf)
        FfiConverterOptionBool.write(value.allowsNostr, into: &buf)
        FfiConverterOptionString.write(value.nostrPubkey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlPayRequestDetails {
    return try FfiConverterTypeLnurlPayRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequestDetails_lower(_ value: LnurlPayRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlPayRequestDetails.lower(value)
}


public struct LnurlPayResponse {
    public var payment: Payment
    public var successAction: SuccessActionProcessed?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment, successAction: SuccessActionProcessed?) {
        self.payment = payment
        self.successAction = successAction
    }
}



extension LnurlPayResponse: Equatable, Hashable {
    public static func ==(lhs: LnurlPayResponse, rhs: LnurlPayResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        if lhs.successAction != rhs.successAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
        hasher.combine(successAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayResponse {
        return
            try LnurlPayResponse(
                payment: FfiConverterTypePayment.read(from: &buf), 
                successAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.successAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayResponse_lift(_ buf: RustBuffer) throws -> LnurlPayResponse {
    return try FfiConverterTypeLnurlPayResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayResponse_lower(_ value: LnurlPayResponse) -> RustBuffer {
    return FfiConverterTypeLnurlPayResponse.lower(value)
}


public struct LnurlReceiveMetadata {
    public var nostrZapRequest: String?
    public var nostrZapReceipt: String?
    public var senderComment: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nostrZapRequest: String?, nostrZapReceipt: String?, senderComment: String?) {
        self.nostrZapRequest = nostrZapRequest
        self.nostrZapReceipt = nostrZapReceipt
        self.senderComment = senderComment
    }
}



extension LnurlReceiveMetadata: Equatable, Hashable {
    public static func ==(lhs: LnurlReceiveMetadata, rhs: LnurlReceiveMetadata) -> Bool {
        if lhs.nostrZapRequest != rhs.nostrZapRequest {
            return false
        }
        if lhs.nostrZapReceipt != rhs.nostrZapReceipt {
            return false
        }
        if lhs.senderComment != rhs.senderComment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nostrZapRequest)
        hasher.combine(nostrZapReceipt)
        hasher.combine(senderComment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlReceiveMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlReceiveMetadata {
        return
            try LnurlReceiveMetadata(
                nostrZapRequest: FfiConverterOptionString.read(from: &buf), 
                nostrZapReceipt: FfiConverterOptionString.read(from: &buf), 
                senderComment: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlReceiveMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.nostrZapRequest, into: &buf)
        FfiConverterOptionString.write(value.nostrZapReceipt, into: &buf)
        FfiConverterOptionString.write(value.senderComment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlReceiveMetadata_lift(_ buf: RustBuffer) throws -> LnurlReceiveMetadata {
    return try FfiConverterTypeLnurlReceiveMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlReceiveMetadata_lower(_ value: LnurlReceiveMetadata) -> RustBuffer {
    return FfiConverterTypeLnurlReceiveMetadata.lower(value)
}


/**
 * Represents the withdraw LNURL info
 */
public struct LnurlWithdrawInfo {
    public var withdrawUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(withdrawUrl: String) {
        self.withdrawUrl = withdrawUrl
    }
}



extension LnurlWithdrawInfo: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawInfo, rhs: LnurlWithdrawInfo) -> Bool {
        if lhs.withdrawUrl != rhs.withdrawUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(withdrawUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawInfo {
        return
            try LnurlWithdrawInfo(
                withdrawUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.withdrawUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawInfo_lift(_ buf: RustBuffer) throws -> LnurlWithdrawInfo {
    return try FfiConverterTypeLnurlWithdrawInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawInfo_lower(_ value: LnurlWithdrawInfo) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawInfo.lower(value)
}


public struct LnurlWithdrawRequest {
    /**
     * The amount to withdraw in satoshis
     * Must be within the min and max withdrawable limits
     */
    public var amountSats: UInt64
    public var withdrawRequest: LnurlWithdrawRequestDetails
    /**
     * If set, the function will return the payment if it is still pending after this
     * number of seconds. If unset, the function will return immediately after
     * initiating the LNURL withdraw.
     */
    public var completionTimeoutSecs: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The amount to withdraw in satoshis
         * Must be within the min and max withdrawable limits
         */amountSats: UInt64, withdrawRequest: LnurlWithdrawRequestDetails, 
        /**
         * If set, the function will return the payment if it is still pending after this
         * number of seconds. If unset, the function will return immediately after
         * initiating the LNURL withdraw.
         */completionTimeoutSecs: UInt32? = nil) {
        self.amountSats = amountSats
        self.withdrawRequest = withdrawRequest
        self.completionTimeoutSecs = completionTimeoutSecs
    }
}



extension LnurlWithdrawRequest: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawRequest, rhs: LnurlWithdrawRequest) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.withdrawRequest != rhs.withdrawRequest {
            return false
        }
        if lhs.completionTimeoutSecs != rhs.completionTimeoutSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(withdrawRequest)
        hasher.combine(completionTimeoutSecs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawRequest {
        return
            try LnurlWithdrawRequest(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                withdrawRequest: FfiConverterTypeLnurlWithdrawRequestDetails.read(from: &buf), 
                completionTimeoutSecs: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterTypeLnurlWithdrawRequestDetails.write(value.withdrawRequest, into: &buf)
        FfiConverterOptionUInt32.write(value.completionTimeoutSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequest_lift(_ buf: RustBuffer) throws -> LnurlWithdrawRequest {
    return try FfiConverterTypeLnurlWithdrawRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequest_lower(_ value: LnurlWithdrawRequest) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawRequest.lower(value)
}


public struct LnurlWithdrawRequestDetails {
    public var callback: String
    public var k1: String
    public var defaultDescription: String
    /**
     * The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
     */
    public var minWithdrawable: UInt64
    /**
     * The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
     */
    public var maxWithdrawable: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, k1: String, defaultDescription: String, 
        /**
         * The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
         */minWithdrawable: UInt64, 
        /**
         * The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
         */maxWithdrawable: UInt64) {
        self.callback = callback
        self.k1 = k1
        self.defaultDescription = defaultDescription
        self.minWithdrawable = minWithdrawable
        self.maxWithdrawable = maxWithdrawable
    }
}



extension LnurlWithdrawRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawRequestDetails, rhs: LnurlWithdrawRequestDetails) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.defaultDescription != rhs.defaultDescription {
            return false
        }
        if lhs.minWithdrawable != rhs.minWithdrawable {
            return false
        }
        if lhs.maxWithdrawable != rhs.maxWithdrawable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(k1)
        hasher.combine(defaultDescription)
        hasher.combine(minWithdrawable)
        hasher.combine(maxWithdrawable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawRequestDetails {
        return
            try LnurlWithdrawRequestDetails(
                callback: FfiConverterString.read(from: &buf), 
                k1: FfiConverterString.read(from: &buf), 
                defaultDescription: FfiConverterString.read(from: &buf), 
                minWithdrawable: FfiConverterUInt64.read(from: &buf), 
                maxWithdrawable: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterString.write(value.defaultDescription, into: &buf)
        FfiConverterUInt64.write(value.minWithdrawable, into: &buf)
        FfiConverterUInt64.write(value.maxWithdrawable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlWithdrawRequestDetails {
    return try FfiConverterTypeLnurlWithdrawRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequestDetails_lower(_ value: LnurlWithdrawRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawRequestDetails.lower(value)
}


public struct LnurlWithdrawResponse {
    /**
     * The Lightning invoice generated for the LNURL withdraw
     */
    public var paymentRequest: String
    public var payment: Payment?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The Lightning invoice generated for the LNURL withdraw
         */paymentRequest: String, payment: Payment?) {
        self.paymentRequest = paymentRequest
        self.payment = payment
    }
}



extension LnurlWithdrawResponse: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawResponse, rhs: LnurlWithdrawResponse) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawResponse {
        return
            try LnurlWithdrawResponse(
                paymentRequest: FfiConverterString.read(from: &buf), 
                payment: FfiConverterOptionTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterOptionTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawResponse_lift(_ buf: RustBuffer) throws -> LnurlWithdrawResponse {
    return try FfiConverterTypeLnurlWithdrawResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawResponse_lower(_ value: LnurlWithdrawResponse) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawResponse.lower(value)
}


/**
 * Locale-specific settings for the representation of a currency
 */
public struct LocaleOverrides {
    public var locale: String
    public var spacing: UInt32?
    public var symbol: Symbol

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locale: String, spacing: UInt32?, symbol: Symbol) {
        self.locale = locale
        self.spacing = spacing
        self.symbol = symbol
    }
}



extension LocaleOverrides: Equatable, Hashable {
    public static func ==(lhs: LocaleOverrides, rhs: LocaleOverrides) -> Bool {
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.spacing != rhs.spacing {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locale)
        hasher.combine(spacing)
        hasher.combine(symbol)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocaleOverrides: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleOverrides {
        return
            try LocaleOverrides(
                locale: FfiConverterString.read(from: &buf), 
                spacing: FfiConverterOptionUInt32.read(from: &buf), 
                symbol: FfiConverterTypeSymbol.read(from: &buf)
        )
    }

    public static func write(_ value: LocaleOverrides, into buf: inout [UInt8]) {
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterOptionUInt32.write(value.spacing, into: &buf)
        FfiConverterTypeSymbol.write(value.symbol, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocaleOverrides_lift(_ buf: RustBuffer) throws -> LocaleOverrides {
    return try FfiConverterTypeLocaleOverrides.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocaleOverrides_lower(_ value: LocaleOverrides) -> RustBuffer {
    return FfiConverterTypeLocaleOverrides.lower(value)
}


/**
 * Localized name of a currency
 */
public struct LocalizedName {
    public var locale: String
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locale: String, name: String) {
        self.locale = locale
        self.name = name
    }
}



extension LocalizedName: Equatable, Hashable {
    public static func ==(lhs: LocalizedName, rhs: LocalizedName) -> Bool {
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locale)
        hasher.combine(name)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalizedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalizedName {
        return
            try LocalizedName(
                locale: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LocalizedName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalizedName_lift(_ buf: RustBuffer) throws -> LocalizedName {
    return try FfiConverterTypeLocalizedName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalizedName_lower(_ value: LocalizedName) -> RustBuffer {
    return FfiConverterTypeLocalizedName.lower(value)
}


public struct LogEntry {
    public var line: String
    public var level: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(line: String, level: String) {
        self.line = line
        self.level = level
    }
}



extension LogEntry: Equatable, Hashable {
    public static func ==(lhs: LogEntry, rhs: LogEntry) -> Bool {
        if lhs.line != rhs.line {
            return false
        }
        if lhs.level != rhs.level {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(line)
        hasher.combine(level)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogEntry {
        return
            try LogEntry(
                line: FfiConverterString.read(from: &buf), 
                level: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LogEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.line, into: &buf)
        FfiConverterString.write(value.level, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogEntry_lift(_ buf: RustBuffer) throws -> LogEntry {
    return try FfiConverterTypeLogEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogEntry_lower(_ value: LogEntry) -> RustBuffer {
    return FfiConverterTypeLogEntry.lower(value)
}


public struct MessageSuccessActionData {
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String) {
        self.message = message
    }
}



extension MessageSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: MessageSuccessActionData, rhs: MessageSuccessActionData) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageSuccessActionData {
        return
            try MessageSuccessActionData(
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageSuccessActionData_lift(_ buf: RustBuffer) throws -> MessageSuccessActionData {
    return try FfiConverterTypeMessageSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageSuccessActionData_lower(_ value: MessageSuccessActionData) -> RustBuffer {
    return FfiConverterTypeMessageSuccessActionData.lower(value)
}


public struct MintIssuerTokenRequest {
    public var amount: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: U128) {
        self.amount = amount
    }
}



extension MintIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: MintIssuerTokenRequest, rhs: MintIssuerTokenRequest) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMintIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MintIssuerTokenRequest {
        return
            try MintIssuerTokenRequest(
                amount: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: MintIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterTypeu128.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMintIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> MintIssuerTokenRequest {
    return try FfiConverterTypeMintIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMintIssuerTokenRequest_lower(_ value: MintIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeMintIssuerTokenRequest.lower(value)
}


public struct OutgoingChange {
    public var change: RecordChange
    public var parent: Record?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(change: RecordChange, parent: Record?) {
        self.change = change
        self.parent = parent
    }
}



extension OutgoingChange: Equatable, Hashable {
    public static func ==(lhs: OutgoingChange, rhs: OutgoingChange) -> Bool {
        if lhs.change != rhs.change {
            return false
        }
        if lhs.parent != rhs.parent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(change)
        hasher.combine(parent)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutgoingChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutgoingChange {
        return
            try OutgoingChange(
                change: FfiConverterTypeRecordChange.read(from: &buf), 
                parent: FfiConverterOptionTypeRecord.read(from: &buf)
        )
    }

    public static func write(_ value: OutgoingChange, into buf: inout [UInt8]) {
        FfiConverterTypeRecordChange.write(value.change, into: &buf)
        FfiConverterOptionTypeRecord.write(value.parent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutgoingChange_lift(_ buf: RustBuffer) throws -> OutgoingChange {
    return try FfiConverterTypeOutgoingChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutgoingChange_lower(_ value: OutgoingChange) -> RustBuffer {
    return FfiConverterTypeOutgoingChange.lower(value)
}


/**
 * Represents a payment (sent or received)
 */
public struct Payment {
    /**
     * Unique identifier for the payment
     */
    public var id: String
    /**
     * Type of payment (send or receive)
     */
    public var paymentType: PaymentType
    /**
     * Status of the payment
     */
    public var status: PaymentStatus
    /**
     * Amount in satoshis or token base units
     */
    public var amount: U128
    /**
     * Fee paid in satoshis or token base units
     */
    public var fees: U128
    /**
     * Timestamp of when the payment was created
     */
    public var timestamp: UInt64
    /**
     * Method of payment. Sometimes the payment details is empty so this field
     * is used to determine the payment method.
     */
    public var method: PaymentMethod
    /**
     * Details of the payment
     */
    public var details: PaymentDetails?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for the payment
         */id: String, 
        /**
         * Type of payment (send or receive)
         */paymentType: PaymentType, 
        /**
         * Status of the payment
         */status: PaymentStatus, 
        /**
         * Amount in satoshis or token base units
         */amount: U128, 
        /**
         * Fee paid in satoshis or token base units
         */fees: U128, 
        /**
         * Timestamp of when the payment was created
         */timestamp: UInt64, 
        /**
         * Method of payment. Sometimes the payment details is empty so this field
         * is used to determine the payment method.
         */method: PaymentMethod, 
        /**
         * Details of the payment
         */details: PaymentDetails?) {
        self.id = id
        self.paymentType = paymentType
        self.status = status
        self.amount = amount
        self.fees = fees
        self.timestamp = timestamp
        self.method = method
        self.details = details
    }
}



extension Payment: Equatable, Hashable {
    public static func ==(lhs: Payment, rhs: Payment) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.paymentType != rhs.paymentType {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(paymentType)
        hasher.combine(status)
        hasher.combine(amount)
        hasher.combine(fees)
        hasher.combine(timestamp)
        hasher.combine(method)
        hasher.combine(details)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return
            try Payment(
                id: FfiConverterString.read(from: &buf), 
                paymentType: FfiConverterTypePaymentType.read(from: &buf), 
                status: FfiConverterTypePaymentStatus.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                fees: FfiConverterTypeu128.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                method: FfiConverterTypePaymentMethod.read(from: &buf), 
                details: FfiConverterOptionTypePaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypePaymentType.write(value.paymentType, into: &buf)
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterTypeu128.write(value.fees, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterTypePaymentMethod.write(value.method, into: &buf)
        FfiConverterOptionTypePaymentDetails.write(value.details, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayment_lift(_ buf: RustBuffer) throws -> Payment {
    return try FfiConverterTypePayment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayment_lower(_ value: Payment) -> RustBuffer {
    return FfiConverterTypePayment.lower(value)
}


/**
 * Metadata associated with a payment that cannot be extracted from the Spark operator.
 */
public struct PaymentMetadata {
    public var lnurlPayInfo: LnurlPayInfo?
    public var lnurlWithdrawInfo: LnurlWithdrawInfo?
    public var lnurlDescription: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lnurlPayInfo: LnurlPayInfo?, lnurlWithdrawInfo: LnurlWithdrawInfo?, lnurlDescription: String?) {
        self.lnurlPayInfo = lnurlPayInfo
        self.lnurlWithdrawInfo = lnurlWithdrawInfo
        self.lnurlDescription = lnurlDescription
    }
}



extension PaymentMetadata: Equatable, Hashable {
    public static func ==(lhs: PaymentMetadata, rhs: PaymentMetadata) -> Bool {
        if lhs.lnurlPayInfo != rhs.lnurlPayInfo {
            return false
        }
        if lhs.lnurlWithdrawInfo != rhs.lnurlWithdrawInfo {
            return false
        }
        if lhs.lnurlDescription != rhs.lnurlDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lnurlPayInfo)
        hasher.combine(lnurlWithdrawInfo)
        hasher.combine(lnurlDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMetadata {
        return
            try PaymentMetadata(
                lnurlPayInfo: FfiConverterOptionTypeLnurlPayInfo.read(from: &buf), 
                lnurlWithdrawInfo: FfiConverterOptionTypeLnurlWithdrawInfo.read(from: &buf), 
                lnurlDescription: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionTypeLnurlPayInfo.write(value.lnurlPayInfo, into: &buf)
        FfiConverterOptionTypeLnurlWithdrawInfo.write(value.lnurlWithdrawInfo, into: &buf)
        FfiConverterOptionString.write(value.lnurlDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lift(_ buf: RustBuffer) throws -> PaymentMetadata {
    return try FfiConverterTypePaymentMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lower(_ value: PaymentMetadata) -> RustBuffer {
    return FfiConverterTypePaymentMetadata.lower(value)
}


public struct PaymentRequestSource {
    public var bip21Uri: String?
    public var bip353Address: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bip21Uri: String?, bip353Address: String?) {
        self.bip21Uri = bip21Uri
        self.bip353Address = bip353Address
    }
}



extension PaymentRequestSource: Equatable, Hashable {
    public static func ==(lhs: PaymentRequestSource, rhs: PaymentRequestSource) -> Bool {
        if lhs.bip21Uri != rhs.bip21Uri {
            return false
        }
        if lhs.bip353Address != rhs.bip353Address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bip21Uri)
        hasher.combine(bip353Address)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentRequestSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentRequestSource {
        return
            try PaymentRequestSource(
                bip21Uri: FfiConverterOptionString.read(from: &buf), 
                bip353Address: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentRequestSource, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.bip21Uri, into: &buf)
        FfiConverterOptionString.write(value.bip353Address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentRequestSource_lift(_ buf: RustBuffer) throws -> PaymentRequestSource {
    return try FfiConverterTypePaymentRequestSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentRequestSource_lower(_ value: PaymentRequestSource) -> RustBuffer {
    return FfiConverterTypePaymentRequestSource.lower(value)
}


public struct PrepareLnurlPayRequest {
    public var amountSats: UInt64
    public var payRequest: LnurlPayRequestDetails
    public var comment: String?
    public var validateSuccessActionUrl: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSats: UInt64, payRequest: LnurlPayRequestDetails, comment: String? = nil, validateSuccessActionUrl: Bool? = nil) {
        self.amountSats = amountSats
        self.payRequest = payRequest
        self.comment = comment
        self.validateSuccessActionUrl = validateSuccessActionUrl
    }
}



extension PrepareLnurlPayRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareLnurlPayRequest, rhs: PrepareLnurlPayRequest) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.validateSuccessActionUrl != rhs.validateSuccessActionUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(payRequest)
        hasher.combine(comment)
        hasher.combine(validateSuccessActionUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareLnurlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareLnurlPayRequest {
        return
            try PrepareLnurlPayRequest(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                validateSuccessActionUrl: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareLnurlPayRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterOptionBool.write(value.validateSuccessActionUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayRequest_lift(_ buf: RustBuffer) throws -> PrepareLnurlPayRequest {
    return try FfiConverterTypePrepareLnurlPayRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayRequest_lower(_ value: PrepareLnurlPayRequest) -> RustBuffer {
    return FfiConverterTypePrepareLnurlPayRequest.lower(value)
}


public struct PrepareLnurlPayResponse {
    public var amountSats: UInt64
    public var comment: String?
    public var payRequest: LnurlPayRequestDetails
    public var feeSats: UInt64
    public var invoiceDetails: Bolt11InvoiceDetails
    public var successAction: SuccessAction?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSats: UInt64, comment: String?, payRequest: LnurlPayRequestDetails, feeSats: UInt64, invoiceDetails: Bolt11InvoiceDetails, successAction: SuccessAction?) {
        self.amountSats = amountSats
        self.comment = comment
        self.payRequest = payRequest
        self.feeSats = feeSats
        self.invoiceDetails = invoiceDetails
        self.successAction = successAction
    }
}



extension PrepareLnurlPayResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareLnurlPayResponse, rhs: PrepareLnurlPayResponse) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        if lhs.feeSats != rhs.feeSats {
            return false
        }
        if lhs.invoiceDetails != rhs.invoiceDetails {
            return false
        }
        if lhs.successAction != rhs.successAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(comment)
        hasher.combine(payRequest)
        hasher.combine(feeSats)
        hasher.combine(invoiceDetails)
        hasher.combine(successAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareLnurlPayResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareLnurlPayResponse {
        return
            try PrepareLnurlPayResponse(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf), 
                feeSats: FfiConverterUInt64.read(from: &buf), 
                invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from: &buf), 
                successAction: FfiConverterOptionTypeSuccessAction.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareLnurlPayResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
        FfiConverterUInt64.write(value.feeSats, into: &buf)
        FfiConverterTypeBolt11InvoiceDetails.write(value.invoiceDetails, into: &buf)
        FfiConverterOptionTypeSuccessAction.write(value.successAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayResponse_lift(_ buf: RustBuffer) throws -> PrepareLnurlPayResponse {
    return try FfiConverterTypePrepareLnurlPayResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayResponse_lower(_ value: PrepareLnurlPayResponse) -> RustBuffer {
    return FfiConverterTypePrepareLnurlPayResponse.lower(value)
}


public struct PrepareSendPaymentRequest {
    public var paymentRequest: String
    /**
     * Amount to send. By default is denominated in sats.
     * If a token identifier is provided, the amount will be denominated in the token base units.
     */
    public var amount: U128?
    /**
     * If provided, the payment will be for a token
     * May only be provided if the payment request is a spark address
     */
    public var tokenIdentifier: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentRequest: String, 
        /**
         * Amount to send. By default is denominated in sats.
         * If a token identifier is provided, the amount will be denominated in the token base units.
         */amount: U128? = nil, 
        /**
         * If provided, the payment will be for a token
         * May only be provided if the payment request is a spark address
         */tokenIdentifier: String? = nil) {
        self.paymentRequest = paymentRequest
        self.amount = amount
        self.tokenIdentifier = tokenIdentifier
    }
}



extension PrepareSendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareSendPaymentRequest, rhs: PrepareSendPaymentRequest) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(amount)
        hasher.combine(tokenIdentifier)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSendPaymentRequest {
        return
            try PrepareSendPaymentRequest(
                paymentRequest: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionTypeu128.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterOptionTypeu128.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentRequest_lift(_ buf: RustBuffer) throws -> PrepareSendPaymentRequest {
    return try FfiConverterTypePrepareSendPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentRequest_lower(_ value: PrepareSendPaymentRequest) -> RustBuffer {
    return FfiConverterTypePrepareSendPaymentRequest.lower(value)
}


public struct PrepareSendPaymentResponse {
    public var paymentMethod: SendPaymentMethod
    /**
     * Amount to send. By default is denominated in sats.
     * If a token identifier is provided, the amount will be denominated in the token base units.
     */
    public var amount: U128
    /**
     * The presence of this field indicates that the payment is for a token
     * If empty, it is a Bitcoin payment
     */
    public var tokenIdentifier: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentMethod: SendPaymentMethod, 
        /**
         * Amount to send. By default is denominated in sats.
         * If a token identifier is provided, the amount will be denominated in the token base units.
         */amount: U128, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?) {
        self.paymentMethod = paymentMethod
        self.amount = amount
        self.tokenIdentifier = tokenIdentifier
    }
}



extension PrepareSendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareSendPaymentResponse, rhs: PrepareSendPaymentResponse) -> Bool {
        if lhs.paymentMethod != rhs.paymentMethod {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentMethod)
        hasher.combine(amount)
        hasher.combine(tokenIdentifier)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSendPaymentResponse {
        return
            try PrepareSendPaymentResponse(
                paymentMethod: FfiConverterTypeSendPaymentMethod.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypeSendPaymentMethod.write(value.paymentMethod, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentResponse_lift(_ buf: RustBuffer) throws -> PrepareSendPaymentResponse {
    return try FfiConverterTypePrepareSendPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentResponse_lower(_ value: PrepareSendPaymentResponse) -> RustBuffer {
    return FfiConverterTypePrepareSendPaymentResponse.lower(value)
}


public struct ProvisionalPayment {
    /**
     * Unique identifier for the payment
     */
    public var paymentId: String
    /**
     * Amount in satoshis or token base units
     */
    public var amount: U128
    /**
     * Details of the payment
     */
    public var details: ProvisionalPaymentDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for the payment
         */paymentId: String, 
        /**
         * Amount in satoshis or token base units
         */amount: U128, 
        /**
         * Details of the payment
         */details: ProvisionalPaymentDetails) {
        self.paymentId = paymentId
        self.amount = amount
        self.details = details
    }
}



extension ProvisionalPayment: Equatable, Hashable {
    public static func ==(lhs: ProvisionalPayment, rhs: ProvisionalPayment) -> Bool {
        if lhs.paymentId != rhs.paymentId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentId)
        hasher.combine(amount)
        hasher.combine(details)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProvisionalPayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProvisionalPayment {
        return
            try ProvisionalPayment(
                paymentId: FfiConverterString.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                details: FfiConverterTypeProvisionalPaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: ProvisionalPayment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentId, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterTypeProvisionalPaymentDetails.write(value.details, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPayment_lift(_ buf: RustBuffer) throws -> ProvisionalPayment {
    return try FfiConverterTypeProvisionalPayment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPayment_lower(_ value: ProvisionalPayment) -> RustBuffer {
    return FfiConverterTypeProvisionalPayment.lower(value)
}


/**
 * Denominator in an exchange rate
 */
public struct Rate {
    public var coin: String
    public var value: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(coin: String, value: Double) {
        self.coin = coin
        self.value = value
    }
}



extension Rate: Equatable, Hashable {
    public static func ==(lhs: Rate, rhs: Rate) -> Bool {
        if lhs.coin != rhs.coin {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(coin)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rate {
        return
            try Rate(
                coin: FfiConverterString.read(from: &buf), 
                value: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Rate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.coin, into: &buf)
        FfiConverterDouble.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRate_lift(_ buf: RustBuffer) throws -> Rate {
    return try FfiConverterTypeRate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRate_lower(_ value: Rate) -> RustBuffer {
    return FfiConverterTypeRate.lower(value)
}


public struct ReceivePaymentRequest {
    public var paymentMethod: ReceivePaymentMethod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentMethod: ReceivePaymentMethod) {
        self.paymentMethod = paymentMethod
    }
}



extension ReceivePaymentRequest: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentRequest, rhs: ReceivePaymentRequest) -> Bool {
        if lhs.paymentMethod != rhs.paymentMethod {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentMethod)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentRequest {
        return
            try ReceivePaymentRequest(
                paymentMethod: FfiConverterTypeReceivePaymentMethod.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypeReceivePaymentMethod.write(value.paymentMethod, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentRequest_lift(_ buf: RustBuffer) throws -> ReceivePaymentRequest {
    return try FfiConverterTypeReceivePaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentRequest_lower(_ value: ReceivePaymentRequest) -> RustBuffer {
    return FfiConverterTypeReceivePaymentRequest.lower(value)
}


public struct ReceivePaymentResponse {
    public var paymentRequest: String
    /**
     * Fee to pay to receive the payment
     * Denominated in sats or token base units
     */
    public var fee: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentRequest: String, 
        /**
         * Fee to pay to receive the payment
         * Denominated in sats or token base units
         */fee: U128) {
        self.paymentRequest = paymentRequest
        self.fee = fee
    }
}



extension ReceivePaymentResponse: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentResponse, rhs: ReceivePaymentResponse) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(fee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentResponse {
        return
            try ReceivePaymentResponse(
                paymentRequest: FfiConverterString.read(from: &buf), 
                fee: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterTypeu128.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentResponse_lift(_ buf: RustBuffer) throws -> ReceivePaymentResponse {
    return try FfiConverterTypeReceivePaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentResponse_lower(_ value: ReceivePaymentResponse) -> RustBuffer {
    return FfiConverterTypeReceivePaymentResponse.lower(value)
}


public struct RecommendedFees {
    public var fastestFee: UInt64
    public var halfHourFee: UInt64
    public var hourFee: UInt64
    public var economyFee: UInt64
    public var minimumFee: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fastestFee: UInt64, halfHourFee: UInt64, hourFee: UInt64, economyFee: UInt64, minimumFee: UInt64) {
        self.fastestFee = fastestFee
        self.halfHourFee = halfHourFee
        self.hourFee = hourFee
        self.economyFee = economyFee
        self.minimumFee = minimumFee
    }
}



extension RecommendedFees: Equatable, Hashable {
    public static func ==(lhs: RecommendedFees, rhs: RecommendedFees) -> Bool {
        if lhs.fastestFee != rhs.fastestFee {
            return false
        }
        if lhs.halfHourFee != rhs.halfHourFee {
            return false
        }
        if lhs.hourFee != rhs.hourFee {
            return false
        }
        if lhs.economyFee != rhs.economyFee {
            return false
        }
        if lhs.minimumFee != rhs.minimumFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fastestFee)
        hasher.combine(halfHourFee)
        hasher.combine(hourFee)
        hasher.combine(economyFee)
        hasher.combine(minimumFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecommendedFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecommendedFees {
        return
            try RecommendedFees(
                fastestFee: FfiConverterUInt64.read(from: &buf), 
                halfHourFee: FfiConverterUInt64.read(from: &buf), 
                hourFee: FfiConverterUInt64.read(from: &buf), 
                economyFee: FfiConverterUInt64.read(from: &buf), 
                minimumFee: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RecommendedFees, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.fastestFee, into: &buf)
        FfiConverterUInt64.write(value.halfHourFee, into: &buf)
        FfiConverterUInt64.write(value.hourFee, into: &buf)
        FfiConverterUInt64.write(value.economyFee, into: &buf)
        FfiConverterUInt64.write(value.minimumFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecommendedFees_lift(_ buf: RustBuffer) throws -> RecommendedFees {
    return try FfiConverterTypeRecommendedFees.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecommendedFees_lower(_ value: RecommendedFees) -> RustBuffer {
    return FfiConverterTypeRecommendedFees.lower(value)
}


public struct Record {
    public var id: RecordId
    public var revision: UInt64
    public var schemaVersion: String
    public var data: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: RecordId, revision: UInt64, schemaVersion: String, data: [String: String]) {
        self.id = id
        self.revision = revision
        self.schemaVersion = schemaVersion
        self.data = data
    }
}



extension Record: Equatable, Hashable {
    public static func ==(lhs: Record, rhs: Record) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.revision != rhs.revision {
            return false
        }
        if lhs.schemaVersion != rhs.schemaVersion {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(revision)
        hasher.combine(schemaVersion)
        hasher.combine(data)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Record {
        return
            try Record(
                id: FfiConverterTypeRecordId.read(from: &buf), 
                revision: FfiConverterUInt64.read(from: &buf), 
                schemaVersion: FfiConverterString.read(from: &buf), 
                data: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: Record, into buf: inout [UInt8]) {
        FfiConverterTypeRecordId.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.revision, into: &buf)
        FfiConverterString.write(value.schemaVersion, into: &buf)
        FfiConverterDictionaryStringString.write(value.data, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecord_lift(_ buf: RustBuffer) throws -> Record {
    return try FfiConverterTypeRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecord_lower(_ value: Record) -> RustBuffer {
    return FfiConverterTypeRecord.lower(value)
}


public struct RecordChange {
    public var id: RecordId
    public var schemaVersion: String
    public var updatedFields: [String: String]
    public var revision: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: RecordId, schemaVersion: String, updatedFields: [String: String], revision: UInt64) {
        self.id = id
        self.schemaVersion = schemaVersion
        self.updatedFields = updatedFields
        self.revision = revision
    }
}



extension RecordChange: Equatable, Hashable {
    public static func ==(lhs: RecordChange, rhs: RecordChange) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.schemaVersion != rhs.schemaVersion {
            return false
        }
        if lhs.updatedFields != rhs.updatedFields {
            return false
        }
        if lhs.revision != rhs.revision {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(schemaVersion)
        hasher.combine(updatedFields)
        hasher.combine(revision)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecordChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecordChange {
        return
            try RecordChange(
                id: FfiConverterTypeRecordId.read(from: &buf), 
                schemaVersion: FfiConverterString.read(from: &buf), 
                updatedFields: FfiConverterDictionaryStringString.read(from: &buf), 
                revision: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RecordChange, into buf: inout [UInt8]) {
        FfiConverterTypeRecordId.write(value.id, into: &buf)
        FfiConverterString.write(value.schemaVersion, into: &buf)
        FfiConverterDictionaryStringString.write(value.updatedFields, into: &buf)
        FfiConverterUInt64.write(value.revision, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecordChange_lift(_ buf: RustBuffer) throws -> RecordChange {
    return try FfiConverterTypeRecordChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecordChange_lower(_ value: RecordChange) -> RustBuffer {
    return FfiConverterTypeRecordChange.lower(value)
}


public struct RecordId {
    public var type: String
    public var dataId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: String, dataId: String) {
        self.type = type
        self.dataId = dataId
    }
}



extension RecordId: Equatable, Hashable {
    public static func ==(lhs: RecordId, rhs: RecordId) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.dataId != rhs.dataId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(dataId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecordId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecordId {
        return
            try RecordId(
                type: FfiConverterString.read(from: &buf), 
                dataId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RecordId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterString.write(value.dataId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecordId_lift(_ buf: RustBuffer) throws -> RecordId {
    return try FfiConverterTypeRecordId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecordId_lower(_ value: RecordId) -> RustBuffer {
    return FfiConverterTypeRecordId.lower(value)
}


public struct RefundDepositRequest {
    public var txid: String
    public var vout: UInt32
    public var destinationAddress: String
    public var fee: Fee

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, destinationAddress: String, fee: Fee) {
        self.txid = txid
        self.vout = vout
        self.destinationAddress = destinationAddress
        self.fee = fee
    }
}



extension RefundDepositRequest: Equatable, Hashable {
    public static func ==(lhs: RefundDepositRequest, rhs: RefundDepositRequest) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.destinationAddress != rhs.destinationAddress {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(destinationAddress)
        hasher.combine(fee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefundDepositRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundDepositRequest {
        return
            try RefundDepositRequest(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                destinationAddress: FfiConverterString.read(from: &buf), 
                fee: FfiConverterTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: RefundDepositRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterString.write(value.destinationAddress, into: &buf)
        FfiConverterTypeFee.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositRequest_lift(_ buf: RustBuffer) throws -> RefundDepositRequest {
    return try FfiConverterTypeRefundDepositRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositRequest_lower(_ value: RefundDepositRequest) -> RustBuffer {
    return FfiConverterTypeRefundDepositRequest.lower(value)
}


public struct RefundDepositResponse {
    public var txId: String
    public var txHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txId: String, txHex: String) {
        self.txId = txId
        self.txHex = txHex
    }
}



extension RefundDepositResponse: Equatable, Hashable {
    public static func ==(lhs: RefundDepositResponse, rhs: RefundDepositResponse) -> Bool {
        if lhs.txId != rhs.txId {
            return false
        }
        if lhs.txHex != rhs.txHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txId)
        hasher.combine(txHex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefundDepositResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundDepositResponse {
        return
            try RefundDepositResponse(
                txId: FfiConverterString.read(from: &buf), 
                txHex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RefundDepositResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txId, into: &buf)
        FfiConverterString.write(value.txHex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositResponse_lift(_ buf: RustBuffer) throws -> RefundDepositResponse {
    return try FfiConverterTypeRefundDepositResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositResponse_lower(_ value: RefundDepositResponse) -> RustBuffer {
    return FfiConverterTypeRefundDepositResponse.lower(value)
}


public struct RegisterLightningAddressRequest {
    public var username: String
    public var description: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String, description: String? = nil) {
        self.username = username
        self.description = description
    }
}



extension RegisterLightningAddressRequest: Equatable, Hashable {
    public static func ==(lhs: RegisterLightningAddressRequest, rhs: RegisterLightningAddressRequest) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(description)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRegisterLightningAddressRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterLightningAddressRequest {
        return
            try RegisterLightningAddressRequest(
                username: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterLightningAddressRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRegisterLightningAddressRequest_lift(_ buf: RustBuffer) throws -> RegisterLightningAddressRequest {
    return try FfiConverterTypeRegisterLightningAddressRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRegisterLightningAddressRequest_lower(_ value: RegisterLightningAddressRequest) -> RustBuffer {
    return FfiConverterTypeRegisterLightningAddressRequest.lower(value)
}


public struct RestResponse {
    public var status: UInt16
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(status: UInt16, body: String) {
        self.status = status
        self.body = body
    }
}



extension RestResponse: Equatable, Hashable {
    public static func ==(lhs: RestResponse, rhs: RestResponse) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(body)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRestResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RestResponse {
        return
            try RestResponse(
                status: FfiConverterUInt16.read(from: &buf), 
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RestResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.status, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestResponse_lift(_ buf: RustBuffer) throws -> RestResponse {
    return try FfiConverterTypeRestResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestResponse_lower(_ value: RestResponse) -> RustBuffer {
    return FfiConverterTypeRestResponse.lower(value)
}


public struct SendOnchainFeeQuote {
    public var id: String
    public var expiresAt: UInt64
    public var speedFast: SendOnchainSpeedFeeQuote
    public var speedMedium: SendOnchainSpeedFeeQuote
    public var speedSlow: SendOnchainSpeedFeeQuote

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, expiresAt: UInt64, speedFast: SendOnchainSpeedFeeQuote, speedMedium: SendOnchainSpeedFeeQuote, speedSlow: SendOnchainSpeedFeeQuote) {
        self.id = id
        self.expiresAt = expiresAt
        self.speedFast = speedFast
        self.speedMedium = speedMedium
        self.speedSlow = speedSlow
    }
}



extension SendOnchainFeeQuote: Equatable, Hashable {
    public static func ==(lhs: SendOnchainFeeQuote, rhs: SendOnchainFeeQuote) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        if lhs.speedFast != rhs.speedFast {
            return false
        }
        if lhs.speedMedium != rhs.speedMedium {
            return false
        }
        if lhs.speedSlow != rhs.speedSlow {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(expiresAt)
        hasher.combine(speedFast)
        hasher.combine(speedMedium)
        hasher.combine(speedSlow)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendOnchainFeeQuote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainFeeQuote {
        return
            try SendOnchainFeeQuote(
                id: FfiConverterString.read(from: &buf), 
                expiresAt: FfiConverterUInt64.read(from: &buf), 
                speedFast: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf), 
                speedMedium: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf), 
                speedSlow: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainFeeQuote, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.expiresAt, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedFast, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedMedium, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedSlow, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainFeeQuote_lift(_ buf: RustBuffer) throws -> SendOnchainFeeQuote {
    return try FfiConverterTypeSendOnchainFeeQuote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainFeeQuote_lower(_ value: SendOnchainFeeQuote) -> RustBuffer {
    return FfiConverterTypeSendOnchainFeeQuote.lower(value)
}


public struct SendOnchainSpeedFeeQuote {
    public var userFeeSat: UInt64
    public var l1BroadcastFeeSat: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userFeeSat: UInt64, l1BroadcastFeeSat: UInt64) {
        self.userFeeSat = userFeeSat
        self.l1BroadcastFeeSat = l1BroadcastFeeSat
    }
}



extension SendOnchainSpeedFeeQuote: Equatable, Hashable {
    public static func ==(lhs: SendOnchainSpeedFeeQuote, rhs: SendOnchainSpeedFeeQuote) -> Bool {
        if lhs.userFeeSat != rhs.userFeeSat {
            return false
        }
        if lhs.l1BroadcastFeeSat != rhs.l1BroadcastFeeSat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userFeeSat)
        hasher.combine(l1BroadcastFeeSat)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendOnchainSpeedFeeQuote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainSpeedFeeQuote {
        return
            try SendOnchainSpeedFeeQuote(
                userFeeSat: FfiConverterUInt64.read(from: &buf), 
                l1BroadcastFeeSat: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainSpeedFeeQuote, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.userFeeSat, into: &buf)
        FfiConverterUInt64.write(value.l1BroadcastFeeSat, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainSpeedFeeQuote_lift(_ buf: RustBuffer) throws -> SendOnchainSpeedFeeQuote {
    return try FfiConverterTypeSendOnchainSpeedFeeQuote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainSpeedFeeQuote_lower(_ value: SendOnchainSpeedFeeQuote) -> RustBuffer {
    return FfiConverterTypeSendOnchainSpeedFeeQuote.lower(value)
}


public struct SendPaymentRequest {
    public var prepareResponse: PrepareSendPaymentResponse
    public var options: SendPaymentOptions?
    /**
     * The optional idempotency key for all Spark based transfers (excludes token payments).
     * If set, providing the same idempotency key for multiple requests will ensure that only one
     * payment is made. If an idempotency key is re-used, the same payment will be returned.
     * The idempotency key must be a valid UUID.
     */
    public var idempotencyKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prepareResponse: PrepareSendPaymentResponse, options: SendPaymentOptions? = nil, 
        /**
         * The optional idempotency key for all Spark based transfers (excludes token payments).
         * If set, providing the same idempotency key for multiple requests will ensure that only one
         * payment is made. If an idempotency key is re-used, the same payment will be returned.
         * The idempotency key must be a valid UUID.
         */idempotencyKey: String? = nil) {
        self.prepareResponse = prepareResponse
        self.options = options
        self.idempotencyKey = idempotencyKey
    }
}



extension SendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: SendPaymentRequest, rhs: SendPaymentRequest) -> Bool {
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        if lhs.options != rhs.options {
            return false
        }
        if lhs.idempotencyKey != rhs.idempotencyKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prepareResponse)
        hasher.combine(options)
        hasher.combine(idempotencyKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentRequest {
        return
            try SendPaymentRequest(
                prepareResponse: FfiConverterTypePrepareSendPaymentResponse.read(from: &buf), 
                options: FfiConverterOptionTypeSendPaymentOptions.read(from: &buf), 
                idempotencyKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypePrepareSendPaymentResponse.write(value.prepareResponse, into: &buf)
        FfiConverterOptionTypeSendPaymentOptions.write(value.options, into: &buf)
        FfiConverterOptionString.write(value.idempotencyKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentRequest_lift(_ buf: RustBuffer) throws -> SendPaymentRequest {
    return try FfiConverterTypeSendPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentRequest_lower(_ value: SendPaymentRequest) -> RustBuffer {
    return FfiConverterTypeSendPaymentRequest.lower(value)
}


public struct SendPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension SendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: SendPaymentResponse, rhs: SendPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentResponse {
        return
            try SendPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentResponse_lift(_ buf: RustBuffer) throws -> SendPaymentResponse {
    return try FfiConverterTypeSendPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentResponse_lower(_ value: SendPaymentResponse) -> RustBuffer {
    return FfiConverterTypeSendPaymentResponse.lower(value)
}


public struct SetLnurlMetadataItem {
    public var paymentHash: String
    public var senderComment: String?
    public var nostrZapRequest: String?
    public var nostrZapReceipt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentHash: String, senderComment: String?, nostrZapRequest: String?, nostrZapReceipt: String?) {
        self.paymentHash = paymentHash
        self.senderComment = senderComment
        self.nostrZapRequest = nostrZapRequest
        self.nostrZapReceipt = nostrZapReceipt
    }
}



extension SetLnurlMetadataItem: Equatable, Hashable {
    public static func ==(lhs: SetLnurlMetadataItem, rhs: SetLnurlMetadataItem) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.senderComment != rhs.senderComment {
            return false
        }
        if lhs.nostrZapRequest != rhs.nostrZapRequest {
            return false
        }
        if lhs.nostrZapReceipt != rhs.nostrZapReceipt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(senderComment)
        hasher.combine(nostrZapRequest)
        hasher.combine(nostrZapReceipt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSetLnurlMetadataItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetLnurlMetadataItem {
        return
            try SetLnurlMetadataItem(
                paymentHash: FfiConverterString.read(from: &buf), 
                senderComment: FfiConverterOptionString.read(from: &buf), 
                nostrZapRequest: FfiConverterOptionString.read(from: &buf), 
                nostrZapReceipt: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SetLnurlMetadataItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.senderComment, into: &buf)
        FfiConverterOptionString.write(value.nostrZapRequest, into: &buf)
        FfiConverterOptionString.write(value.nostrZapReceipt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetLnurlMetadataItem_lift(_ buf: RustBuffer) throws -> SetLnurlMetadataItem {
    return try FfiConverterTypeSetLnurlMetadataItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetLnurlMetadataItem_lower(_ value: SetLnurlMetadataItem) -> RustBuffer {
    return FfiConverterTypeSetLnurlMetadataItem.lower(value)
}


public struct SignMessageRequest {
    public var message: String
    /**
     * If true, the signature will be encoded in compact format instead of DER format
     */
    public var compact: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String, 
        /**
         * If true, the signature will be encoded in compact format instead of DER format
         */compact: Bool) {
        self.message = message
        self.compact = compact
    }
}



extension SignMessageRequest: Equatable, Hashable {
    public static func ==(lhs: SignMessageRequest, rhs: SignMessageRequest) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.compact != rhs.compact {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(compact)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageRequest {
        return
            try SignMessageRequest(
                message: FfiConverterString.read(from: &buf), 
                compact: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterBool.write(value.compact, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageRequest_lift(_ buf: RustBuffer) throws -> SignMessageRequest {
    return try FfiConverterTypeSignMessageRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageRequest_lower(_ value: SignMessageRequest) -> RustBuffer {
    return FfiConverterTypeSignMessageRequest.lower(value)
}


public struct SignMessageResponse {
    public var pubkey: String
    /**
     * The DER or compact hex encoded signature
     */
    public var signature: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pubkey: String, 
        /**
         * The DER or compact hex encoded signature
         */signature: String) {
        self.pubkey = pubkey
        self.signature = signature
    }
}



extension SignMessageResponse: Equatable, Hashable {
    public static func ==(lhs: SignMessageResponse, rhs: SignMessageResponse) -> Bool {
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pubkey)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignMessageResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageResponse {
        return
            try SignMessageResponse(
                pubkey: FfiConverterString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageResponse_lift(_ buf: RustBuffer) throws -> SignMessageResponse {
    return try FfiConverterTypeSignMessageResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageResponse_lower(_ value: SignMessageResponse) -> RustBuffer {
    return FfiConverterTypeSignMessageResponse.lower(value)
}


public struct SilentPaymentAddressDetails {
    public var address: String
    public var network: BitcoinNetwork
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, network: BitcoinNetwork, source: PaymentRequestSource) {
        self.address = address
        self.network = network
        self.source = source
    }
}



extension SilentPaymentAddressDetails: Equatable, Hashable {
    public static func ==(lhs: SilentPaymentAddressDetails, rhs: SilentPaymentAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(network)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSilentPaymentAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SilentPaymentAddressDetails {
        return
            try SilentPaymentAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: SilentPaymentAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSilentPaymentAddressDetails_lift(_ buf: RustBuffer) throws -> SilentPaymentAddressDetails {
    return try FfiConverterTypeSilentPaymentAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSilentPaymentAddressDetails_lower(_ value: SilentPaymentAddressDetails) -> RustBuffer {
    return FfiConverterTypeSilentPaymentAddressDetails.lower(value)
}


public struct SparkAddressDetails {
    /**
     * The raw address string
     */
    public var address: String
    /**
     * The identity public key of the address owner
     */
    public var identityPublicKey: String
    public var network: BitcoinNetwork
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The raw address string
         */address: String, 
        /**
         * The identity public key of the address owner
         */identityPublicKey: String, network: BitcoinNetwork, source: PaymentRequestSource) {
        self.address = address
        self.identityPublicKey = identityPublicKey
        self.network = network
        self.source = source
    }
}



extension SparkAddressDetails: Equatable, Hashable {
    public static func ==(lhs: SparkAddressDetails, rhs: SparkAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.identityPublicKey != rhs.identityPublicKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(identityPublicKey)
        hasher.combine(network)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkAddressDetails {
        return
            try SparkAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                identityPublicKey: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: SparkAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterString.write(value.identityPublicKey, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddressDetails_lift(_ buf: RustBuffer) throws -> SparkAddressDetails {
    return try FfiConverterTypeSparkAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddressDetails_lower(_ value: SparkAddressDetails) -> RustBuffer {
    return FfiConverterTypeSparkAddressDetails.lower(value)
}


public struct SparkHtlcDetails {
    /**
     * The payment hash of the HTLC
     */
    public var paymentHash: String
    /**
     * The preimage of the HTLC. Empty until receiver has released it.
     */
    public var preimage: String?
    /**
     * The expiry time of the HTLC in seconds since the Unix epoch
     */
    public var expiryTime: UInt64
    /**
     * The HTLC status
     */
    public var status: SparkHtlcStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The payment hash of the HTLC
         */paymentHash: String, 
        /**
         * The preimage of the HTLC. Empty until receiver has released it.
         */preimage: String?, 
        /**
         * The expiry time of the HTLC in seconds since the Unix epoch
         */expiryTime: UInt64, 
        /**
         * The HTLC status
         */status: SparkHtlcStatus) {
        self.paymentHash = paymentHash
        self.preimage = preimage
        self.expiryTime = expiryTime
        self.status = status
    }
}



extension SparkHtlcDetails: Equatable, Hashable {
    public static func ==(lhs: SparkHtlcDetails, rhs: SparkHtlcDetails) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.expiryTime != rhs.expiryTime {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(preimage)
        hasher.combine(expiryTime)
        hasher.combine(status)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkHtlcDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkHtlcDetails {
        return
            try SparkHtlcDetails(
                paymentHash: FfiConverterString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                expiryTime: FfiConverterUInt64.read(from: &buf), 
                status: FfiConverterTypeSparkHtlcStatus.read(from: &buf)
        )
    }

    public static func write(_ value: SparkHtlcDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterUInt64.write(value.expiryTime, into: &buf)
        FfiConverterTypeSparkHtlcStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcDetails_lift(_ buf: RustBuffer) throws -> SparkHtlcDetails {
    return try FfiConverterTypeSparkHtlcDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcDetails_lower(_ value: SparkHtlcDetails) -> RustBuffer {
    return FfiConverterTypeSparkHtlcDetails.lower(value)
}


public struct SparkHtlcOptions {
    /**
     * The payment hash of the HTLC. The receiver will need to provide the associated preimage to claim it.
     */
    public var paymentHash: String
    /**
     * The duration of the HTLC in seconds.
     * After this time, the HTLC will be returned.
     */
    public var expiryDurationSecs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The payment hash of the HTLC. The receiver will need to provide the associated preimage to claim it.
         */paymentHash: String, 
        /**
         * The duration of the HTLC in seconds.
         * After this time, the HTLC will be returned.
         */expiryDurationSecs: UInt64) {
        self.paymentHash = paymentHash
        self.expiryDurationSecs = expiryDurationSecs
    }
}



extension SparkHtlcOptions: Equatable, Hashable {
    public static func ==(lhs: SparkHtlcOptions, rhs: SparkHtlcOptions) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.expiryDurationSecs != rhs.expiryDurationSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(expiryDurationSecs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkHtlcOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkHtlcOptions {
        return
            try SparkHtlcOptions(
                paymentHash: FfiConverterString.read(from: &buf), 
                expiryDurationSecs: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SparkHtlcOptions, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterUInt64.write(value.expiryDurationSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcOptions_lift(_ buf: RustBuffer) throws -> SparkHtlcOptions {
    return try FfiConverterTypeSparkHtlcOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcOptions_lower(_ value: SparkHtlcOptions) -> RustBuffer {
    return FfiConverterTypeSparkHtlcOptions.lower(value)
}


public struct SparkInvoiceDetails {
    /**
     * The raw invoice string
     */
    public var invoice: String
    /**
     * The identity public key of the invoice issuer
     */
    public var identityPublicKey: String
    public var network: BitcoinNetwork
    /**
     * Optional amount denominated in sats if `token_identifier` is absent, otherwise in the token base units
     */
    public var amount: U128?
    /**
     * The token identifier of the token payment. Absence indicates a Bitcoin payment.
     */
    public var tokenIdentifier: String?
    /**
     * Optional expiry time. If not provided, the invoice will never expire.
     */
    public var expiryTime: UInt64?
    /**
     * Optional description.
     */
    public var description: String?
    /**
     * If set, the invoice may only be fulfilled by a payer with this public key.
     */
    public var senderPublicKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The raw invoice string
         */invoice: String, 
        /**
         * The identity public key of the invoice issuer
         */identityPublicKey: String, network: BitcoinNetwork, 
        /**
         * Optional amount denominated in sats if `token_identifier` is absent, otherwise in the token base units
         */amount: U128?, 
        /**
         * The token identifier of the token payment. Absence indicates a Bitcoin payment.
         */tokenIdentifier: String?, 
        /**
         * Optional expiry time. If not provided, the invoice will never expire.
         */expiryTime: UInt64?, 
        /**
         * Optional description.
         */description: String?, 
        /**
         * If set, the invoice may only be fulfilled by a payer with this public key.
         */senderPublicKey: String?) {
        self.invoice = invoice
        self.identityPublicKey = identityPublicKey
        self.network = network
        self.amount = amount
        self.tokenIdentifier = tokenIdentifier
        self.expiryTime = expiryTime
        self.description = description
        self.senderPublicKey = senderPublicKey
    }
}



extension SparkInvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: SparkInvoiceDetails, rhs: SparkInvoiceDetails) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.identityPublicKey != rhs.identityPublicKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        if lhs.expiryTime != rhs.expiryTime {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.senderPublicKey != rhs.senderPublicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(identityPublicKey)
        hasher.combine(network)
        hasher.combine(amount)
        hasher.combine(tokenIdentifier)
        hasher.combine(expiryTime)
        hasher.combine(description)
        hasher.combine(senderPublicKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkInvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkInvoiceDetails {
        return
            try SparkInvoiceDetails(
                invoice: FfiConverterString.read(from: &buf), 
                identityPublicKey: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                amount: FfiConverterOptionTypeu128.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf), 
                expiryTime: FfiConverterOptionUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                senderPublicKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparkInvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterString.write(value.identityPublicKey, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterOptionTypeu128.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
        FfiConverterOptionUInt64.write(value.expiryTime, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.senderPublicKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoiceDetails_lift(_ buf: RustBuffer) throws -> SparkInvoiceDetails {
    return try FfiConverterTypeSparkInvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoiceDetails_lower(_ value: SparkInvoiceDetails) -> RustBuffer {
    return FfiConverterTypeSparkInvoiceDetails.lower(value)
}


public struct SparkInvoicePaymentDetails {
    /**
     * Represents the spark invoice description
     */
    public var description: String?
    /**
     * The raw spark invoice string
     */
    public var invoice: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Represents the spark invoice description
         */description: String?, 
        /**
         * The raw spark invoice string
         */invoice: String) {
        self.description = description
        self.invoice = invoice
    }
}



extension SparkInvoicePaymentDetails: Equatable, Hashable {
    public static func ==(lhs: SparkInvoicePaymentDetails, rhs: SparkInvoicePaymentDetails) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(invoice)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkInvoicePaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkInvoicePaymentDetails {
        return
            try SparkInvoicePaymentDetails(
                description: FfiConverterOptionString.read(from: &buf), 
                invoice: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SparkInvoicePaymentDetails, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterString.write(value.invoice, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoicePaymentDetails_lift(_ buf: RustBuffer) throws -> SparkInvoicePaymentDetails {
    return try FfiConverterTypeSparkInvoicePaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoicePaymentDetails_lower(_ value: SparkInvoicePaymentDetails) -> RustBuffer {
    return FfiConverterTypeSparkInvoicePaymentDetails.lower(value)
}


/**
 * Settings for the symbol representation of a currency
 */
public struct Symbol {
    public var grapheme: String?
    public var template: String?
    public var rtl: Bool?
    public var position: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(grapheme: String?, template: String?, rtl: Bool?, position: UInt32?) {
        self.grapheme = grapheme
        self.template = template
        self.rtl = rtl
        self.position = position
    }
}



extension Symbol: Equatable, Hashable {
    public static func ==(lhs: Symbol, rhs: Symbol) -> Bool {
        if lhs.grapheme != rhs.grapheme {
            return false
        }
        if lhs.template != rhs.template {
            return false
        }
        if lhs.rtl != rhs.rtl {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(grapheme)
        hasher.combine(template)
        hasher.combine(rtl)
        hasher.combine(position)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSymbol: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Symbol {
        return
            try Symbol(
                grapheme: FfiConverterOptionString.read(from: &buf), 
                template: FfiConverterOptionString.read(from: &buf), 
                rtl: FfiConverterOptionBool.read(from: &buf), 
                position: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Symbol, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.grapheme, into: &buf)
        FfiConverterOptionString.write(value.template, into: &buf)
        FfiConverterOptionBool.write(value.rtl, into: &buf)
        FfiConverterOptionUInt32.write(value.position, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSymbol_lift(_ buf: RustBuffer) throws -> Symbol {
    return try FfiConverterTypeSymbol.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSymbol_lower(_ value: Symbol) -> RustBuffer {
    return FfiConverterTypeSymbol.lower(value)
}


/**
 * Request to sync the wallet with the Spark network
 */
public struct SyncWalletRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension SyncWalletRequest: Equatable, Hashable {
    public static func ==(lhs: SyncWalletRequest, rhs: SyncWalletRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncWalletRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncWalletRequest {
        return
            SyncWalletRequest()
    }

    public static func write(_ value: SyncWalletRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletRequest_lift(_ buf: RustBuffer) throws -> SyncWalletRequest {
    return try FfiConverterTypeSyncWalletRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletRequest_lower(_ value: SyncWalletRequest) -> RustBuffer {
    return FfiConverterTypeSyncWalletRequest.lower(value)
}


/**
 * Response from synchronizing the wallet
 */
public struct SyncWalletResponse {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension SyncWalletResponse: Equatable, Hashable {
    public static func ==(lhs: SyncWalletResponse, rhs: SyncWalletResponse) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncWalletResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncWalletResponse {
        return
            SyncWalletResponse()
    }

    public static func write(_ value: SyncWalletResponse, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletResponse_lift(_ buf: RustBuffer) throws -> SyncWalletResponse {
    return try FfiConverterTypeSyncWalletResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletResponse_lower(_ value: SyncWalletResponse) -> RustBuffer {
    return FfiConverterTypeSyncWalletResponse.lower(value)
}


public struct TokenBalance {
    public var balance: U128
    public var tokenMetadata: TokenMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(balance: U128, tokenMetadata: TokenMetadata) {
        self.balance = balance
        self.tokenMetadata = tokenMetadata
    }
}



extension TokenBalance: Equatable, Hashable {
    public static func ==(lhs: TokenBalance, rhs: TokenBalance) -> Bool {
        if lhs.balance != rhs.balance {
            return false
        }
        if lhs.tokenMetadata != rhs.tokenMetadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balance)
        hasher.combine(tokenMetadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenBalance {
        return
            try TokenBalance(
                balance: FfiConverterTypeu128.read(from: &buf), 
                tokenMetadata: FfiConverterTypeTokenMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: TokenBalance, into buf: inout [UInt8]) {
        FfiConverterTypeu128.write(value.balance, into: &buf)
        FfiConverterTypeTokenMetadata.write(value.tokenMetadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalance_lift(_ buf: RustBuffer) throws -> TokenBalance {
    return try FfiConverterTypeTokenBalance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalance_lower(_ value: TokenBalance) -> RustBuffer {
    return FfiConverterTypeTokenBalance.lower(value)
}


public struct TokenMetadata {
    public var identifier: String
    /**
     * Hex representation of the issuer public key
     */
    public var issuerPublicKey: String
    public var name: String
    public var ticker: String
    /**
     * Number of decimals the token uses
     */
    public var decimals: UInt32
    public var maxSupply: U128
    public var isFreezable: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: String, 
        /**
         * Hex representation of the issuer public key
         */issuerPublicKey: String, name: String, ticker: String, 
        /**
         * Number of decimals the token uses
         */decimals: UInt32, maxSupply: U128, isFreezable: Bool) {
        self.identifier = identifier
        self.issuerPublicKey = issuerPublicKey
        self.name = name
        self.ticker = ticker
        self.decimals = decimals
        self.maxSupply = maxSupply
        self.isFreezable = isFreezable
    }
}



extension TokenMetadata: Equatable, Hashable {
    public static func ==(lhs: TokenMetadata, rhs: TokenMetadata) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.issuerPublicKey != rhs.issuerPublicKey {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.maxSupply != rhs.maxSupply {
            return false
        }
        if lhs.isFreezable != rhs.isFreezable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(issuerPublicKey)
        hasher.combine(name)
        hasher.combine(ticker)
        hasher.combine(decimals)
        hasher.combine(maxSupply)
        hasher.combine(isFreezable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenMetadata {
        return
            try TokenMetadata(
                identifier: FfiConverterString.read(from: &buf), 
                issuerPublicKey: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                ticker: FfiConverterString.read(from: &buf), 
                decimals: FfiConverterUInt32.read(from: &buf), 
                maxSupply: FfiConverterTypeu128.read(from: &buf), 
                isFreezable: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TokenMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterString.write(value.issuerPublicKey, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.ticker, into: &buf)
        FfiConverterUInt32.write(value.decimals, into: &buf)
        FfiConverterTypeu128.write(value.maxSupply, into: &buf)
        FfiConverterBool.write(value.isFreezable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenMetadata_lift(_ buf: RustBuffer) throws -> TokenMetadata {
    return try FfiConverterTypeTokenMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenMetadata_lower(_ value: TokenMetadata) -> RustBuffer {
    return FfiConverterTypeTokenMetadata.lower(value)
}


public struct TxStatus {
    public var confirmed: Bool
    public var blockHeight: UInt32?
    public var blockTime: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(confirmed: Bool, blockHeight: UInt32?, blockTime: UInt64?) {
        self.confirmed = confirmed
        self.blockHeight = blockHeight
        self.blockTime = blockTime
    }
}



extension TxStatus: Equatable, Hashable {
    public static func ==(lhs: TxStatus, rhs: TxStatus) -> Bool {
        if lhs.confirmed != rhs.confirmed {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.blockTime != rhs.blockTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(confirmed)
        hasher.combine(blockHeight)
        hasher.combine(blockTime)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxStatus {
        return
            try TxStatus(
                confirmed: FfiConverterBool.read(from: &buf), 
                blockHeight: FfiConverterOptionUInt32.read(from: &buf), 
                blockTime: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TxStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.confirmed, into: &buf)
        FfiConverterOptionUInt32.write(value.blockHeight, into: &buf)
        FfiConverterOptionUInt64.write(value.blockTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lift(_ buf: RustBuffer) throws -> TxStatus {
    return try FfiConverterTypeTxStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lower(_ value: TxStatus) -> RustBuffer {
    return FfiConverterTypeTxStatus.lower(value)
}


public struct UnfreezeIssuerTokenRequest {
    public var address: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String) {
        self.address = address
    }
}



extension UnfreezeIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: UnfreezeIssuerTokenRequest, rhs: UnfreezeIssuerTokenRequest) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnfreezeIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnfreezeIssuerTokenRequest {
        return
            try UnfreezeIssuerTokenRequest(
                address: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UnfreezeIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfreezeIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> UnfreezeIssuerTokenRequest {
    return try FfiConverterTypeUnfreezeIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfreezeIssuerTokenRequest_lower(_ value: UnfreezeIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeUnfreezeIssuerTokenRequest.lower(value)
}


public struct UnfreezeIssuerTokenResponse {
    public var impactedOutputIds: [String]
    public var impactedTokenAmount: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(impactedOutputIds: [String], impactedTokenAmount: U128) {
        self.impactedOutputIds = impactedOutputIds
        self.impactedTokenAmount = impactedTokenAmount
    }
}



extension UnfreezeIssuerTokenResponse: Equatable, Hashable {
    public static func ==(lhs: UnfreezeIssuerTokenResponse, rhs: UnfreezeIssuerTokenResponse) -> Bool {
        if lhs.impactedOutputIds != rhs.impactedOutputIds {
            return false
        }
        if lhs.impactedTokenAmount != rhs.impactedTokenAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(impactedOutputIds)
        hasher.combine(impactedTokenAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnfreezeIssuerTokenResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnfreezeIssuerTokenResponse {
        return
            try UnfreezeIssuerTokenResponse(
                impactedOutputIds: FfiConverterSequenceString.read(from: &buf), 
                impactedTokenAmount: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: UnfreezeIssuerTokenResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.impactedOutputIds, into: &buf)
        FfiConverterTypeu128.write(value.impactedTokenAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfreezeIssuerTokenResponse_lift(_ buf: RustBuffer) throws -> UnfreezeIssuerTokenResponse {
    return try FfiConverterTypeUnfreezeIssuerTokenResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfreezeIssuerTokenResponse_lower(_ value: UnfreezeIssuerTokenResponse) -> RustBuffer {
    return FfiConverterTypeUnfreezeIssuerTokenResponse.lower(value)
}


public struct UnversionedRecordChange {
    public var id: RecordId
    public var schemaVersion: String
    public var updatedFields: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: RecordId, schemaVersion: String, updatedFields: [String: String]) {
        self.id = id
        self.schemaVersion = schemaVersion
        self.updatedFields = updatedFields
    }
}



extension UnversionedRecordChange: Equatable, Hashable {
    public static func ==(lhs: UnversionedRecordChange, rhs: UnversionedRecordChange) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.schemaVersion != rhs.schemaVersion {
            return false
        }
        if lhs.updatedFields != rhs.updatedFields {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(schemaVersion)
        hasher.combine(updatedFields)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnversionedRecordChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnversionedRecordChange {
        return
            try UnversionedRecordChange(
                id: FfiConverterTypeRecordId.read(from: &buf), 
                schemaVersion: FfiConverterString.read(from: &buf), 
                updatedFields: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: UnversionedRecordChange, into buf: inout [UInt8]) {
        FfiConverterTypeRecordId.write(value.id, into: &buf)
        FfiConverterString.write(value.schemaVersion, into: &buf)
        FfiConverterDictionaryStringString.write(value.updatedFields, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnversionedRecordChange_lift(_ buf: RustBuffer) throws -> UnversionedRecordChange {
    return try FfiConverterTypeUnversionedRecordChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnversionedRecordChange_lower(_ value: UnversionedRecordChange) -> RustBuffer {
    return FfiConverterTypeUnversionedRecordChange.lower(value)
}


public struct UpdateUserSettingsRequest {
    public var sparkPrivateModeEnabled: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sparkPrivateModeEnabled: Bool?) {
        self.sparkPrivateModeEnabled = sparkPrivateModeEnabled
    }
}



extension UpdateUserSettingsRequest: Equatable, Hashable {
    public static func ==(lhs: UpdateUserSettingsRequest, rhs: UpdateUserSettingsRequest) -> Bool {
        if lhs.sparkPrivateModeEnabled != rhs.sparkPrivateModeEnabled {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sparkPrivateModeEnabled)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateUserSettingsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateUserSettingsRequest {
        return
            try UpdateUserSettingsRequest(
                sparkPrivateModeEnabled: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateUserSettingsRequest, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.sparkPrivateModeEnabled, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateUserSettingsRequest_lift(_ buf: RustBuffer) throws -> UpdateUserSettingsRequest {
    return try FfiConverterTypeUpdateUserSettingsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateUserSettingsRequest_lower(_ value: UpdateUserSettingsRequest) -> RustBuffer {
    return FfiConverterTypeUpdateUserSettingsRequest.lower(value)
}


public struct UrlSuccessActionData {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * URL of the success action
     */
    public var url: String
    /**
     * Indicates the success URL domain matches the LNURL callback domain.
     *
     * See <https://github.com/lnurl/luds/blob/luds/09.md>
     */
    public var matchesCallbackDomain: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * URL of the success action
         */url: String, 
        /**
         * Indicates the success URL domain matches the LNURL callback domain.
         *
         * See <https://github.com/lnurl/luds/blob/luds/09.md>
         */matchesCallbackDomain: Bool) {
        self.description = description
        self.url = url
        self.matchesCallbackDomain = matchesCallbackDomain
    }
}



extension UrlSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: UrlSuccessActionData, rhs: UrlSuccessActionData) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.matchesCallbackDomain != rhs.matchesCallbackDomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(matchesCallbackDomain)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUrlSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlSuccessActionData {
        return
            try UrlSuccessActionData(
                description: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                matchesCallbackDomain: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UrlSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterBool.write(value.matchesCallbackDomain, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrlSuccessActionData_lift(_ buf: RustBuffer) throws -> UrlSuccessActionData {
    return try FfiConverterTypeUrlSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrlSuccessActionData_lower(_ value: UrlSuccessActionData) -> RustBuffer {
    return FfiConverterTypeUrlSuccessActionData.lower(value)
}


public struct UserSettings {
    public var sparkPrivateModeEnabled: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sparkPrivateModeEnabled: Bool) {
        self.sparkPrivateModeEnabled = sparkPrivateModeEnabled
    }
}



extension UserSettings: Equatable, Hashable {
    public static func ==(lhs: UserSettings, rhs: UserSettings) -> Bool {
        if lhs.sparkPrivateModeEnabled != rhs.sparkPrivateModeEnabled {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sparkPrivateModeEnabled)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserSettings {
        return
            try UserSettings(
                sparkPrivateModeEnabled: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UserSettings, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.sparkPrivateModeEnabled, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserSettings_lift(_ buf: RustBuffer) throws -> UserSettings {
    return try FfiConverterTypeUserSettings.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserSettings_lower(_ value: UserSettings) -> RustBuffer {
    return FfiConverterTypeUserSettings.lower(value)
}


public struct Utxo {
    public var txid: String
    public var vout: UInt32
    public var value: UInt64
    public var status: TxStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, value: UInt64, status: TxStatus) {
        self.txid = txid
        self.vout = vout
        self.value = value
        self.status = status
    }
}



extension Utxo: Equatable, Hashable {
    public static func ==(lhs: Utxo, rhs: Utxo) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(value)
        hasher.combine(status)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Utxo {
        return
            try Utxo(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                value: FfiConverterUInt64.read(from: &buf), 
                status: FfiConverterTypeTxStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Utxo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.value, into: &buf)
        FfiConverterTypeTxStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lift(_ buf: RustBuffer) throws -> Utxo {
    return try FfiConverterTypeUtxo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lower(_ value: Utxo) -> RustBuffer {
    return FfiConverterTypeUtxo.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of decryption of [`AesSuccessActionData`] payload
 */

public enum AesSuccessActionDataResult {
    
    case decrypted(data: AesSuccessActionDataDecrypted
    )
    case errorStatus(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionDataResult: FfiConverterRustBuffer {
    typealias SwiftType = AesSuccessActionDataResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .decrypted(data: try FfiConverterTypeAesSuccessActionDataDecrypted.read(from: &buf)
        )
        
        case 2: return .errorStatus(reason: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AesSuccessActionDataResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .decrypted(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataDecrypted.write(data, into: &buf)
            
        
        case let .errorStatus(reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataResult_lift(_ buf: RustBuffer) throws -> AesSuccessActionDataResult {
    return try FfiConverterTypeAesSuccessActionDataResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataResult_lower(_ value: AesSuccessActionDataResult) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionDataResult.lower(value)
}



extension AesSuccessActionDataResult: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Amount {
    
    case bitcoin(amountMsat: UInt64
    )
    /**
     * An amount of currency specified using ISO 4712.
     */
    case currency(
        /**
         * The currency that the amount is denominated in.
         */iso4217Code: String, 
        /**
         * The amount in the currency unit adjusted by the ISO 4712 exponent (e.g., USD cents).
         */fractionalAmount: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin(amountMsat: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .currency(iso4217Code: try FfiConverterString.read(from: &buf), fractionalAmount: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoin(amountMsat):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amountMsat, into: &buf)
            
        
        case let .currency(iso4217Code,fractionalAmount):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(iso4217Code, into: &buf)
            FfiConverterUInt64.write(fractionalAmount, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ buf: RustBuffer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> RustBuffer {
    return FfiConverterTypeAmount.lower(value)
}



extension Amount: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */

public enum AssetFilter {
    
    case bitcoin
    case token(
        /**
         * Optional token identifier to filter by
         */tokenIdentifier: String?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAssetFilter: FfiConverterRustBuffer {
    typealias SwiftType = AssetFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .token(tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case let .token(tokenIdentifier):
            writeInt(&buf, Int32(2))
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetFilter_lift(_ buf: RustBuffer) throws -> AssetFilter {
    return try FfiConverterTypeAssetFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetFilter_lower(_ value: AssetFilter) -> RustBuffer {
    return FfiConverterTypeAssetFilter.lower(value)
}



extension AssetFilter: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BitcoinNetwork {
    
    /**
     * Mainnet
     */
    case bitcoin
    case testnet3
    case testnet4
    case signet
    case regtest
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinNetwork: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet3
        
        case 3: return .testnet4
        
        case 4: return .signet
        
        case 5: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinNetwork, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet3:
            writeInt(&buf, Int32(2))
        
        
        case .testnet4:
            writeInt(&buf, Int32(3))
        
        
        case .signet:
            writeInt(&buf, Int32(4))
        
        
        case .regtest:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinNetwork_lift(_ buf: RustBuffer) throws -> BitcoinNetwork {
    return try FfiConverterTypeBitcoinNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinNetwork_lower(_ value: BitcoinNetwork) -> RustBuffer {
    return FfiConverterTypeBitcoinNetwork.lower(value)
}



extension BitcoinNetwork: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ChainApiType {
    
    case esplora
    case mempoolSpace
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainApiType: FfiConverterRustBuffer {
    typealias SwiftType = ChainApiType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainApiType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .esplora
        
        case 2: return .mempoolSpace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChainApiType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .esplora:
            writeInt(&buf, Int32(1))
        
        
        case .mempoolSpace:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainApiType_lift(_ buf: RustBuffer) throws -> ChainApiType {
    return try FfiConverterTypeChainApiType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainApiType_lower(_ value: ChainApiType) -> RustBuffer {
    return FfiConverterTypeChainApiType.lower(value)
}



extension ChainApiType: Equatable, Hashable {}




public enum ChainServiceError {

    
    
    case InvalidAddress(String
    )
    case ServiceConnectivity(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainServiceError: FfiConverterRustBuffer {
    typealias SwiftType = ChainServiceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainServiceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidAddress(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ServiceConnectivity(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChainServiceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ServiceConnectivity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ChainServiceError: Equatable, Hashable {}

extension ChainServiceError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DepositClaimError {
    
    case maxDepositClaimFeeExceeded(tx: String, vout: UInt32, maxFee: Fee?, requiredFeeSats: UInt64, requiredFeeRateSatPerVbyte: UInt64
    )
    case missingUtxo(tx: String, vout: UInt32
    )
    case generic(message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositClaimError: FfiConverterRustBuffer {
    typealias SwiftType = DepositClaimError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositClaimError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .maxDepositClaimFeeExceeded(tx: try FfiConverterString.read(from: &buf), vout: try FfiConverterUInt32.read(from: &buf), maxFee: try FfiConverterOptionTypeFee.read(from: &buf), requiredFeeSats: try FfiConverterUInt64.read(from: &buf), requiredFeeRateSatPerVbyte: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .missingUtxo(tx: try FfiConverterString.read(from: &buf), vout: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .generic(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositClaimError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .maxDepositClaimFeeExceeded(tx,vout,maxFee,requiredFeeSats,requiredFeeRateSatPerVbyte):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            FfiConverterOptionTypeFee.write(maxFee, into: &buf)
            FfiConverterUInt64.write(requiredFeeSats, into: &buf)
            FfiConverterUInt64.write(requiredFeeRateSatPerVbyte, into: &buf)
            
        
        case let .missingUtxo(tx,vout):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            
        
        case let .generic(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositClaimError_lift(_ buf: RustBuffer) throws -> DepositClaimError {
    return try FfiConverterTypeDepositClaimError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositClaimError_lower(_ value: DepositClaimError) -> RustBuffer {
    return FfiConverterTypeDepositClaimError.lower(value)
}



extension DepositClaimError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Fee {
    
    case fixed(amount: UInt64
    )
    case rate(satPerVbyte: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFee: FfiConverterRustBuffer {
    typealias SwiftType = Fee

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fee {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fixed(amount: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .rate(satPerVbyte: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Fee, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fixed(amount):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amount, into: &buf)
            
        
        case let .rate(satPerVbyte):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(satPerVbyte, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lift(_ buf: RustBuffer) throws -> Fee {
    return try FfiConverterTypeFee.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lower(_ value: Fee) -> RustBuffer {
    return FfiConverterTypeFee.lower(value)
}



extension Fee: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum InputType {
    
    case bitcoinAddress(BitcoinAddressDetails
    )
    case bolt11Invoice(Bolt11InvoiceDetails
    )
    case bolt12Invoice(Bolt12InvoiceDetails
    )
    case bolt12Offer(Bolt12OfferDetails
    )
    case lightningAddress(LightningAddressDetails
    )
    case lnurlPay(LnurlPayRequestDetails
    )
    case silentPaymentAddress(SilentPaymentAddressDetails
    )
    case lnurlAuth(LnurlAuthRequestDetails
    )
    case url(String
    )
    case bip21(Bip21Details
    )
    case bolt12InvoiceRequest(Bolt12InvoiceRequestDetails
    )
    case lnurlWithdraw(LnurlWithdrawRequestDetails
    )
    case sparkAddress(SparkAddressDetails
    )
    case sparkInvoice(SparkInvoiceDetails
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = InputType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(try FfiConverterTypeBitcoinAddressDetails.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(try FfiConverterTypeBolt11InvoiceDetails.read(from: &buf)
        )
        
        case 3: return .bolt12Invoice(try FfiConverterTypeBolt12InvoiceDetails.read(from: &buf)
        )
        
        case 4: return .bolt12Offer(try FfiConverterTypeBolt12OfferDetails.read(from: &buf)
        )
        
        case 5: return .lightningAddress(try FfiConverterTypeLightningAddressDetails.read(from: &buf)
        )
        
        case 6: return .lnurlPay(try FfiConverterTypeLnurlPayRequestDetails.read(from: &buf)
        )
        
        case 7: return .silentPaymentAddress(try FfiConverterTypeSilentPaymentAddressDetails.read(from: &buf)
        )
        
        case 8: return .lnurlAuth(try FfiConverterTypeLnurlAuthRequestDetails.read(from: &buf)
        )
        
        case 9: return .url(try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .bip21(try FfiConverterTypeBip21Details.read(from: &buf)
        )
        
        case 11: return .bolt12InvoiceRequest(try FfiConverterTypeBolt12InvoiceRequestDetails.read(from: &buf)
        )
        
        case 12: return .lnurlWithdraw(try FfiConverterTypeLnurlWithdrawRequestDetails.read(from: &buf)
        )
        
        case 13: return .sparkAddress(try FfiConverterTypeSparkAddressDetails.read(from: &buf)
        )
        
        case 14: return .sparkInvoice(try FfiConverterTypeSparkInvoiceDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InputType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressDetails.write(v1, into: &buf)
            
        
        case let .bolt11Invoice(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBolt11InvoiceDetails.write(v1, into: &buf)
            
        
        case let .bolt12Invoice(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBolt12InvoiceDetails.write(v1, into: &buf)
            
        
        case let .bolt12Offer(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBolt12OfferDetails.write(v1, into: &buf)
            
        
        case let .lightningAddress(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeLightningAddressDetails.write(v1, into: &buf)
            
        
        case let .lnurlPay(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLnurlPayRequestDetails.write(v1, into: &buf)
            
        
        case let .silentPaymentAddress(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeSilentPaymentAddressDetails.write(v1, into: &buf)
            
        
        case let .lnurlAuth(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeLnurlAuthRequestDetails.write(v1, into: &buf)
            
        
        case let .url(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .bip21(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeBip21Details.write(v1, into: &buf)
            
        
        case let .bolt12InvoiceRequest(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeBolt12InvoiceRequestDetails.write(v1, into: &buf)
            
        
        case let .lnurlWithdraw(v1):
            writeInt(&buf, Int32(12))
            FfiConverterTypeLnurlWithdrawRequestDetails.write(v1, into: &buf)
            
        
        case let .sparkAddress(v1):
            writeInt(&buf, Int32(13))
            FfiConverterTypeSparkAddressDetails.write(v1, into: &buf)
            
        
        case let .sparkInvoice(v1):
            writeInt(&buf, Int32(14))
            FfiConverterTypeSparkInvoiceDetails.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputType_lift(_ buf: RustBuffer) throws -> InputType {
    return try FfiConverterTypeInputType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputType_lower(_ value: InputType) -> RustBuffer {
    return FfiConverterTypeInputType.lower(value)
}



extension InputType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum KeySetType {
    
    case `default`
    case taproot
    case nativeSegwit
    case wrappedSegwit
    case legacy
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeySetType: FfiConverterRustBuffer {
    typealias SwiftType = KeySetType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySetType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .taproot
        
        case 3: return .nativeSegwit
        
        case 4: return .wrappedSegwit
        
        case 5: return .legacy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeySetType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .taproot:
            writeInt(&buf, Int32(2))
        
        
        case .nativeSegwit:
            writeInt(&buf, Int32(3))
        
        
        case .wrappedSegwit:
            writeInt(&buf, Int32(4))
        
        
        case .legacy:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySetType_lift(_ buf: RustBuffer) throws -> KeySetType {
    return try FfiConverterTypeKeySetType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySetType_lower(_ value: KeySetType) -> RustBuffer {
    return FfiConverterTypeKeySetType.lower(value)
}



extension KeySetType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case mainnet
    case regtest
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .regtest:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OnchainConfirmationSpeed {
    
    case fast
    case medium
    case slow
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnchainConfirmationSpeed: FfiConverterRustBuffer {
    typealias SwiftType = OnchainConfirmationSpeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainConfirmationSpeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fast
        
        case 2: return .medium
        
        case 3: return .slow
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OnchainConfirmationSpeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fast:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .slow:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainConfirmationSpeed_lift(_ buf: RustBuffer) throws -> OnchainConfirmationSpeed {
    return try FfiConverterTypeOnchainConfirmationSpeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainConfirmationSpeed_lower(_ value: OnchainConfirmationSpeed) -> RustBuffer {
    return FfiConverterTypeOnchainConfirmationSpeed.lower(value)
}



extension OnchainConfirmationSpeed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentDetails {
    
    case spark(
        /**
         * The invoice details if the payment fulfilled a spark invoice
         */invoiceDetails: SparkInvoicePaymentDetails?, 
        /**
         * The HTLC transfer details if the payment fulfilled an HTLC transfer
         */htlcDetails: SparkHtlcDetails?
    )
    case token(metadata: TokenMetadata, txHash: String, 
        /**
         * The invoice details if the payment fulfilled a spark invoice
         */invoiceDetails: SparkInvoicePaymentDetails?
    )
    case lightning(
        /**
         * Represents the invoice description
         */description: String?, 
        /**
         * The preimage of the paid invoice (proof of payment).
         */preimage: String?, 
        /**
         * Represents the Bolt11/Bolt12 invoice associated with a payment
         * In the case of a Send payment, this is the invoice paid by the user
         * In the case of a Receive payment, this is the invoice paid to the user
         */invoice: String, 
        /**
         * The payment hash of the invoice
         */paymentHash: String, 
        /**
         * The invoice destination/payee pubkey
         */destinationPubkey: String, 
        /**
         * Lnurl payment information if this was an lnurl payment.
         */lnurlPayInfo: LnurlPayInfo?, 
        /**
         * Lnurl withdrawal information if this was an lnurl payment.
         */lnurlWithdrawInfo: LnurlWithdrawInfo?, 
        /**
         * Lnurl receive information if this was a received lnurl payment.
         */lnurlReceiveMetadata: LnurlReceiveMetadata?
    )
    case withdraw(txId: String
    )
    case deposit(txId: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .spark(invoiceDetails: try FfiConverterOptionTypeSparkInvoicePaymentDetails.read(from: &buf), htlcDetails: try FfiConverterOptionTypeSparkHtlcDetails.read(from: &buf)
        )
        
        case 2: return .token(metadata: try FfiConverterTypeTokenMetadata.read(from: &buf), txHash: try FfiConverterString.read(from: &buf), invoiceDetails: try FfiConverterOptionTypeSparkInvoicePaymentDetails.read(from: &buf)
        )
        
        case 3: return .lightning(description: try FfiConverterOptionString.read(from: &buf), preimage: try FfiConverterOptionString.read(from: &buf), invoice: try FfiConverterString.read(from: &buf), paymentHash: try FfiConverterString.read(from: &buf), destinationPubkey: try FfiConverterString.read(from: &buf), lnurlPayInfo: try FfiConverterOptionTypeLnurlPayInfo.read(from: &buf), lnurlWithdrawInfo: try FfiConverterOptionTypeLnurlWithdrawInfo.read(from: &buf), lnurlReceiveMetadata: try FfiConverterOptionTypeLnurlReceiveMetadata.read(from: &buf)
        )
        
        case 4: return .withdraw(txId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .deposit(txId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .spark(invoiceDetails,htlcDetails):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeSparkInvoicePaymentDetails.write(invoiceDetails, into: &buf)
            FfiConverterOptionTypeSparkHtlcDetails.write(htlcDetails, into: &buf)
            
        
        case let .token(metadata,txHash,invoiceDetails):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTokenMetadata.write(metadata, into: &buf)
            FfiConverterString.write(txHash, into: &buf)
            FfiConverterOptionTypeSparkInvoicePaymentDetails.write(invoiceDetails, into: &buf)
            
        
        case let .lightning(description,preimage,invoice,paymentHash,destinationPubkey,lnurlPayInfo,lnurlWithdrawInfo,lnurlReceiveMetadata):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterOptionString.write(preimage, into: &buf)
            FfiConverterString.write(invoice, into: &buf)
            FfiConverterString.write(paymentHash, into: &buf)
            FfiConverterString.write(destinationPubkey, into: &buf)
            FfiConverterOptionTypeLnurlPayInfo.write(lnurlPayInfo, into: &buf)
            FfiConverterOptionTypeLnurlWithdrawInfo.write(lnurlWithdrawInfo, into: &buf)
            FfiConverterOptionTypeLnurlReceiveMetadata.write(lnurlReceiveMetadata, into: &buf)
            
        
        case let .withdraw(txId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(txId, into: &buf)
            
        
        case let .deposit(txId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(txId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}



extension PaymentDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentMethod {
    
    case lightning
    case spark
    case token
    case deposit
    case withdraw
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = PaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lightning
        
        case 2: return .spark
        
        case 3: return .token
        
        case 4: return .deposit
        
        case 5: return .withdraw
        
        case 6: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lightning:
            writeInt(&buf, Int32(1))
        
        
        case .spark:
            writeInt(&buf, Int32(2))
        
        
        case .token:
            writeInt(&buf, Int32(3))
        
        
        case .deposit:
            writeInt(&buf, Int32(4))
        
        
        case .withdraw:
            writeInt(&buf, Int32(5))
        
        
        case .unknown:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lift(_ buf: RustBuffer) throws -> PaymentMethod {
    return try FfiConverterTypePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lower(_ value: PaymentMethod) -> RustBuffer {
    return FfiConverterTypePaymentMethod.lower(value)
}



extension PaymentMethod: Equatable, Hashable {}




public enum PaymentObserverError {

    
    
    case ServiceConnectivity(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentObserverError: FfiConverterRustBuffer {
    typealias SwiftType = PaymentObserverError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentObserverError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ServiceConnectivity(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentObserverError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ServiceConnectivity(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension PaymentObserverError: Equatable, Hashable {}

extension PaymentObserverError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The status of a payment
 */

public enum PaymentStatus {
    
    /**
     * Payment is completed successfully
     */
    case completed
    /**
     * Payment is in progress
     */
    case pending
    /**
     * Payment has failed
     */
    case failed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .completed
        
        case 2: return .pending
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .completed:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}



extension PaymentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of payment
 */

public enum PaymentType {
    
    /**
     * Payment sent from this wallet
     */
    case send
    /**
     * Payment received to this wallet
     */
    case receive
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .send
        
        case 2: return .receive
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .send:
            writeInt(&buf, Int32(1))
        
        
        case .receive:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentType_lift(_ buf: RustBuffer) throws -> PaymentType {
    return try FfiConverterTypePaymentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentType_lower(_ value: PaymentType) -> RustBuffer {
    return FfiConverterTypePaymentType.lower(value)
}



extension PaymentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProvisionalPaymentDetails {
    
    case bitcoin(
        /**
         * Onchain Bitcoin address
         */withdrawalAddress: String
    )
    case lightning(
        /**
         * BOLT11 invoice
         */invoice: String
    )
    case spark(
        /**
         * Spark pay request being paid (either a Spark address or a Spark invoice)
         */payRequest: String
    )
    case token(
        /**
         * Token identifier
         */tokenId: String, 
        /**
         * Spark pay request being paid (either a Spark address or a Spark invoice)
         */payRequest: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProvisionalPaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProvisionalPaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProvisionalPaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin(withdrawalAddress: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .lightning(invoice: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .spark(payRequest: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .token(tokenId: try FfiConverterString.read(from: &buf), payRequest: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProvisionalPaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoin(withdrawalAddress):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(withdrawalAddress, into: &buf)
            
        
        case let .lightning(invoice):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(invoice, into: &buf)
            
        
        case let .spark(payRequest):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(payRequest, into: &buf)
            
        
        case let .token(tokenId,payRequest):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(tokenId, into: &buf)
            FfiConverterString.write(payRequest, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPaymentDetails_lift(_ buf: RustBuffer) throws -> ProvisionalPaymentDetails {
    return try FfiConverterTypeProvisionalPaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPaymentDetails_lower(_ value: ProvisionalPaymentDetails) -> RustBuffer {
    return FfiConverterTypeProvisionalPaymentDetails.lower(value)
}



extension ProvisionalPaymentDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ReceivePaymentMethod {
    
    case sparkAddress
    case sparkInvoice(
        /**
         * Amount to receive. Denominated in sats if token identifier is empty, otherwise in the token base units
         */amount: U128?, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?, 
        /**
         * The expiry time of the invoice in seconds since the Unix epoch
         */expiryTime: UInt64?, 
        /**
         * A description to embed in the invoice.
         */description: String?, 
        /**
         * If set, the invoice may only be fulfilled by a payer with this public key
         */senderPublicKey: String?
    )
    case bitcoinAddress
    case bolt11Invoice(description: String, amountSats: UInt64?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = ReceivePaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sparkAddress
        
        case 2: return .sparkInvoice(amount: try FfiConverterOptionTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf), expiryTime: try FfiConverterOptionUInt64.read(from: &buf), description: try FfiConverterOptionString.read(from: &buf), senderPublicKey: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 3: return .bitcoinAddress
        
        case 4: return .bolt11Invoice(description: try FfiConverterString.read(from: &buf), amountSats: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceivePaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sparkAddress:
            writeInt(&buf, Int32(1))
        
        
        case let .sparkInvoice(amount,tokenIdentifier,expiryTime,description,senderPublicKey):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeu128.write(amount, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            FfiConverterOptionUInt64.write(expiryTime, into: &buf)
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterOptionString.write(senderPublicKey, into: &buf)
            
        
        case .bitcoinAddress:
            writeInt(&buf, Int32(3))
        
        
        case let .bolt11Invoice(description,amountSats):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(description, into: &buf)
            FfiConverterOptionUInt64.write(amountSats, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentMethod_lift(_ buf: RustBuffer) throws -> ReceivePaymentMethod {
    return try FfiConverterTypeReceivePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentMethod_lower(_ value: ReceivePaymentMethod) -> RustBuffer {
    return FfiConverterTypeReceivePaymentMethod.lower(value)
}



extension ReceivePaymentMethod: Equatable, Hashable {}




/**
 * Error type for the `BreezSdk`
 */
public enum SdkError {

    
    
    case SparkError(String
    )
    case InvalidUuid(String
    )
    /**
     * Invalid input error
     */
    case InvalidInput(String
    )
    /**
     * Network error
     */
    case NetworkError(String
    )
    /**
     * Storage error
     */
    case StorageError(String
    )
    case ChainServiceError(String
    )
    case MaxDepositClaimFeeExceeded(tx: String, vout: UInt32, maxFee: Fee?, requiredFeeSats: UInt64, requiredFeeRateSatPerVbyte: UInt64
    )
    case MissingUtxo(tx: String, vout: UInt32
    )
    case LnurlError(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkError: FfiConverterRustBuffer {
    typealias SwiftType = SdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SparkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidUuid(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidInput(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .NetworkError(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .StorageError(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .ChainServiceError(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .MaxDepositClaimFeeExceeded(
            tx: try FfiConverterString.read(from: &buf), 
            vout: try FfiConverterUInt32.read(from: &buf), 
            maxFee: try FfiConverterOptionTypeFee.read(from: &buf), 
            requiredFeeSats: try FfiConverterUInt64.read(from: &buf), 
            requiredFeeRateSatPerVbyte: try FfiConverterUInt64.read(from: &buf)
            )
        case 8: return .MissingUtxo(
            tx: try FfiConverterString.read(from: &buf), 
            vout: try FfiConverterUInt32.read(from: &buf)
            )
        case 9: return .LnurlError(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SparkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidUuid(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidInput(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NetworkError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .StorageError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ChainServiceError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .MaxDepositClaimFeeExceeded(tx,vout,maxFee,requiredFeeSats,requiredFeeRateSatPerVbyte):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            FfiConverterOptionTypeFee.write(maxFee, into: &buf)
            FfiConverterUInt64.write(requiredFeeSats, into: &buf)
            FfiConverterUInt64.write(requiredFeeRateSatPerVbyte, into: &buf)
            
        
        case let .MissingUtxo(tx,vout):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            
        
        case let .LnurlError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension SdkError: Equatable, Hashable {}

extension SdkError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Events emitted by the SDK
 */

public enum SdkEvent {
    
    /**
     * Emitted when the wallet has been synchronized with the network
     */
    case synced
    /**
     * Emitted when data was pushed and/or pulled to/from real-time sync storage.
     */
    case dataSynced(
        /**
         * Value indicating whether new data was pulled through real-time sync.
         */didPullNewRecords: Bool
    )
    /**
     * Emitted when the SDK was unable to claim deposits
     */
    case unclaimedDeposits(unclaimedDeposits: [DepositInfo]
    )
    case claimedDeposits(claimedDeposits: [DepositInfo]
    )
    case paymentSucceeded(payment: Payment
    )
    case paymentPending(payment: Payment
    )
    case paymentFailed(payment: Payment
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkEvent: FfiConverterRustBuffer {
    typealias SwiftType = SdkEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .synced
        
        case 2: return .dataSynced(didPullNewRecords: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .unclaimedDeposits(unclaimedDeposits: try FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
        
        case 4: return .claimedDeposits(claimedDeposits: try FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
        
        case 5: return .paymentSucceeded(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        case 6: return .paymentPending(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        case 7: return .paymentFailed(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .synced:
            writeInt(&buf, Int32(1))
        
        
        case let .dataSynced(didPullNewRecords):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(didPullNewRecords, into: &buf)
            
        
        case let .unclaimedDeposits(unclaimedDeposits):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeDepositInfo.write(unclaimedDeposits, into: &buf)
            
        
        case let .claimedDeposits(claimedDeposits):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeDepositInfo.write(claimedDeposits, into: &buf)
            
        
        case let .paymentSucceeded(payment):
            writeInt(&buf, Int32(5))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        
        case let .paymentPending(payment):
            writeInt(&buf, Int32(6))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        
        case let .paymentFailed(payment):
            writeInt(&buf, Int32(7))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkEvent_lift(_ buf: RustBuffer) throws -> SdkEvent {
    return try FfiConverterTypeSdkEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkEvent_lower(_ value: SdkEvent) -> RustBuffer {
    return FfiConverterTypeSdkEvent.lower(value)
}



extension SdkEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */

public enum Seed {
    
    /**
     * A BIP-39 mnemonic phrase with an optional passphrase.
     */
    case mnemonic(
        /**
         * The mnemonic phrase. 12 or 24 words.
         */mnemonic: String, 
        /**
         * An optional passphrase for the mnemonic.
         */passphrase: String?
    )
    /**
     * Raw entropy bytes.
     */
    case entropy(Data
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSeed: FfiConverterRustBuffer {
    typealias SwiftType = Seed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Seed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mnemonic(mnemonic: try FfiConverterString.read(from: &buf), passphrase: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 2: return .entropy(try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Seed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .mnemonic(mnemonic,passphrase):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(mnemonic, into: &buf)
            FfiConverterOptionString.write(passphrase, into: &buf)
            
        
        case let .entropy(v1):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeed_lift(_ buf: RustBuffer) throws -> Seed {
    return try FfiConverterTypeSeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeed_lower(_ value: Seed) -> RustBuffer {
    return FfiConverterTypeSeed.lower(value)
}



extension Seed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendPaymentMethod {
    
    case bitcoinAddress(address: BitcoinAddressDetails, feeQuote: SendOnchainFeeQuote
    )
    case bolt11Invoice(invoiceDetails: Bolt11InvoiceDetails, sparkTransferFeeSats: UInt64?, lightningFeeSats: UInt64
    )
    case sparkAddress(address: String, 
        /**
         * Fee to pay for the transaction
         * Denominated in sats if token identifier is empty, otherwise in the token base units
         */fee: U128, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?
    )
    case sparkInvoice(sparkInvoiceDetails: SparkInvoiceDetails, 
        /**
         * Fee to pay for the transaction
         * Denominated in sats if token identifier is empty, otherwise in the token base units
         */fee: U128, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(address: try FfiConverterTypeBitcoinAddressDetails.read(from: &buf), feeQuote: try FfiConverterTypeSendOnchainFeeQuote.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(invoiceDetails: try FfiConverterTypeBolt11InvoiceDetails.read(from: &buf), sparkTransferFeeSats: try FfiConverterOptionUInt64.read(from: &buf), lightningFeeSats: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .sparkAddress(address: try FfiConverterString.read(from: &buf), fee: try FfiConverterTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .sparkInvoice(sparkInvoiceDetails: try FfiConverterTypeSparkInvoiceDetails.read(from: &buf), fee: try FfiConverterTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(address,feeQuote):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressDetails.write(address, into: &buf)
            FfiConverterTypeSendOnchainFeeQuote.write(feeQuote, into: &buf)
            
        
        case let .bolt11Invoice(invoiceDetails,sparkTransferFeeSats,lightningFeeSats):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBolt11InvoiceDetails.write(invoiceDetails, into: &buf)
            FfiConverterOptionUInt64.write(sparkTransferFeeSats, into: &buf)
            FfiConverterUInt64.write(lightningFeeSats, into: &buf)
            
        
        case let .sparkAddress(address,fee,tokenIdentifier):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(address, into: &buf)
            FfiConverterTypeu128.write(fee, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        
        case let .sparkInvoice(sparkInvoiceDetails,fee,tokenIdentifier):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSparkInvoiceDetails.write(sparkInvoiceDetails, into: &buf)
            FfiConverterTypeu128.write(fee, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentMethod_lift(_ buf: RustBuffer) throws -> SendPaymentMethod {
    return try FfiConverterTypeSendPaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentMethod_lower(_ value: SendPaymentMethod) -> RustBuffer {
    return FfiConverterTypeSendPaymentMethod.lower(value)
}



extension SendPaymentMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendPaymentOptions {
    
    case bitcoinAddress(confirmationSpeed: OnchainConfirmationSpeed
    )
    case bolt11Invoice(preferSpark: Bool, 
        /**
         * If set, the function will return the payment if it is still pending after this
         * number of seconds. If unset, the function will return immediately after initiating the payment.
         */completionTimeoutSecs: UInt32?
    )
    case sparkAddress(
        /**
         * Can only be provided for Bitcoin payments. If set, a Spark HTLC transfer will be created.
         * The receiver will need to provide the preimage to claim it.
         */htlcOptions: SparkHtlcOptions?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentOptions: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(confirmationSpeed: try FfiConverterTypeOnchainConfirmationSpeed.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(preferSpark: try FfiConverterBool.read(from: &buf), completionTimeoutSecs: try FfiConverterOptionUInt32.read(from: &buf)
        )
        
        case 3: return .sparkAddress(htlcOptions: try FfiConverterOptionTypeSparkHtlcOptions.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(confirmationSpeed):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOnchainConfirmationSpeed.write(confirmationSpeed, into: &buf)
            
        
        case let .bolt11Invoice(preferSpark,completionTimeoutSecs):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(preferSpark, into: &buf)
            FfiConverterOptionUInt32.write(completionTimeoutSecs, into: &buf)
            
        
        case let .sparkAddress(htlcOptions):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypeSparkHtlcOptions.write(htlcOptions, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentOptions_lift(_ buf: RustBuffer) throws -> SendPaymentOptions {
    return try FfiConverterTypeSendPaymentOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentOptions_lower(_ value: SendPaymentOptions) -> RustBuffer {
    return FfiConverterTypeSendPaymentOptions.lower(value)
}



extension SendPaymentOptions: Equatable, Hashable {}




public enum ServiceConnectivityError {

    
    
    case Builder(String
    )
    case Redirect(String
    )
    case Status(status: UInt16, body: String
    )
    case Timeout(String
    )
    case Request(String
    )
    case Connect(String
    )
    case Body(String
    )
    case Decode(String
    )
    case Json(String
    )
    case Other(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServiceConnectivityError: FfiConverterRustBuffer {
    typealias SwiftType = ServiceConnectivityError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServiceConnectivityError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Builder(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Redirect(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Status(
            status: try FfiConverterUInt16.read(from: &buf), 
            body: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Timeout(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Request(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .Connect(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .Body(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .Decode(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .Json(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .Other(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ServiceConnectivityError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Builder(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Redirect(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Status(status,body):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(status, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .Timeout(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Request(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Connect(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Body(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Decode(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Json(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Other(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ServiceConnectivityError: Equatable, Hashable {}

extension ServiceConnectivityError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparkHtlcStatus {
    
    /**
     * The HTLC is waiting for the preimage to be shared by the receiver
     */
    case waitingForPreimage
    /**
     * The HTLC preimage has been shared and the transfer can be or has been claimed by the receiver
     */
    case preimageShared
    /**
     * The HTLC has been returned to the sender due to expiry
     */
    case returned
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkHtlcStatus: FfiConverterRustBuffer {
    typealias SwiftType = SparkHtlcStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkHtlcStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .waitingForPreimage
        
        case 2: return .preimageShared
        
        case 3: return .returned
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparkHtlcStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .waitingForPreimage:
            writeInt(&buf, Int32(1))
        
        
        case .preimageShared:
            writeInt(&buf, Int32(2))
        
        
        case .returned:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcStatus_lift(_ buf: RustBuffer) throws -> SparkHtlcStatus {
    return try FfiConverterTypeSparkHtlcStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcStatus_lower(_ value: SparkHtlcStatus) -> RustBuffer {
    return FfiConverterTypeSparkHtlcStatus.lower(value)
}



extension SparkHtlcStatus: Equatable, Hashable {}




/**
 * Errors that can occur during storage operations
 */
public enum StorageError {

    
    
    case Implementation(String
    )
    /**
     * Database initialization error
     */
    case InitializationError(String
    )
    case Serialization(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageError: FfiConverterRustBuffer {
    typealias SwiftType = StorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Implementation(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InitializationError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Implementation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InitializationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension StorageError: Equatable, Hashable {}

extension StorageError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported success action types
 *
 * Receiving any other (unsupported) success action type will result in a failed parsing,
 * which will abort the LNURL-pay workflow, as per LUD-09.
 */

public enum SuccessAction {
    
    /**
     * AES type, described in LUD-10
     */
    case aes(data: AesSuccessActionData
    )
    /**
     * Message type, described in LUD-09
     */
    case message(data: MessageSuccessActionData
    )
    /**
     * URL type, described in LUD-09
     */
    case url(data: UrlSuccessActionData
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSuccessAction: FfiConverterRustBuffer {
    typealias SwiftType = SuccessAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .aes(data: try FfiConverterTypeAesSuccessActionData.read(from: &buf)
        )
        
        case 2: return .message(data: try FfiConverterTypeMessageSuccessActionData.read(from: &buf)
        )
        
        case 3: return .url(data: try FfiConverterTypeUrlSuccessActionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .aes(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionData.write(data, into: &buf)
            
        
        case let .message(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(data, into: &buf)
            
        
        case let .url(data):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(data, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessAction_lift(_ buf: RustBuffer) throws -> SuccessAction {
    return try FfiConverterTypeSuccessAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessAction_lower(_ value: SuccessAction) -> RustBuffer {
    return FfiConverterTypeSuccessAction.lower(value)
}



extension SuccessAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * [`SuccessAction`] where contents are ready to be consumed by the caller
 *
 * Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
 */

public enum SuccessActionProcessed {
    
    /**
     * See [`SuccessAction::Aes`] for received payload
     *
     * See [`AesSuccessActionDataDecrypted`] for decrypted payload
     */
    case aes(result: AesSuccessActionDataResult
    )
    /**
     * See [`SuccessAction::Message`]
     */
    case message(data: MessageSuccessActionData
    )
    /**
     * See [`SuccessAction::Url`]
     */
    case url(data: UrlSuccessActionData
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessActionProcessed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .aes(result: try FfiConverterTypeAesSuccessActionDataResult.read(from: &buf)
        )
        
        case 2: return .message(data: try FfiConverterTypeMessageSuccessActionData.read(from: &buf)
        )
        
        case 3: return .url(data: try FfiConverterTypeUrlSuccessActionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessActionProcessed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .aes(result):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataResult.write(result, into: &buf)
            
        
        case let .message(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(data, into: &buf)
            
        
        case let .url(data):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(data, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessActionProcessed_lift(_ buf: RustBuffer) throws -> SuccessActionProcessed {
    return try FfiConverterTypeSuccessActionProcessed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessActionProcessed_lower(_ value: SuccessActionProcessed) -> RustBuffer {
    return FfiConverterTypeSuccessActionProcessed.lower(value)
}



extension SuccessActionProcessed: Equatable, Hashable {}




/**
 * Errors that can occur during storage operations
 */
public enum SyncStorageError {

    
    
    case Implementation(String
    )
    /**
     * Database initialization error
     */
    case InitializationError(String
    )
    case Serialization(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncStorageError: FfiConverterRustBuffer {
    typealias SwiftType = SyncStorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncStorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Implementation(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InitializationError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SyncStorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Implementation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InitializationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension SyncStorageError: Equatable, Hashable {}

extension SyncStorageError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UpdateDepositPayload {
    
    case claimError(error: DepositClaimError
    )
    case refund(refundTxid: String, refundTx: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateDepositPayload: FfiConverterRustBuffer {
    typealias SwiftType = UpdateDepositPayload

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateDepositPayload {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .claimError(error: try FfiConverterTypeDepositClaimError.read(from: &buf)
        )
        
        case 2: return .refund(refundTxid: try FfiConverterString.read(from: &buf), refundTx: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UpdateDepositPayload, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .claimError(error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDepositClaimError.write(error, into: &buf)
            
        
        case let .refund(refundTxid,refundTx):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(refundTxid, into: &buf)
            FfiConverterString.write(refundTx, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateDepositPayload_lift(_ buf: RustBuffer) throws -> UpdateDepositPayload {
    return try FfiConverterTypeUpdateDepositPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateDepositPayload_lower(_ value: UpdateDepositPayload) -> RustBuffer {
    return FfiConverterTypeUpdateDepositPayload.lower(value)
}



extension UpdateDepositPayload: Equatable, Hashable {}






/**
 * Trait for event listeners
 */
public protocol EventListener : AnyObject {
    
    /**
     * Called when an event occurs
     */
    func onEvent(event: SdkEvent) async 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEventListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEventListener = UniffiVTableCallbackInterfaceEventListener(
        onEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.onEvent(
                     event: try FfiConverterTypeSdkEvent.lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceEventListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EventListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEventListener() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(&UniffiCallbackInterfaceEventListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceEventListener {
    fileprivate static var handleMap = UniffiHandleMap<EventListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceEventListener : FfiConverter {
    typealias SwiftType = EventListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol Logger : AnyObject {
    
    func log(l: LogEntry) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogger {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLogger = UniffiVTableCallbackInterfaceLogger(
        log: { (
            uniffiHandle: UInt64,
            l: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.log(
                     l: try FfiConverterTypeLogEntry.lift(l)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Logger: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLogger() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(&UniffiCallbackInterfaceLogger.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLogger {
    fileprivate static var handleMap = UniffiHandleMap<Logger>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLogger : FfiConverter {
    typealias SwiftType = Logger
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCredentials: FfiConverterRustBuffer {
    typealias SwiftType = Credentials?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredentials.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredentials.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLightningAddressInfo: FfiConverterRustBuffer {
    typealias SwiftType = LightningAddressInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLightningAddressInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLightningAddressInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlPayInfo: FfiConverterRustBuffer {
    typealias SwiftType = LnurlPayInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlPayInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlPayInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlReceiveMetadata: FfiConverterRustBuffer {
    typealias SwiftType = LnurlReceiveMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlReceiveMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlReceiveMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlWithdrawInfo: FfiConverterRustBuffer {
    typealias SwiftType = LnurlWithdrawInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlWithdrawInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlWithdrawInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeOutgoingChange: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingChange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutgoingChange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutgoingChange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = Payment?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePayment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePayment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRecord: FfiConverterRustBuffer {
    typealias SwiftType = Record?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRecord.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRecord.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkHtlcDetails: FfiConverterRustBuffer {
    typealias SwiftType = SparkHtlcDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkHtlcDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkHtlcDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkHtlcOptions: FfiConverterRustBuffer {
    typealias SwiftType = SparkHtlcOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkHtlcOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkHtlcOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkInvoicePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = SparkInvoicePaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkInvoicePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkInvoicePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSymbol: FfiConverterRustBuffer {
    typealias SwiftType = Symbol?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSymbol.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSymbol.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAssetFilter: FfiConverterRustBuffer {
    typealias SwiftType = AssetFilter?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAssetFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAssetFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDepositClaimError: FfiConverterRustBuffer {
    typealias SwiftType = DepositClaimError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDepositClaimError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDepositClaimError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFee: FfiConverterRustBuffer {
    typealias SwiftType = Fee?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFee.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFee.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSendPaymentOptions: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendPaymentOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendPaymentOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessAction: FfiConverterRustBuffer {
    typealias SwiftType = SuccessAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessActionProcessed.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessActionProcessed.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceLogger: FfiConverterRustBuffer {
    typealias SwiftType = Logger?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceLogger.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceLogger.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeExternalInputParser: FfiConverterRustBuffer {
    typealias SwiftType = [ExternalInputParser]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeExternalInputParser.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeExternalInputParser.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentStatus]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePaymentStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePaymentStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentType]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePaymentType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePaymentType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeSparkHtlcStatus: FfiConverterRustBuffer {
    typealias SwiftType = [SparkHtlcStatus]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeSparkHtlcStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeSparkHtlcStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeu128: FfiConverterRustBuffer {
    typealias SwiftType = U128?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeu128.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeu128.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBip21Extra: FfiConverterRustBuffer {
    typealias SwiftType = [Bip21Extra]

    public static func write(_ value: [Bip21Extra], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBip21Extra.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip21Extra] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip21Extra]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBip21Extra.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt11RouteHint: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt11RouteHint]

    public static func write(_ value: [Bolt11RouteHint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt11RouteHint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt11RouteHint] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt11RouteHint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt11RouteHint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt11RouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt11RouteHintHop]

    public static func write(_ value: [Bolt11RouteHintHop], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt11RouteHintHop.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt11RouteHintHop] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt11RouteHintHop]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt11RouteHintHop.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt12OfferBlindedPath: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt12OfferBlindedPath]

    public static func write(_ value: [Bolt12OfferBlindedPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt12OfferBlindedPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt12OfferBlindedPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt12OfferBlindedPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt12OfferBlindedPath.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDepositInfo: FfiConverterRustBuffer {
    typealias SwiftType = [DepositInfo]

    public static func write(_ value: [DepositInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDepositInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DepositInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [DepositInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDepositInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeExternalInputParser: FfiConverterRustBuffer {
    typealias SwiftType = [ExternalInputParser]

    public static func write(_ value: [ExternalInputParser], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExternalInputParser.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ExternalInputParser] {
        let len: Int32 = try readInt(&buf)
        var seq = [ExternalInputParser]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeExternalInputParser.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = [FiatCurrency]

    public static func write(_ value: [FiatCurrency], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFiatCurrency.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FiatCurrency] {
        let len: Int32 = try readInt(&buf)
        var seq = [FiatCurrency]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFiatCurrency.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIncomingChange: FfiConverterRustBuffer {
    typealias SwiftType = [IncomingChange]

    public static func write(_ value: [IncomingChange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIncomingChange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IncomingChange] {
        let len: Int32 = try readInt(&buf)
        var seq = [IncomingChange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIncomingChange.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]

    public static func write(_ value: [LocaleOverrides], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocaleOverrides.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocaleOverrides] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocaleOverrides]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocaleOverrides.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]

    public static func write(_ value: [LocalizedName], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalizedName.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalizedName] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalizedName]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalizedName.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOutgoingChange: FfiConverterRustBuffer {
    typealias SwiftType = [OutgoingChange]

    public static func write(_ value: [OutgoingChange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutgoingChange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutgoingChange] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutgoingChange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutgoingChange.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeProvisionalPayment: FfiConverterRustBuffer {
    typealias SwiftType = [ProvisionalPayment]

    public static func write(_ value: [ProvisionalPayment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProvisionalPayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProvisionalPayment] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProvisionalPayment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeProvisionalPayment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRate: FfiConverterRustBuffer {
    typealias SwiftType = [Rate]

    public static func write(_ value: [Rate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Rate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Rate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRecord: FfiConverterRustBuffer {
    typealias SwiftType = [Record]

    public static func write(_ value: [Record], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Record] {
        let len: Int32 = try readInt(&buf)
        var seq = [Record]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRecord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSetLnurlMetadataItem: FfiConverterRustBuffer {
    typealias SwiftType = [SetLnurlMetadataItem]

    public static func write(_ value: [SetLnurlMetadataItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSetLnurlMetadataItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SetLnurlMetadataItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [SetLnurlMetadataItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSetLnurlMetadataItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTokenMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [TokenMetadata]

    public static func write(_ value: [TokenMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTokenMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TokenMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [TokenMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTokenMetadata.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [Utxo]

    public static func write(_ value: [Utxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUtxo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Utxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [Utxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUtxo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = [InputType]

    public static func write(_ value: [InputType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInputType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [InputType] {
        let len: Int32 = try readInt(&buf)
        var seq = [InputType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInputType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentStatus]

    public static func write(_ value: [PaymentStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentStatus.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentStatus] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentStatus]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentStatus.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentType]

    public static func write(_ value: [PaymentType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentType] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSparkHtlcStatus: FfiConverterRustBuffer {
    typealias SwiftType = [SparkHtlcStatus]

    public static func write(_ value: [SparkHtlcStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparkHtlcStatus.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparkHtlcStatus] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparkHtlcStatus]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparkHtlcStatus.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeTokenBalance: FfiConverterRustBuffer {
    public static func write(_ value: [String: TokenBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeTokenBalance.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: TokenBalance] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: TokenBalance]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeTokenBalance.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}




/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias U128 = BInt


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeu128: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U128 {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return BInt(builtinValue)!
    }

    public static func write(_ value: U128, into buf: inout [UInt8]) {
        let builtinValue = value.asString(radix: 10)
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> U128 {
        let builtinValue = try FfiConverterString.lift(value)
        return BInt(builtinValue)!
    }

    public static func lower(_ value: U128) -> RustBuffer {
        let builtinValue = value.asString(radix: 10)
        return FfiConverterString.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeu128_lift(_ value: RustBuffer) throws -> U128 {
    return try FfiConverterTypeu128.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeu128_lower(_ value: U128) -> RustBuffer {
    return FfiConverterTypeu128.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountBreezSdkSpark() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
/**
 * Connects to the Spark network using the provided configuration and mnemonic.
 *
 * # Arguments
 *
 * * `request` - The connection request object
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */
public func connect(request: ConnectRequest)async throws  -> BreezSdk {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_func_connect(FfiConverterTypeConnectRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBreezSdk.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
public func defaultConfig(network: Network) -> Config {
    return try!  FfiConverterTypeConfig.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_func_default_config(
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
public func initLogging(logDir: String?, appLogger: Logger?, logFilter: String?)throws  {try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_func_init_logging(
        FfiConverterOptionString.lower(logDir),
        FfiConverterOptionCallbackInterfaceLogger.lower(appLogger),
        FfiConverterOptionString.lower(logFilter),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_breez_sdk_spark_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_connect() != 40345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_config() != 62194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_init_logging() != 8518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos() != 20959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status() != 23018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex() != 59376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction() != 65179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees() != 43230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener() != 37737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available() != 31624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message() != 4385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit() != 43529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment() != 57587) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address() != 44132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect() != 330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info() != 6771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address() != 36552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment() != 11540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer() != 26649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata() != 40125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings() != 38537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies() != 63366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates() != 5904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments() != 16156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits() != 22486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay() != 10147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw() != 45652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_parse() != 14285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay() != 37691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment() != 34185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment() != 36984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees() != 16947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit() != 33646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address() != 530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener() != 41066) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment() != 54349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message() != 57563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet() != 30368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings() != 1721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies() != 19092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates() != 11512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send() != 30686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_restclient_get_request() != 8260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_restclient_post_request() != 24889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_restclient_delete_request() != 51072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build() != 8126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service() != 2848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage() != 14543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service() != 37854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set() != 42926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client() != 51060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer() != 21617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage() != 20579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service() != 63155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage() != 59400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item() != 6883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item() != 30248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item() != 7970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_list_payments() != 19728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_insert_payment() != 28075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata() != 45500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id() != 35394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice() != 57075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_add_deposit() != 60240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit() != 60586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_list_deposits() != 54118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_update_deposit() != 39803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata() != 7460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_add_outgoing_change() != 19087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_complete_outgoing_sync() != 20071) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_get_pending_outgoing_changes() != 23473) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_get_last_revision() != 36887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_insert_incoming_records() != 41782) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_delete_incoming_record() != 23002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_rebase_pending_outgoing_records() != 61508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_get_incoming_records() != 53552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_get_latest_outgoing_change() != 16326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_syncstorage_update_record_from_incoming() != 9986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token() != 56056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token() != 33277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token() != 32344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance() != 9758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata() != 57707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token() != 36459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token() != 65025) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new() != 65435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event() != 24807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_logger_log() != 11839) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitBitcoinChainService()
    uniffiCallbackInitFiatService()
    uniffiCallbackInitPaymentObserver()
    uniffiCallbackInitRestClient()
    uniffiCallbackInitStorage()
    uniffiCallbackInitSyncStorage()
    uniffiCallbackInitEventListener()
    uniffiCallbackInitLogger()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all