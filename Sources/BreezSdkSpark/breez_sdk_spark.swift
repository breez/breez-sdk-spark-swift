// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(breez_sdk_sparkFFI)
import breez_sdk_sparkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_breez_sdk_spark_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_breez_sdk_spark_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol BitcoinChainService : AnyObject {
    
    func getAddressUtxos(address: String) async throws  -> [Utxo]
    
    func getTransactionHex(txid: String) async throws  -> String
    
    func broadcastTransaction(tx: String) async throws 
    
}

open class BitcoinChainServiceImpl:
    BitcoinChainService {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(pointer, $0) }
    }

    

    
open func getAddressUtxos(address: String)async throws  -> [Utxo] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(address)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUtxo.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func getTransactionHex(txid: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func broadcastTransaction(tx: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(tx)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBitcoinChainService {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBitcoinChainService = UniffiVTableCallbackInterfaceBitcoinChainService(
        getAddressUtxos: { (
            uniffiHandle: UInt64,
            address: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Utxo] in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getAddressUtxos(
                     address: try FfiConverterString.lift(address)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Utxo]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeUtxo.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getTransactionHex: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getTransactionHex(
                     txid: try FfiConverterString.lift(txid)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        broadcastTransaction: { (
            uniffiHandle: UInt64,
            tx: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.broadcastTransaction(
                     tx: try FfiConverterString.lift(tx)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeBitcoinChainService.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BitcoinChainService: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBitcoinChainService() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(&UniffiCallbackInterfaceBitcoinChainService.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinChainService: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<BitcoinChainService>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BitcoinChainService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinChainService {
        return BitcoinChainServiceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BitcoinChainService) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinChainService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BitcoinChainService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinChainService_lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinChainService {
    return try FfiConverterTypeBitcoinChainService.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinChainService_lower(_ value: BitcoinChainService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBitcoinChainService.lower(value)
}




/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
public protocol BreezSdkProtocol : AnyObject {
    
    /**
     * Registers a listener to receive SDK events
     *
     * # Arguments
     *
     * * `listener` - An implementation of the `EventListener` trait
     *
     * # Returns
     *
     * A unique identifier for the listener, which can be used to remove it later
     */
    func addEventListener(listener: EventListener)  -> String
    
    func claimDeposit(request: ClaimDepositRequest) async throws  -> ClaimDepositResponse
    
    /**
     * Stops the SDK's background tasks
     *
     * This method stops the background tasks started by the `start()` method.
     * It should be called before your application terminates to ensure proper cleanup.
     *
     * # Returns
     *
     * Result containing either success or an `SdkError` if the background task couldn't be stopped
     */
    func disconnect() throws 
    
    /**
     * Returns the balance of the wallet in satoshis
     */
    func getInfo(request: GetInfoRequest) async throws  -> GetInfoResponse
    
    func getPayment(request: GetPaymentRequest) async throws  -> GetPaymentResponse
    
    /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
    func listPayments(request: ListPaymentsRequest) async throws  -> ListPaymentsResponse
    
    func listUnclaimedDeposits(request: ListUnclaimedDepositsRequest) async throws  -> ListUnclaimedDepositsResponse
    
    func lnurlPay(request: LnurlPayRequest) async throws  -> LnurlPayResponse
    
    func pollLightningSendPayment(paymentId: String) 
    
    func prepareLnurlPay(request: PrepareLnurlPayRequest) async throws  -> PrepareLnurlPayResponse
    
    func prepareSendPayment(request: PrepareSendPaymentRequest) async throws  -> PrepareSendPaymentResponse
    
    func receivePayment(request: ReceivePaymentRequest) async throws  -> ReceivePaymentResponse
    
    func refundDeposit(request: RefundDepositRequest) async throws  -> RefundDepositResponse
    
    /**
     * Removes a previously registered event listener
     *
     * # Arguments
     *
     * * `id` - The listener ID returned from `add_event_listener`
     *
     * # Returns
     *
     * `true` if the listener was found and removed, `false` otherwise
     */
    func removeEventListener(id: String)  -> Bool
    
    func sendPayment(request: SendPaymentRequest) async throws  -> SendPaymentResponse
    
    func sendPaymentInternal(request: SendPaymentRequest, suppressPaymentEvent: Bool) async throws  -> SendPaymentResponse
    
    /**
     * Synchronizes the wallet with the Spark network
     */
    func syncWallet(request: SyncWalletRequest) throws  -> SyncWalletResponse
    
}

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
open class BreezSdk:
    BreezSdkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_breezsdk(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_breezsdk(pointer, $0) }
    }

    

    
    /**
     * Registers a listener to receive SDK events
     *
     * # Arguments
     *
     * * `listener` - An implementation of the `EventListener` trait
     *
     * # Returns
     *
     * A unique identifier for the listener, which can be used to remove it later
     */
open func addEventListener(listener: EventListener) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(self.uniffiClonePointer(),
        FfiConverterCallbackInterfaceEventListener.lower(listener),$0
    )
})
}
    
open func claimDeposit(request: ClaimDepositRequest)async throws  -> ClaimDepositResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClaimDepositRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeClaimDepositResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Stops the SDK's background tasks
     *
     * This method stops the background tasks started by the `start()` method.
     * It should be called before your application terminates to ensure proper cleanup.
     *
     * # Returns
     *
     * Result containing either success or an `SdkError` if the background task couldn't be stopped
     */
open func disconnect()throws  {try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Returns the balance of the wallet in satoshis
     */
open func getInfo(request: GetInfoRequest)async throws  -> GetInfoResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetInfoRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetInfoResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func getPayment(request: GetPaymentRequest)async throws  -> GetPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
open func listPayments(request: ListPaymentsRequest)async throws  -> ListPaymentsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListPaymentsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListPaymentsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func listUnclaimedDeposits(request: ListUnclaimedDepositsRequest)async throws  -> ListUnclaimedDepositsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListUnclaimedDepositsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListUnclaimedDepositsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func lnurlPay(request: LnurlPayRequest)async throws  -> LnurlPayResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLnurlPayRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLnurlPayResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func pollLightningSendPayment(paymentId: String) {try! rustCall() {
    uniffi_breez_sdk_spark_fn_method_breezsdk_poll_lightning_send_payment(self.uniffiClonePointer(),
        FfiConverterString.lower(paymentId),$0
    )
}
}
    
open func prepareLnurlPay(request: PrepareLnurlPayRequest)async throws  -> PrepareLnurlPayResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrepareLnurlPayRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrepareLnurlPayResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func prepareSendPayment(request: PrepareSendPaymentRequest)async throws  -> PrepareSendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrepareSendPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrepareSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func receivePayment(request: ReceivePaymentRequest)async throws  -> ReceivePaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReceivePaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReceivePaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func refundDeposit(request: RefundDepositRequest)async throws  -> RefundDepositResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRefundDepositRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRefundDepositResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Removes a previously registered event listener
     *
     * # Arguments
     *
     * * `id` - The listener ID returned from `add_event_listener`
     *
     * # Returns
     *
     * `true` if the listener was found and removed, `false` otherwise
     */
open func removeEventListener(id: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
})
}
    
open func sendPayment(request: SendPaymentRequest)async throws  -> SendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func sendPaymentInternal(request: SendPaymentRequest, suppressPaymentEvent: Bool)async throws  -> SendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment_internal(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendPaymentRequest.lower(request),FfiConverterBool.lower(suppressPaymentEvent)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Synchronizes the wallet with the Spark network
     */
open func syncWallet(request: SyncWalletRequest)throws  -> SyncWalletResponse {
    return try  FfiConverterTypeSyncWalletResponse.lift(try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(self.uniffiClonePointer(),
        FfiConverterTypeSyncWalletRequest.lower(request),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBreezSdk: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BreezSdk

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BreezSdk {
        return BreezSdk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BreezSdk) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezSdk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BreezSdk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdk_lift(_ pointer: UnsafeMutableRawPointer) throws -> BreezSdk {
    return try FfiConverterTypeBreezSdk.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdk_lower(_ value: BreezSdk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBreezSdk.lower(value)
}




/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
public protocol SdkBuilderProtocol : AnyObject {
    
    /**
     * Builds the `BreezSdk` instance with the configured components.
     */
    func build() async throws  -> BreezSdk
    
    /**
     * Sets the chain service to be used by the SDK.
     * Arguments:
     * - `chain_service`: The chain service to be used.
     */
    func withChainService(chainService: BitcoinChainService) async 
    
    func withLnurlClient(lnurlClient: RestClient) async 
    
    /**
     * Sets the REST chain service to be used by the SDK.
     * Arguments:
     * - `url`: The base URL of the REST API.
     * - `credentials`: Optional credentials for basic authentication.
     */
    func withRestChainService(url: String, credentials: Credentials?) async 
    
}

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
open class SdkBuilder:
    SdkBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_sdkbuilder(self.pointer, $0) }
    }
    /**
     * Creates a new `SdkBuilder` with the provided configuration.
     * Arguments:
     * - `config`: The configuration to be used.
     * - `mnemonic`: The mnemonic phrase for the wallet.
     * - `storage`: The storage backend to be used.
     */
public convenience init(config: Config, mnemonic: String, storage: Storage) {
    let pointer =
        try! rustCall() {
    uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
        FfiConverterTypeConfig.lower(config),
        FfiConverterString.lower(mnemonic),
        FfiConverterTypeStorage.lower(storage),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_sdkbuilder(pointer, $0) }
    }

    

    
    /**
     * Builds the `BreezSdk` instance with the configured components.
     */
open func build()async throws  -> BreezSdk {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBreezSdk.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Sets the chain service to be used by the SDK.
     * Arguments:
     * - `chain_service`: The chain service to be used.
     */
open func withChainService(chainService: BitcoinChainService)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBitcoinChainService.lower(chainService)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func withLnurlClient(lnurlClient: RestClient)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRestClient_lower(lnurlClient)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the REST chain service to be used by the SDK.
     * Arguments:
     * - `url`: The base URL of the REST API.
     * - `credentials`: Optional credentials for basic authentication.
     */
open func withRestChainService(url: String, credentials: Credentials?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionTypeCredentials.lower(credentials)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SdkBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SdkBuilder {
        return SdkBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SdkBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SdkBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SdkBuilder {
    return try FfiConverterTypeSdkBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkBuilder_lower(_ value: SdkBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSdkBuilder.lower(value)
}




/**
 * Trait for persistent storage
 */
public protocol Storage : AnyObject {
    
    func getCachedItem(key: String) async throws  -> String?
    
    func setCachedItem(key: String, value: String) async throws 
    
    /**
     * Lists payments with pagination
     *
     * # Arguments
     *
     * * `offset` - Number of records to skip
     * * `limit` - Maximum number of records to return
     *
     * # Returns
     *
     * A vector of payments or a `StorageError`
     */
    func listPayments(offset: UInt32?, limit: UInt32?) async throws  -> [Payment]
    
    /**
     * Inserts a payment into storage
     *
     * # Arguments
     *
     * * `payment` - The payment to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func insertPayment(payment: Payment) async throws 
    
    /**
     * Inserts payment metadata into storage
     *
     * # Arguments
     *
     * * `payment_id` - The ID of the payment
     * * `metadata` - The metadata to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func setPaymentMetadata(paymentId: String, metadata: PaymentMetadata) async throws 
    
    /**
     * Gets a payment by its ID
     * # Arguments
     *
     * * `id` - The ID of the payment to retrieve
     *
     * # Returns
     *
     * The payment if found or None if not found
     */
    func getPaymentById(id: String) async throws  -> Payment
    
    /**
     * Add a deposit to storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `amount_sats` - The amount of the deposit in sats
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func addDeposit(txid: String, vout: UInt32, amountSats: UInt64) async throws 
    
    /**
     * Removes an unclaimed deposit from storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func deleteDeposit(txid: String, vout: UInt32) async throws 
    
    /**
     * Lists all unclaimed deposits from storage
     * # Returns
     *
     * A vector of `DepositInfo` or a `StorageError`
     */
    func listDeposits() async throws  -> [DepositInfo]
    
    /**
     * Updates or inserts unclaimed deposit details
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `payload` - The payload for the update
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func updateDeposit(txid: String, vout: UInt32, payload: UpdateDepositPayload) async throws 
    
}

/**
 * Trait for persistent storage
 */
open class StorageImpl:
    Storage {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_storage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_storage(pointer, $0) }
    }

    

    
open func getCachedItem(key: String)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func setCachedItem(key: String, value: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key),FfiConverterString.lower(value)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Lists payments with pagination
     *
     * # Arguments
     *
     * * `offset` - Number of records to skip
     * * `limit` - Maximum number of records to return
     *
     * # Returns
     *
     * A vector of payments or a `StorageError`
     */
open func listPayments(offset: UInt32?, limit: UInt32?)async throws  -> [Payment] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_list_payments(
                    self.uniffiClonePointer(),
                    FfiConverterOptionUInt32.lower(offset),FfiConverterOptionUInt32.lower(limit)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Inserts a payment into storage
     *
     * # Arguments
     *
     * * `payment` - The payment to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func insertPayment(payment: Payment)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayment.lower(payment)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Inserts payment metadata into storage
     *
     * # Arguments
     *
     * * `payment_id` - The ID of the payment
     * * `metadata` - The metadata to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func setPaymentMetadata(paymentId: String, metadata: PaymentMetadata)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(paymentId),FfiConverterTypePaymentMetadata.lower(metadata)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Gets a payment by its ID
     * # Arguments
     *
     * * `id` - The ID of the payment to retrieve
     *
     * # Returns
     *
     * The payment if found or None if not found
     */
open func getPaymentById(id: String)async throws  -> Payment {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Add a deposit to storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `amount_sats` - The amount of the deposit in sats
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func addDeposit(txid: String, vout: UInt32, amountSats: UInt64)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterUInt64.lower(amountSats)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Removes an unclaimed deposit from storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func deleteDeposit(txid: String, vout: UInt32)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Lists all unclaimed deposits from storage
     * # Returns
     *
     * A vector of `DepositInfo` or a `StorageError`
     */
open func listDeposits()async throws  -> [DepositInfo] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeDepositInfo.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Updates or inserts unclaimed deposit details
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `payload` - The payload for the update
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func updateDeposit(txid: String, vout: UInt32, payload: UpdateDepositPayload)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterTypeUpdateDepositPayload.lower(payload)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceStorage {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceStorage = UniffiVTableCallbackInterfaceStorage(
        getCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String? in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getCachedItem(
                     key: try FfiConverterString.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setCachedItem(
                     key: try FfiConverterString.lift(key),
                     value: try FfiConverterString.lift(value)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listPayments: { (
            uniffiHandle: UInt64,
            offset: RustBuffer,
            limit: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Payment] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listPayments(
                     offset: try FfiConverterOptionUInt32.lift(offset),
                     limit: try FfiConverterOptionUInt32.lift(limit)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Payment]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        insertPayment: { (
            uniffiHandle: UInt64,
            payment: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.insertPayment(
                     payment: try FfiConverterTypePayment.lift(payment)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setPaymentMetadata: { (
            uniffiHandle: UInt64,
            paymentId: RustBuffer,
            metadata: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setPaymentMetadata(
                     paymentId: try FfiConverterString.lift(paymentId),
                     metadata: try FfiConverterTypePaymentMetadata.lift(metadata)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPaymentById: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Payment in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPaymentById(
                     id: try FfiConverterString.lift(id)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Payment) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        addDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            amountSats: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.addDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout),
                     amountSats: try FfiConverterUInt64.lift(amountSats)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listDeposits: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [DepositInfo] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listDeposits(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [DepositInfo]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeDepositInfo.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        updateDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            payload: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.updateDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout),
                     payload: try FfiConverterTypeUpdateDepositPayload.lift(payload)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Storage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitStorage() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(&UniffiCallbackInterfaceStorage.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<Storage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Storage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Storage {
        return StorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Storage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Storage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Storage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> Storage {
    return try FfiConverterTypeStorage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorage_lower(_ value: Storage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStorage.lower(value)
}


public struct ClaimDepositRequest {
    public var txid: String
    public var vout: UInt32
    public var maxFee: Fee?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, maxFee: Fee?) {
        self.txid = txid
        self.vout = vout
        self.maxFee = maxFee
    }
}



extension ClaimDepositRequest: Equatable, Hashable {
    public static func ==(lhs: ClaimDepositRequest, rhs: ClaimDepositRequest) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.maxFee != rhs.maxFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(maxFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimDepositRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimDepositRequest {
        return
            try ClaimDepositRequest(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                maxFee: FfiConverterOptionTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimDepositRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterOptionTypeFee.write(value.maxFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositRequest_lift(_ buf: RustBuffer) throws -> ClaimDepositRequest {
    return try FfiConverterTypeClaimDepositRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositRequest_lower(_ value: ClaimDepositRequest) -> RustBuffer {
    return FfiConverterTypeClaimDepositRequest.lower(value)
}


public struct ClaimDepositResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension ClaimDepositResponse: Equatable, Hashable {
    public static func ==(lhs: ClaimDepositResponse, rhs: ClaimDepositResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimDepositResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimDepositResponse {
        return
            try ClaimDepositResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimDepositResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositResponse_lift(_ buf: RustBuffer) throws -> ClaimDepositResponse {
    return try FfiConverterTypeClaimDepositResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositResponse_lower(_ value: ClaimDepositResponse) -> RustBuffer {
    return FfiConverterTypeClaimDepositResponse.lower(value)
}


public struct Config {
    public var apiKey: String?
    public var network: Network
    public var syncIntervalSecs: UInt32
    public var maxDepositClaimFee: Fee?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(apiKey: String?, network: Network, syncIntervalSecs: UInt32, maxDepositClaimFee: Fee?) {
        self.apiKey = apiKey
        self.network = network
        self.syncIntervalSecs = syncIntervalSecs
        self.maxDepositClaimFee = maxDepositClaimFee
    }
}



extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.apiKey != rhs.apiKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.syncIntervalSecs != rhs.syncIntervalSecs {
            return false
        }
        if lhs.maxDepositClaimFee != rhs.maxDepositClaimFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(apiKey)
        hasher.combine(network)
        hasher.combine(syncIntervalSecs)
        hasher.combine(maxDepositClaimFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                apiKey: FfiConverterOptionString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                syncIntervalSecs: FfiConverterUInt32.read(from: &buf), 
                maxDepositClaimFee: FfiConverterOptionTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.apiKey, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.syncIntervalSecs, into: &buf)
        FfiConverterOptionTypeFee.write(value.maxDepositClaimFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct Credentials {
    public var username: String
    public var password: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String, password: String) {
        self.username = username
        self.password = password
    }
}



extension Credentials: Equatable, Hashable {
    public static func ==(lhs: Credentials, rhs: Credentials) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentials: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Credentials {
        return
            try Credentials(
                username: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Credentials, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentials_lift(_ buf: RustBuffer) throws -> Credentials {
    return try FfiConverterTypeCredentials.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentials_lower(_ value: Credentials) -> RustBuffer {
    return FfiConverterTypeCredentials.lower(value)
}


public struct DepositInfo {
    public var txid: String
    public var vout: UInt32
    public var amountSats: UInt64
    public var refundTx: String?
    public var refundTxId: String?
    public var claimError: DepositClaimError?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, amountSats: UInt64, refundTx: String?, refundTxId: String?, claimError: DepositClaimError?) {
        self.txid = txid
        self.vout = vout
        self.amountSats = amountSats
        self.refundTx = refundTx
        self.refundTxId = refundTxId
        self.claimError = claimError
    }
}



extension DepositInfo: Equatable, Hashable {
    public static func ==(lhs: DepositInfo, rhs: DepositInfo) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.refundTx != rhs.refundTx {
            return false
        }
        if lhs.refundTxId != rhs.refundTxId {
            return false
        }
        if lhs.claimError != rhs.claimError {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(amountSats)
        hasher.combine(refundTx)
        hasher.combine(refundTxId)
        hasher.combine(claimError)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositInfo {
        return
            try DepositInfo(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                amountSats: FfiConverterUInt64.read(from: &buf), 
                refundTx: FfiConverterOptionString.read(from: &buf), 
                refundTxId: FfiConverterOptionString.read(from: &buf), 
                claimError: FfiConverterOptionTypeDepositClaimError.read(from: &buf)
        )
    }

    public static func write(_ value: DepositInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.refundTx, into: &buf)
        FfiConverterOptionString.write(value.refundTxId, into: &buf)
        FfiConverterOptionTypeDepositClaimError.write(value.claimError, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositInfo_lift(_ buf: RustBuffer) throws -> DepositInfo {
    return try FfiConverterTypeDepositInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositInfo_lower(_ value: DepositInfo) -> RustBuffer {
    return FfiConverterTypeDepositInfo.lower(value)
}


/**
 * Request to get the balance of the wallet
 */
public struct GetInfoRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension GetInfoRequest: Equatable, Hashable {
    public static func ==(lhs: GetInfoRequest, rhs: GetInfoRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoRequest {
        return
            GetInfoRequest()
    }

    public static func write(_ value: GetInfoRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoRequest_lift(_ buf: RustBuffer) throws -> GetInfoRequest {
    return try FfiConverterTypeGetInfoRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoRequest_lower(_ value: GetInfoRequest) -> RustBuffer {
    return FfiConverterTypeGetInfoRequest.lower(value)
}


/**
 * Response containing the balance of the wallet
 */
public struct GetInfoResponse {
    /**
     * The balance in satoshis
     */
    public var balanceSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The balance in satoshis
         */balanceSats: UInt64) {
        self.balanceSats = balanceSats
    }
}



extension GetInfoResponse: Equatable, Hashable {
    public static func ==(lhs: GetInfoResponse, rhs: GetInfoResponse) -> Bool {
        if lhs.balanceSats != rhs.balanceSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balanceSats)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoResponse {
        return
            try GetInfoResponse(
                balanceSats: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.balanceSats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lift(_ buf: RustBuffer) throws -> GetInfoResponse {
    return try FfiConverterTypeGetInfoResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lower(_ value: GetInfoResponse) -> RustBuffer {
    return FfiConverterTypeGetInfoResponse.lower(value)
}


public struct GetPaymentRequest {
    public var paymentId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentId: String) {
        self.paymentId = paymentId
    }
}



extension GetPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: GetPaymentRequest, rhs: GetPaymentRequest) -> Bool {
        if lhs.paymentId != rhs.paymentId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPaymentRequest {
        return
            try GetPaymentRequest(
                paymentId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GetPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentRequest_lift(_ buf: RustBuffer) throws -> GetPaymentRequest {
    return try FfiConverterTypeGetPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentRequest_lower(_ value: GetPaymentRequest) -> RustBuffer {
    return FfiConverterTypeGetPaymentRequest.lower(value)
}


public struct GetPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension GetPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: GetPaymentResponse, rhs: GetPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPaymentResponse {
        return
            try GetPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: GetPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentResponse_lift(_ buf: RustBuffer) throws -> GetPaymentResponse {
    return try FfiConverterTypeGetPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentResponse_lower(_ value: GetPaymentResponse) -> RustBuffer {
    return FfiConverterTypeGetPaymentResponse.lower(value)
}


/**
 * Request to list payments with pagination
 */
public struct ListPaymentsRequest {
    /**
     * Number of records to skip
     */
    public var offset: UInt32?
    /**
     * Maximum number of records to return
     */
    public var limit: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Number of records to skip
         */offset: UInt32?, 
        /**
         * Maximum number of records to return
         */limit: UInt32?) {
        self.offset = offset
        self.limit = limit
    }
}



extension ListPaymentsRequest: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsRequest, rhs: ListPaymentsRequest) -> Bool {
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(offset)
        hasher.combine(limit)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListPaymentsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsRequest {
        return
            try ListPaymentsRequest(
                offset: FfiConverterOptionUInt32.read(from: &buf), 
                limit: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsRequest, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.offset, into: &buf)
        FfiConverterOptionUInt32.write(value.limit, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsRequest_lift(_ buf: RustBuffer) throws -> ListPaymentsRequest {
    return try FfiConverterTypeListPaymentsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsRequest_lower(_ value: ListPaymentsRequest) -> RustBuffer {
    return FfiConverterTypeListPaymentsRequest.lower(value)
}


/**
 * Response from listing payments
 */
public struct ListPaymentsResponse {
    /**
     * The list of payments
     */
    public var payments: [Payment]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of payments
         */payments: [Payment]) {
        self.payments = payments
    }
}



extension ListPaymentsResponse: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsResponse, rhs: ListPaymentsResponse) -> Bool {
        if lhs.payments != rhs.payments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payments)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListPaymentsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsResponse {
        return
            try ListPaymentsResponse(
                payments: FfiConverterSequenceTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePayment.write(value.payments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsResponse_lift(_ buf: RustBuffer) throws -> ListPaymentsResponse {
    return try FfiConverterTypeListPaymentsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsResponse_lower(_ value: ListPaymentsResponse) -> RustBuffer {
    return FfiConverterTypeListPaymentsResponse.lower(value)
}


public struct ListUnclaimedDepositsRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension ListUnclaimedDepositsRequest: Equatable, Hashable {
    public static func ==(lhs: ListUnclaimedDepositsRequest, rhs: ListUnclaimedDepositsRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUnclaimedDepositsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUnclaimedDepositsRequest {
        return
            ListUnclaimedDepositsRequest()
    }

    public static func write(_ value: ListUnclaimedDepositsRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsRequest_lift(_ buf: RustBuffer) throws -> ListUnclaimedDepositsRequest {
    return try FfiConverterTypeListUnclaimedDepositsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsRequest_lower(_ value: ListUnclaimedDepositsRequest) -> RustBuffer {
    return FfiConverterTypeListUnclaimedDepositsRequest.lower(value)
}


public struct ListUnclaimedDepositsResponse {
    public var deposits: [DepositInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deposits: [DepositInfo]) {
        self.deposits = deposits
    }
}



extension ListUnclaimedDepositsResponse: Equatable, Hashable {
    public static func ==(lhs: ListUnclaimedDepositsResponse, rhs: ListUnclaimedDepositsResponse) -> Bool {
        if lhs.deposits != rhs.deposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deposits)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUnclaimedDepositsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUnclaimedDepositsResponse {
        return
            try ListUnclaimedDepositsResponse(
                deposits: FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ListUnclaimedDepositsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeDepositInfo.write(value.deposits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsResponse_lift(_ buf: RustBuffer) throws -> ListUnclaimedDepositsResponse {
    return try FfiConverterTypeListUnclaimedDepositsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsResponse_lower(_ value: ListUnclaimedDepositsResponse) -> RustBuffer {
    return FfiConverterTypeListUnclaimedDepositsResponse.lower(value)
}


/**
 * Represents the payment LNURL info
 */
public struct LnurlPayInfo {
    public var lnAddress: String?
    public var comment: String?
    public var domain: String?
    public var metadata: String?
    public var processedSuccessAction: SuccessActionProcessed?
    public var rawSuccessAction: SuccessAction?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lnAddress: String?, comment: String?, domain: String?, metadata: String?, processedSuccessAction: SuccessActionProcessed?, rawSuccessAction: SuccessAction?) {
        self.lnAddress = lnAddress
        self.comment = comment
        self.domain = domain
        self.metadata = metadata
        self.processedSuccessAction = processedSuccessAction
        self.rawSuccessAction = rawSuccessAction
    }
}



extension LnurlPayInfo: Equatable, Hashable {
    public static func ==(lhs: LnurlPayInfo, rhs: LnurlPayInfo) -> Bool {
        if lhs.lnAddress != rhs.lnAddress {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.processedSuccessAction != rhs.processedSuccessAction {
            return false
        }
        if lhs.rawSuccessAction != rhs.rawSuccessAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lnAddress)
        hasher.combine(comment)
        hasher.combine(domain)
        hasher.combine(metadata)
        hasher.combine(processedSuccessAction)
        hasher.combine(rawSuccessAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayInfo {
        return
            try LnurlPayInfo(
                lnAddress: FfiConverterOptionString.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                domain: FfiConverterOptionString.read(from: &buf), 
                metadata: FfiConverterOptionString.read(from: &buf), 
                processedSuccessAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf), 
                rawSuccessAction: FfiConverterOptionTypeSuccessAction.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.lnAddress, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterOptionString.write(value.domain, into: &buf)
        FfiConverterOptionString.write(value.metadata, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.processedSuccessAction, into: &buf)
        FfiConverterOptionTypeSuccessAction.write(value.rawSuccessAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayInfo_lift(_ buf: RustBuffer) throws -> LnurlPayInfo {
    return try FfiConverterTypeLnurlPayInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayInfo_lower(_ value: LnurlPayInfo) -> RustBuffer {
    return FfiConverterTypeLnurlPayInfo.lower(value)
}


public struct LnurlPayRequest {
    public var prepareResponse: PrepareLnurlPayResponse

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prepareResponse: PrepareLnurlPayResponse) {
        self.prepareResponse = prepareResponse
    }
}



extension LnurlPayRequest: Equatable, Hashable {
    public static func ==(lhs: LnurlPayRequest, rhs: LnurlPayRequest) -> Bool {
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prepareResponse)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayRequest {
        return
            try LnurlPayRequest(
                prepareResponse: FfiConverterTypePrepareLnurlPayResponse.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayRequest, into buf: inout [UInt8]) {
        FfiConverterTypePrepareLnurlPayResponse.write(value.prepareResponse, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequest_lift(_ buf: RustBuffer) throws -> LnurlPayRequest {
    return try FfiConverterTypeLnurlPayRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequest_lower(_ value: LnurlPayRequest) -> RustBuffer {
    return FfiConverterTypeLnurlPayRequest.lower(value)
}


public struct LnurlPayResponse {
    public var payment: Payment
    public var successAction: SuccessActionProcessed?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment, successAction: SuccessActionProcessed?) {
        self.payment = payment
        self.successAction = successAction
    }
}



extension LnurlPayResponse: Equatable, Hashable {
    public static func ==(lhs: LnurlPayResponse, rhs: LnurlPayResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        if lhs.successAction != rhs.successAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
        hasher.combine(successAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayResponse {
        return
            try LnurlPayResponse(
                payment: FfiConverterTypePayment.read(from: &buf), 
                successAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.successAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayResponse_lift(_ buf: RustBuffer) throws -> LnurlPayResponse {
    return try FfiConverterTypeLnurlPayResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayResponse_lower(_ value: LnurlPayResponse) -> RustBuffer {
    return FfiConverterTypeLnurlPayResponse.lower(value)
}


public struct LogEntry {
    public var line: String
    public var level: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(line: String, level: String) {
        self.line = line
        self.level = level
    }
}



extension LogEntry: Equatable, Hashable {
    public static func ==(lhs: LogEntry, rhs: LogEntry) -> Bool {
        if lhs.line != rhs.line {
            return false
        }
        if lhs.level != rhs.level {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(line)
        hasher.combine(level)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogEntry {
        return
            try LogEntry(
                line: FfiConverterString.read(from: &buf), 
                level: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LogEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.line, into: &buf)
        FfiConverterString.write(value.level, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogEntry_lift(_ buf: RustBuffer) throws -> LogEntry {
    return try FfiConverterTypeLogEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogEntry_lower(_ value: LogEntry) -> RustBuffer {
    return FfiConverterTypeLogEntry.lower(value)
}


/**
 * Represents a payment (sent or received)
 */
public struct Payment {
    /**
     * Unique identifier for the payment
     */
    public var id: String
    /**
     * Type of payment (send or receive)
     */
    public var paymentType: PaymentType
    /**
     * Status of the payment
     */
    public var status: PaymentStatus
    /**
     * Amount in satoshis
     */
    public var amount: UInt64
    /**
     * Fee paid in satoshis
     */
    public var fees: UInt64
    /**
     * Timestamp of when the payment was created
     */
    public var timestamp: UInt64
    /**
     * Method of payment. Sometimes the payment details is empty so this field
     * is used to determine the payment method.
     */
    public var method: PaymentMethod
    /**
     * Details of the payment
     */
    public var details: PaymentDetails?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for the payment
         */id: String, 
        /**
         * Type of payment (send or receive)
         */paymentType: PaymentType, 
        /**
         * Status of the payment
         */status: PaymentStatus, 
        /**
         * Amount in satoshis
         */amount: UInt64, 
        /**
         * Fee paid in satoshis
         */fees: UInt64, 
        /**
         * Timestamp of when the payment was created
         */timestamp: UInt64, 
        /**
         * Method of payment. Sometimes the payment details is empty so this field
         * is used to determine the payment method.
         */method: PaymentMethod, 
        /**
         * Details of the payment
         */details: PaymentDetails?) {
        self.id = id
        self.paymentType = paymentType
        self.status = status
        self.amount = amount
        self.fees = fees
        self.timestamp = timestamp
        self.method = method
        self.details = details
    }
}



extension Payment: Equatable, Hashable {
    public static func ==(lhs: Payment, rhs: Payment) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.paymentType != rhs.paymentType {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(paymentType)
        hasher.combine(status)
        hasher.combine(amount)
        hasher.combine(fees)
        hasher.combine(timestamp)
        hasher.combine(method)
        hasher.combine(details)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return
            try Payment(
                id: FfiConverterString.read(from: &buf), 
                paymentType: FfiConverterTypePaymentType.read(from: &buf), 
                status: FfiConverterTypePaymentStatus.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf), 
                fees: FfiConverterUInt64.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                method: FfiConverterTypePaymentMethod.read(from: &buf), 
                details: FfiConverterOptionTypePaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypePaymentType.write(value.paymentType, into: &buf)
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
        FfiConverterUInt64.write(value.fees, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterTypePaymentMethod.write(value.method, into: &buf)
        FfiConverterOptionTypePaymentDetails.write(value.details, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayment_lift(_ buf: RustBuffer) throws -> Payment {
    return try FfiConverterTypePayment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayment_lower(_ value: Payment) -> RustBuffer {
    return FfiConverterTypePayment.lower(value)
}


/**
 * Metadata associated with a payment that cannot be extracted from the Spark operator.
 */
public struct PaymentMetadata {
    public var lnurlPayInfo: LnurlPayInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lnurlPayInfo: LnurlPayInfo?) {
        self.lnurlPayInfo = lnurlPayInfo
    }
}



extension PaymentMetadata: Equatable, Hashable {
    public static func ==(lhs: PaymentMetadata, rhs: PaymentMetadata) -> Bool {
        if lhs.lnurlPayInfo != rhs.lnurlPayInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lnurlPayInfo)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMetadata {
        return
            try PaymentMetadata(
                lnurlPayInfo: FfiConverterOptionTypeLnurlPayInfo.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionTypeLnurlPayInfo.write(value.lnurlPayInfo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lift(_ buf: RustBuffer) throws -> PaymentMetadata {
    return try FfiConverterTypePaymentMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lower(_ value: PaymentMetadata) -> RustBuffer {
    return FfiConverterTypePaymentMetadata.lower(value)
}


public struct PrepareLnurlPayRequest {
    public var amountSats: UInt64
    public var comment: String?
    public var payRequest: LnurlPayRequestDetails
    public var validateSuccessActionUrl: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSats: UInt64, comment: String?, payRequest: LnurlPayRequestDetails, validateSuccessActionUrl: Bool?) {
        self.amountSats = amountSats
        self.comment = comment
        self.payRequest = payRequest
        self.validateSuccessActionUrl = validateSuccessActionUrl
    }
}



extension PrepareLnurlPayRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareLnurlPayRequest, rhs: PrepareLnurlPayRequest) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        if lhs.validateSuccessActionUrl != rhs.validateSuccessActionUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(comment)
        hasher.combine(payRequest)
        hasher.combine(validateSuccessActionUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareLnurlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareLnurlPayRequest {
        return
            try PrepareLnurlPayRequest(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf), 
                validateSuccessActionUrl: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareLnurlPayRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
        FfiConverterOptionBool.write(value.validateSuccessActionUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayRequest_lift(_ buf: RustBuffer) throws -> PrepareLnurlPayRequest {
    return try FfiConverterTypePrepareLnurlPayRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayRequest_lower(_ value: PrepareLnurlPayRequest) -> RustBuffer {
    return FfiConverterTypePrepareLnurlPayRequest.lower(value)
}


public struct PrepareLnurlPayResponse {
    public var amountSats: UInt64
    public var comment: String?
    public var payRequest: LnurlPayRequestDetails
    public var feeSats: UInt64
    public var invoiceDetails: Bolt11InvoiceDetails
    public var successAction: SuccessAction?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSats: UInt64, comment: String?, payRequest: LnurlPayRequestDetails, feeSats: UInt64, invoiceDetails: Bolt11InvoiceDetails, successAction: SuccessAction?) {
        self.amountSats = amountSats
        self.comment = comment
        self.payRequest = payRequest
        self.feeSats = feeSats
        self.invoiceDetails = invoiceDetails
        self.successAction = successAction
    }
}



extension PrepareLnurlPayResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareLnurlPayResponse, rhs: PrepareLnurlPayResponse) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        if lhs.feeSats != rhs.feeSats {
            return false
        }
        if lhs.invoiceDetails != rhs.invoiceDetails {
            return false
        }
        if lhs.successAction != rhs.successAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(comment)
        hasher.combine(payRequest)
        hasher.combine(feeSats)
        hasher.combine(invoiceDetails)
        hasher.combine(successAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareLnurlPayResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareLnurlPayResponse {
        return
            try PrepareLnurlPayResponse(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf), 
                feeSats: FfiConverterUInt64.read(from: &buf), 
                invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from: &buf), 
                successAction: FfiConverterOptionTypeSuccessAction.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareLnurlPayResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
        FfiConverterUInt64.write(value.feeSats, into: &buf)
        FfiConverterTypeBolt11InvoiceDetails.write(value.invoiceDetails, into: &buf)
        FfiConverterOptionTypeSuccessAction.write(value.successAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayResponse_lift(_ buf: RustBuffer) throws -> PrepareLnurlPayResponse {
    return try FfiConverterTypePrepareLnurlPayResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayResponse_lower(_ value: PrepareLnurlPayResponse) -> RustBuffer {
    return FfiConverterTypePrepareLnurlPayResponse.lower(value)
}


public struct PrepareSendPaymentRequest {
    public var paymentRequest: String
    public var amountSats: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentRequest: String, amountSats: UInt64?) {
        self.paymentRequest = paymentRequest
        self.amountSats = amountSats
    }
}



extension PrepareSendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareSendPaymentRequest, rhs: PrepareSendPaymentRequest) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(amountSats)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSendPaymentRequest {
        return
            try PrepareSendPaymentRequest(
                paymentRequest: FfiConverterString.read(from: &buf), 
                amountSats: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterOptionUInt64.write(value.amountSats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentRequest_lift(_ buf: RustBuffer) throws -> PrepareSendPaymentRequest {
    return try FfiConverterTypePrepareSendPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentRequest_lower(_ value: PrepareSendPaymentRequest) -> RustBuffer {
    return FfiConverterTypePrepareSendPaymentRequest.lower(value)
}


public struct PrepareSendPaymentResponse {
    public var paymentMethod: SendPaymentMethod
    public var amountSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentMethod: SendPaymentMethod, amountSats: UInt64) {
        self.paymentMethod = paymentMethod
        self.amountSats = amountSats
    }
}



extension PrepareSendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareSendPaymentResponse, rhs: PrepareSendPaymentResponse) -> Bool {
        if lhs.paymentMethod != rhs.paymentMethod {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentMethod)
        hasher.combine(amountSats)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSendPaymentResponse {
        return
            try PrepareSendPaymentResponse(
                paymentMethod: FfiConverterTypeSendPaymentMethod.read(from: &buf), 
                amountSats: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypeSendPaymentMethod.write(value.paymentMethod, into: &buf)
        FfiConverterUInt64.write(value.amountSats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentResponse_lift(_ buf: RustBuffer) throws -> PrepareSendPaymentResponse {
    return try FfiConverterTypePrepareSendPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentResponse_lower(_ value: PrepareSendPaymentResponse) -> RustBuffer {
    return FfiConverterTypePrepareSendPaymentResponse.lower(value)
}


public struct ReceivePaymentRequest {
    public var paymentMethod: ReceivePaymentMethod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentMethod: ReceivePaymentMethod) {
        self.paymentMethod = paymentMethod
    }
}



extension ReceivePaymentRequest: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentRequest, rhs: ReceivePaymentRequest) -> Bool {
        if lhs.paymentMethod != rhs.paymentMethod {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentMethod)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentRequest {
        return
            try ReceivePaymentRequest(
                paymentMethod: FfiConverterTypeReceivePaymentMethod.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypeReceivePaymentMethod.write(value.paymentMethod, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentRequest_lift(_ buf: RustBuffer) throws -> ReceivePaymentRequest {
    return try FfiConverterTypeReceivePaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentRequest_lower(_ value: ReceivePaymentRequest) -> RustBuffer {
    return FfiConverterTypeReceivePaymentRequest.lower(value)
}


public struct ReceivePaymentResponse {
    public var paymentRequest: String
    public var feeSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentRequest: String, feeSats: UInt64) {
        self.paymentRequest = paymentRequest
        self.feeSats = feeSats
    }
}



extension ReceivePaymentResponse: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentResponse, rhs: ReceivePaymentResponse) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.feeSats != rhs.feeSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(feeSats)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentResponse {
        return
            try ReceivePaymentResponse(
                paymentRequest: FfiConverterString.read(from: &buf), 
                feeSats: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterUInt64.write(value.feeSats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentResponse_lift(_ buf: RustBuffer) throws -> ReceivePaymentResponse {
    return try FfiConverterTypeReceivePaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentResponse_lower(_ value: ReceivePaymentResponse) -> RustBuffer {
    return FfiConverterTypeReceivePaymentResponse.lower(value)
}


public struct RefundDepositRequest {
    public var txid: String
    public var vout: UInt32
    public var destinationAddress: String
    public var fee: Fee

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, destinationAddress: String, fee: Fee) {
        self.txid = txid
        self.vout = vout
        self.destinationAddress = destinationAddress
        self.fee = fee
    }
}



extension RefundDepositRequest: Equatable, Hashable {
    public static func ==(lhs: RefundDepositRequest, rhs: RefundDepositRequest) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.destinationAddress != rhs.destinationAddress {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(destinationAddress)
        hasher.combine(fee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefundDepositRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundDepositRequest {
        return
            try RefundDepositRequest(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                destinationAddress: FfiConverterString.read(from: &buf), 
                fee: FfiConverterTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: RefundDepositRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterString.write(value.destinationAddress, into: &buf)
        FfiConverterTypeFee.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositRequest_lift(_ buf: RustBuffer) throws -> RefundDepositRequest {
    return try FfiConverterTypeRefundDepositRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositRequest_lower(_ value: RefundDepositRequest) -> RustBuffer {
    return FfiConverterTypeRefundDepositRequest.lower(value)
}


public struct RefundDepositResponse {
    public var txId: String
    public var txHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txId: String, txHex: String) {
        self.txId = txId
        self.txHex = txHex
    }
}



extension RefundDepositResponse: Equatable, Hashable {
    public static func ==(lhs: RefundDepositResponse, rhs: RefundDepositResponse) -> Bool {
        if lhs.txId != rhs.txId {
            return false
        }
        if lhs.txHex != rhs.txHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txId)
        hasher.combine(txHex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefundDepositResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundDepositResponse {
        return
            try RefundDepositResponse(
                txId: FfiConverterString.read(from: &buf), 
                txHex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RefundDepositResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txId, into: &buf)
        FfiConverterString.write(value.txHex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositResponse_lift(_ buf: RustBuffer) throws -> RefundDepositResponse {
    return try FfiConverterTypeRefundDepositResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositResponse_lower(_ value: RefundDepositResponse) -> RustBuffer {
    return FfiConverterTypeRefundDepositResponse.lower(value)
}


public struct SendOnchainFeeQuote {
    public var id: String
    public var expiresAt: UInt64
    public var speedFast: SendOnchainSpeedFeeQuote
    public var speedMedium: SendOnchainSpeedFeeQuote
    public var speedSlow: SendOnchainSpeedFeeQuote

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, expiresAt: UInt64, speedFast: SendOnchainSpeedFeeQuote, speedMedium: SendOnchainSpeedFeeQuote, speedSlow: SendOnchainSpeedFeeQuote) {
        self.id = id
        self.expiresAt = expiresAt
        self.speedFast = speedFast
        self.speedMedium = speedMedium
        self.speedSlow = speedSlow
    }
}



extension SendOnchainFeeQuote: Equatable, Hashable {
    public static func ==(lhs: SendOnchainFeeQuote, rhs: SendOnchainFeeQuote) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        if lhs.speedFast != rhs.speedFast {
            return false
        }
        if lhs.speedMedium != rhs.speedMedium {
            return false
        }
        if lhs.speedSlow != rhs.speedSlow {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(expiresAt)
        hasher.combine(speedFast)
        hasher.combine(speedMedium)
        hasher.combine(speedSlow)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendOnchainFeeQuote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainFeeQuote {
        return
            try SendOnchainFeeQuote(
                id: FfiConverterString.read(from: &buf), 
                expiresAt: FfiConverterUInt64.read(from: &buf), 
                speedFast: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf), 
                speedMedium: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf), 
                speedSlow: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainFeeQuote, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.expiresAt, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedFast, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedMedium, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedSlow, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainFeeQuote_lift(_ buf: RustBuffer) throws -> SendOnchainFeeQuote {
    return try FfiConverterTypeSendOnchainFeeQuote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainFeeQuote_lower(_ value: SendOnchainFeeQuote) -> RustBuffer {
    return FfiConverterTypeSendOnchainFeeQuote.lower(value)
}


public struct SendOnchainSpeedFeeQuote {
    public var userFeeSat: UInt64
    public var l1BroadcastFeeSat: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userFeeSat: UInt64, l1BroadcastFeeSat: UInt64) {
        self.userFeeSat = userFeeSat
        self.l1BroadcastFeeSat = l1BroadcastFeeSat
    }
}



extension SendOnchainSpeedFeeQuote: Equatable, Hashable {
    public static func ==(lhs: SendOnchainSpeedFeeQuote, rhs: SendOnchainSpeedFeeQuote) -> Bool {
        if lhs.userFeeSat != rhs.userFeeSat {
            return false
        }
        if lhs.l1BroadcastFeeSat != rhs.l1BroadcastFeeSat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userFeeSat)
        hasher.combine(l1BroadcastFeeSat)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendOnchainSpeedFeeQuote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainSpeedFeeQuote {
        return
            try SendOnchainSpeedFeeQuote(
                userFeeSat: FfiConverterUInt64.read(from: &buf), 
                l1BroadcastFeeSat: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainSpeedFeeQuote, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.userFeeSat, into: &buf)
        FfiConverterUInt64.write(value.l1BroadcastFeeSat, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainSpeedFeeQuote_lift(_ buf: RustBuffer) throws -> SendOnchainSpeedFeeQuote {
    return try FfiConverterTypeSendOnchainSpeedFeeQuote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainSpeedFeeQuote_lower(_ value: SendOnchainSpeedFeeQuote) -> RustBuffer {
    return FfiConverterTypeSendOnchainSpeedFeeQuote.lower(value)
}


public struct SendPaymentRequest {
    public var prepareResponse: PrepareSendPaymentResponse
    public var options: SendPaymentOptions?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prepareResponse: PrepareSendPaymentResponse, options: SendPaymentOptions?) {
        self.prepareResponse = prepareResponse
        self.options = options
    }
}



extension SendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: SendPaymentRequest, rhs: SendPaymentRequest) -> Bool {
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        if lhs.options != rhs.options {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prepareResponse)
        hasher.combine(options)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentRequest {
        return
            try SendPaymentRequest(
                prepareResponse: FfiConverterTypePrepareSendPaymentResponse.read(from: &buf), 
                options: FfiConverterOptionTypeSendPaymentOptions.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypePrepareSendPaymentResponse.write(value.prepareResponse, into: &buf)
        FfiConverterOptionTypeSendPaymentOptions.write(value.options, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentRequest_lift(_ buf: RustBuffer) throws -> SendPaymentRequest {
    return try FfiConverterTypeSendPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentRequest_lower(_ value: SendPaymentRequest) -> RustBuffer {
    return FfiConverterTypeSendPaymentRequest.lower(value)
}


public struct SendPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension SendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: SendPaymentResponse, rhs: SendPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentResponse {
        return
            try SendPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentResponse_lift(_ buf: RustBuffer) throws -> SendPaymentResponse {
    return try FfiConverterTypeSendPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentResponse_lower(_ value: SendPaymentResponse) -> RustBuffer {
    return FfiConverterTypeSendPaymentResponse.lower(value)
}


/**
 * Request to sync the wallet with the Spark network
 */
public struct SyncWalletRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension SyncWalletRequest: Equatable, Hashable {
    public static func ==(lhs: SyncWalletRequest, rhs: SyncWalletRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncWalletRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncWalletRequest {
        return
            SyncWalletRequest()
    }

    public static func write(_ value: SyncWalletRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletRequest_lift(_ buf: RustBuffer) throws -> SyncWalletRequest {
    return try FfiConverterTypeSyncWalletRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletRequest_lower(_ value: SyncWalletRequest) -> RustBuffer {
    return FfiConverterTypeSyncWalletRequest.lower(value)
}


/**
 * Response from synchronizing the wallet
 */
public struct SyncWalletResponse {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension SyncWalletResponse: Equatable, Hashable {
    public static func ==(lhs: SyncWalletResponse, rhs: SyncWalletResponse) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncWalletResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncWalletResponse {
        return
            SyncWalletResponse()
    }

    public static func write(_ value: SyncWalletResponse, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletResponse_lift(_ buf: RustBuffer) throws -> SyncWalletResponse {
    return try FfiConverterTypeSyncWalletResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletResponse_lower(_ value: SyncWalletResponse) -> RustBuffer {
    return FfiConverterTypeSyncWalletResponse.lower(value)
}


public struct TxStatus {
    public var confirmed: Bool
    public var blockHeight: UInt32?
    public var blockTime: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(confirmed: Bool, blockHeight: UInt32?, blockTime: UInt64?) {
        self.confirmed = confirmed
        self.blockHeight = blockHeight
        self.blockTime = blockTime
    }
}



extension TxStatus: Equatable, Hashable {
    public static func ==(lhs: TxStatus, rhs: TxStatus) -> Bool {
        if lhs.confirmed != rhs.confirmed {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.blockTime != rhs.blockTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(confirmed)
        hasher.combine(blockHeight)
        hasher.combine(blockTime)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxStatus {
        return
            try TxStatus(
                confirmed: FfiConverterBool.read(from: &buf), 
                blockHeight: FfiConverterOptionUInt32.read(from: &buf), 
                blockTime: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TxStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.confirmed, into: &buf)
        FfiConverterOptionUInt32.write(value.blockHeight, into: &buf)
        FfiConverterOptionUInt64.write(value.blockTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lift(_ buf: RustBuffer) throws -> TxStatus {
    return try FfiConverterTypeTxStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lower(_ value: TxStatus) -> RustBuffer {
    return FfiConverterTypeTxStatus.lower(value)
}


public struct Utxo {
    public var txid: String
    public var vout: UInt32
    public var value: UInt64
    public var status: TxStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, value: UInt64, status: TxStatus) {
        self.txid = txid
        self.vout = vout
        self.value = value
        self.status = status
    }
}



extension Utxo: Equatable, Hashable {
    public static func ==(lhs: Utxo, rhs: Utxo) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(value)
        hasher.combine(status)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Utxo {
        return
            try Utxo(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                value: FfiConverterUInt64.read(from: &buf), 
                status: FfiConverterTypeTxStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Utxo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.value, into: &buf)
        FfiConverterTypeTxStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lift(_ buf: RustBuffer) throws -> Utxo {
    return try FfiConverterTypeUtxo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lower(_ value: Utxo) -> RustBuffer {
    return FfiConverterTypeUtxo.lower(value)
}


public enum ChainServiceError {

    
    
    case InvalidAddress(String
    )
    case ServiceConnectivity(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainServiceError: FfiConverterRustBuffer {
    typealias SwiftType = ChainServiceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainServiceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidAddress(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ServiceConnectivity(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChainServiceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ServiceConnectivity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ChainServiceError: Equatable, Hashable {}

extension ChainServiceError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DepositClaimError {
    
    case depositClaimFeeExceeded(tx: String, vout: UInt32, maxFee: Fee, actualFee: UInt64
    )
    case missingUtxo(tx: String, vout: UInt32
    )
    case generic(message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositClaimError: FfiConverterRustBuffer {
    typealias SwiftType = DepositClaimError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositClaimError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .depositClaimFeeExceeded(tx: try FfiConverterString.read(from: &buf), vout: try FfiConverterUInt32.read(from: &buf), maxFee: try FfiConverterTypeFee.read(from: &buf), actualFee: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .missingUtxo(tx: try FfiConverterString.read(from: &buf), vout: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .generic(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositClaimError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .depositClaimFeeExceeded(tx,vout,maxFee,actualFee):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            FfiConverterTypeFee.write(maxFee, into: &buf)
            FfiConverterUInt64.write(actualFee, into: &buf)
            
        
        case let .missingUtxo(tx,vout):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            
        
        case let .generic(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositClaimError_lift(_ buf: RustBuffer) throws -> DepositClaimError {
    return try FfiConverterTypeDepositClaimError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositClaimError_lower(_ value: DepositClaimError) -> RustBuffer {
    return FfiConverterTypeDepositClaimError.lower(value)
}



extension DepositClaimError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Fee {
    
    case fixed(amount: UInt64
    )
    case rate(satPerVbyte: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFee: FfiConverterRustBuffer {
    typealias SwiftType = Fee

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fee {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fixed(amount: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .rate(satPerVbyte: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Fee, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fixed(amount):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amount, into: &buf)
            
        
        case let .rate(satPerVbyte):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(satPerVbyte, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lift(_ buf: RustBuffer) throws -> Fee {
    return try FfiConverterTypeFee.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lower(_ value: Fee) -> RustBuffer {
    return FfiConverterTypeFee.lower(value)
}



extension Fee: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case mainnet
    case regtest
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .regtest:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OnchainConfirmationSpeed {
    
    case fast
    case medium
    case slow
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnchainConfirmationSpeed: FfiConverterRustBuffer {
    typealias SwiftType = OnchainConfirmationSpeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainConfirmationSpeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fast
        
        case 2: return .medium
        
        case 3: return .slow
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OnchainConfirmationSpeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fast:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .slow:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainConfirmationSpeed_lift(_ buf: RustBuffer) throws -> OnchainConfirmationSpeed {
    return try FfiConverterTypeOnchainConfirmationSpeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainConfirmationSpeed_lower(_ value: OnchainConfirmationSpeed) -> RustBuffer {
    return FfiConverterTypeOnchainConfirmationSpeed.lower(value)
}



extension OnchainConfirmationSpeed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentDetails {
    
    case spark
    case lightning(
        /**
         * Represents the invoice description
         */description: String?, 
        /**
         * The preimage of the paid invoice (proof of payment).
         */preimage: String?, 
        /**
         * Represents the Bolt11/Bolt12 invoice associated with a payment
         * In the case of a Send payment, this is the invoice paid by the user
         * In the case of a Receive payment, this is the invoice paid to the user
         */invoice: String, 
        /**
         * The payment hash of the invoice
         */paymentHash: String, 
        /**
         * The invoice destination/payee pubkey
         */destinationPubkey: String, 
        /**
         * Lnurl payment information if this was an lnurl payment.
         */lnurlPayInfo: LnurlPayInfo?
    )
    case withdraw(txId: String
    )
    case deposit(txId: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .spark
        
        case 2: return .lightning(description: try FfiConverterOptionString.read(from: &buf), preimage: try FfiConverterOptionString.read(from: &buf), invoice: try FfiConverterString.read(from: &buf), paymentHash: try FfiConverterString.read(from: &buf), destinationPubkey: try FfiConverterString.read(from: &buf), lnurlPayInfo: try FfiConverterOptionTypeLnurlPayInfo.read(from: &buf)
        )
        
        case 3: return .withdraw(txId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .deposit(txId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .spark:
            writeInt(&buf, Int32(1))
        
        
        case let .lightning(description,preimage,invoice,paymentHash,destinationPubkey,lnurlPayInfo):
            writeInt(&buf, Int32(2))
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterOptionString.write(preimage, into: &buf)
            FfiConverterString.write(invoice, into: &buf)
            FfiConverterString.write(paymentHash, into: &buf)
            FfiConverterString.write(destinationPubkey, into: &buf)
            FfiConverterOptionTypeLnurlPayInfo.write(lnurlPayInfo, into: &buf)
            
        
        case let .withdraw(txId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(txId, into: &buf)
            
        
        case let .deposit(txId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(txId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}



extension PaymentDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentMethod {
    
    case lightning
    case spark
    case deposit
    case withdraw
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = PaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lightning
        
        case 2: return .spark
        
        case 3: return .deposit
        
        case 4: return .withdraw
        
        case 5: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lightning:
            writeInt(&buf, Int32(1))
        
        
        case .spark:
            writeInt(&buf, Int32(2))
        
        
        case .deposit:
            writeInt(&buf, Int32(3))
        
        
        case .withdraw:
            writeInt(&buf, Int32(4))
        
        
        case .unknown:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lift(_ buf: RustBuffer) throws -> PaymentMethod {
    return try FfiConverterTypePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lower(_ value: PaymentMethod) -> RustBuffer {
    return FfiConverterTypePaymentMethod.lower(value)
}



extension PaymentMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The status of a payment
 */

public enum PaymentStatus {
    
    /**
     * Payment is completed successfully
     */
    case completed
    /**
     * Payment is in progress
     */
    case pending
    /**
     * Payment has failed
     */
    case failed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .completed
        
        case 2: return .pending
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .completed:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}



extension PaymentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of payment
 */

public enum PaymentType {
    
    /**
     * Payment sent from this wallet
     */
    case send
    /**
     * Payment received to this wallet
     */
    case receive
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .send
        
        case 2: return .receive
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .send:
            writeInt(&buf, Int32(1))
        
        
        case .receive:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentType_lift(_ buf: RustBuffer) throws -> PaymentType {
    return try FfiConverterTypePaymentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentType_lower(_ value: PaymentType) -> RustBuffer {
    return FfiConverterTypePaymentType.lower(value)
}



extension PaymentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ReceivePaymentMethod {
    
    case sparkAddress
    case bitcoinAddress
    case bolt11Invoice(description: String, amountSats: UInt64?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = ReceivePaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sparkAddress
        
        case 2: return .bitcoinAddress
        
        case 3: return .bolt11Invoice(description: try FfiConverterString.read(from: &buf), amountSats: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceivePaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sparkAddress:
            writeInt(&buf, Int32(1))
        
        
        case .bitcoinAddress:
            writeInt(&buf, Int32(2))
        
        
        case let .bolt11Invoice(description,amountSats):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(description, into: &buf)
            FfiConverterOptionUInt64.write(amountSats, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentMethod_lift(_ buf: RustBuffer) throws -> ReceivePaymentMethod {
    return try FfiConverterTypeReceivePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentMethod_lower(_ value: ReceivePaymentMethod) -> RustBuffer {
    return FfiConverterTypeReceivePaymentMethod.lower(value)
}



extension ReceivePaymentMethod: Equatable, Hashable {}




/**
 * Error type for the `BreezSdk`
 */
public enum SdkError {

    
    
    case SparkError(String
    )
    case InvalidUuid(String
    )
    /**
     * Invalid input error
     */
    case InvalidInput(String
    )
    /**
     * Network error
     */
    case NetworkError(String
    )
    /**
     * Storage error
     */
    case StorageError(String
    )
    case ChainServiceError(String
    )
    case DepositClaimFeeExceeded(tx: String, vout: UInt32, maxFee: Fee, actualFee: UInt64
    )
    case MissingUtxo(tx: String, vout: UInt32
    )
    case LnurlError(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkError: FfiConverterRustBuffer {
    typealias SwiftType = SdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SparkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidUuid(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidInput(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .NetworkError(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .StorageError(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .ChainServiceError(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .DepositClaimFeeExceeded(
            tx: try FfiConverterString.read(from: &buf), 
            vout: try FfiConverterUInt32.read(from: &buf), 
            maxFee: try FfiConverterTypeFee.read(from: &buf), 
            actualFee: try FfiConverterUInt64.read(from: &buf)
            )
        case 8: return .MissingUtxo(
            tx: try FfiConverterString.read(from: &buf), 
            vout: try FfiConverterUInt32.read(from: &buf)
            )
        case 9: return .LnurlError(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SparkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidUuid(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidInput(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NetworkError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .StorageError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ChainServiceError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .DepositClaimFeeExceeded(tx,vout,maxFee,actualFee):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            FfiConverterTypeFee.write(maxFee, into: &buf)
            FfiConverterUInt64.write(actualFee, into: &buf)
            
        
        case let .MissingUtxo(tx,vout):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            
        
        case let .LnurlError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension SdkError: Equatable, Hashable {}

extension SdkError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Events emitted by the SDK
 */

public enum SdkEvent {
    
    /**
     * Emitted when the wallet has been synchronized with the network
     */
    case synced
    /**
     * Emitted when the wallet failed to claim some deposits
     */
    case claimDepositsFailed(unclaimedDeposits: [DepositInfo]
    )
    case claimDepositsSucceeded(claimedDeposits: [DepositInfo]
    )
    case paymentSucceeded(payment: Payment
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkEvent: FfiConverterRustBuffer {
    typealias SwiftType = SdkEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .synced
        
        case 2: return .claimDepositsFailed(unclaimedDeposits: try FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
        
        case 3: return .claimDepositsSucceeded(claimedDeposits: try FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
        
        case 4: return .paymentSucceeded(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .synced:
            writeInt(&buf, Int32(1))
        
        
        case let .claimDepositsFailed(unclaimedDeposits):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeDepositInfo.write(unclaimedDeposits, into: &buf)
            
        
        case let .claimDepositsSucceeded(claimedDeposits):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeDepositInfo.write(claimedDeposits, into: &buf)
            
        
        case let .paymentSucceeded(payment):
            writeInt(&buf, Int32(4))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkEvent_lift(_ buf: RustBuffer) throws -> SdkEvent {
    return try FfiConverterTypeSdkEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkEvent_lower(_ value: SdkEvent) -> RustBuffer {
    return FfiConverterTypeSdkEvent.lower(value)
}



extension SdkEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendPaymentMethod {
    
    case bitcoinAddress(address: BitcoinAddressDetails, feeQuote: SendOnchainFeeQuote
    )
    case bolt11Invoice(invoiceDetails: Bolt11InvoiceDetails, sparkTransferFeeSats: UInt64?, lightningFeeSats: UInt64
    )
    case sparkAddress(address: String, feeSats: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(address: try FfiConverterTypeBitcoinAddressDetails.read(from: &buf), feeQuote: try FfiConverterTypeSendOnchainFeeQuote.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(invoiceDetails: try FfiConverterTypeBolt11InvoiceDetails.read(from: &buf), sparkTransferFeeSats: try FfiConverterOptionUInt64.read(from: &buf), lightningFeeSats: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .sparkAddress(address: try FfiConverterString.read(from: &buf), feeSats: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(address,feeQuote):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressDetails.write(address, into: &buf)
            FfiConverterTypeSendOnchainFeeQuote.write(feeQuote, into: &buf)
            
        
        case let .bolt11Invoice(invoiceDetails,sparkTransferFeeSats,lightningFeeSats):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBolt11InvoiceDetails.write(invoiceDetails, into: &buf)
            FfiConverterOptionUInt64.write(sparkTransferFeeSats, into: &buf)
            FfiConverterUInt64.write(lightningFeeSats, into: &buf)
            
        
        case let .sparkAddress(address,feeSats):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(address, into: &buf)
            FfiConverterUInt64.write(feeSats, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentMethod_lift(_ buf: RustBuffer) throws -> SendPaymentMethod {
    return try FfiConverterTypeSendPaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentMethod_lower(_ value: SendPaymentMethod) -> RustBuffer {
    return FfiConverterTypeSendPaymentMethod.lower(value)
}



extension SendPaymentMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendPaymentOptions {
    
    case bitcoinAddress(confirmationSpeed: OnchainConfirmationSpeed
    )
    case bolt11Invoice(useSpark: Bool
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentOptions: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(confirmationSpeed: try FfiConverterTypeOnchainConfirmationSpeed.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(useSpark: try FfiConverterBool.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(confirmationSpeed):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOnchainConfirmationSpeed.write(confirmationSpeed, into: &buf)
            
        
        case let .bolt11Invoice(useSpark):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(useSpark, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentOptions_lift(_ buf: RustBuffer) throws -> SendPaymentOptions {
    return try FfiConverterTypeSendPaymentOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentOptions_lower(_ value: SendPaymentOptions) -> RustBuffer {
    return FfiConverterTypeSendPaymentOptions.lower(value)
}



extension SendPaymentOptions: Equatable, Hashable {}




/**
 * Errors that can occur during storage operations
 */
public enum StorageError {

    
    
    case Implementation(String
    )
    /**
     * Database initialization error
     */
    case InitializationError(String
    )
    case Serialization(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageError: FfiConverterRustBuffer {
    typealias SwiftType = StorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Implementation(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InitializationError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Implementation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InitializationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension StorageError: Equatable, Hashable {}

extension StorageError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UpdateDepositPayload {
    
    case claimError(error: DepositClaimError
    )
    case refund(refundTxid: String, refundTx: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateDepositPayload: FfiConverterRustBuffer {
    typealias SwiftType = UpdateDepositPayload

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateDepositPayload {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .claimError(error: try FfiConverterTypeDepositClaimError.read(from: &buf)
        )
        
        case 2: return .refund(refundTxid: try FfiConverterString.read(from: &buf), refundTx: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UpdateDepositPayload, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .claimError(error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDepositClaimError.write(error, into: &buf)
            
        
        case let .refund(refundTxid,refundTx):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(refundTxid, into: &buf)
            FfiConverterString.write(refundTx, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateDepositPayload_lift(_ buf: RustBuffer) throws -> UpdateDepositPayload {
    return try FfiConverterTypeUpdateDepositPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateDepositPayload_lower(_ value: UpdateDepositPayload) -> RustBuffer {
    return FfiConverterTypeUpdateDepositPayload.lower(value)
}



extension UpdateDepositPayload: Equatable, Hashable {}






/**
 * Trait for event listeners
 */
public protocol EventListener : AnyObject {
    
    /**
     * Called when an event occurs
     */
    func onEvent(event: SdkEvent) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEventListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEventListener = UniffiVTableCallbackInterfaceEventListener(
        onEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onEvent(
                     event: try FfiConverterTypeSdkEvent.lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceEventListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EventListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEventListener() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(&UniffiCallbackInterfaceEventListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceEventListener {
    fileprivate static var handleMap = UniffiHandleMap<EventListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceEventListener : FfiConverter {
    typealias SwiftType = EventListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol Logger : AnyObject {
    
    func log(l: LogEntry) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogger {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLogger = UniffiVTableCallbackInterfaceLogger(
        log: { (
            uniffiHandle: UInt64,
            l: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.log(
                     l: try FfiConverterTypeLogEntry.lift(l)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Logger: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLogger() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(&UniffiCallbackInterfaceLogger.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLogger {
    fileprivate static var handleMap = UniffiHandleMap<Logger>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLogger : FfiConverter {
    typealias SwiftType = Logger
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCredentials: FfiConverterRustBuffer {
    typealias SwiftType = Credentials?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredentials.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredentials.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlPayInfo: FfiConverterRustBuffer {
    typealias SwiftType = LnurlPayInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlPayInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlPayInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDepositClaimError: FfiConverterRustBuffer {
    typealias SwiftType = DepositClaimError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDepositClaimError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDepositClaimError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFee: FfiConverterRustBuffer {
    typealias SwiftType = Fee?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFee.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFee.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSendPaymentOptions: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendPaymentOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendPaymentOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceLogger: FfiConverterRustBuffer {
    typealias SwiftType = Logger?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceLogger.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceLogger.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessAction: FfiConverterRustBuffer {
    typealias SwiftType = SuccessAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessActionProcessed.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessActionProcessed.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDepositInfo: FfiConverterRustBuffer {
    typealias SwiftType = [DepositInfo]

    public static func write(_ value: [DepositInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDepositInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DepositInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [DepositInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDepositInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [Utxo]

    public static func write(_ value: [Utxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUtxo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Utxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [Utxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUtxo.read(from: &buf))
        }
        return seq
    }
}














private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountBreezSdkSpark() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func defaultConfig(network: Network) -> Config {
    return try!  FfiConverterTypeConfig.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_func_default_config(
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
public func defaultStorage(dataDir: String)throws  -> Storage {
    return try  FfiConverterTypeStorage.lift(try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_func_default_storage(
        FfiConverterString.lower(dataDir),$0
    )
})
}
public func initLogging(logDir: String?, appLogger: Logger?, logFilter: String?)throws  {try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_func_init_logging(
        FfiConverterOptionString.lower(logDir),
        FfiConverterOptionCallbackInterfaceLogger.lower(appLogger),
        FfiConverterOptionString.lower(logFilter),$0
    )
}
}
public func parse(input: String)async throws  -> InputType {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_func_parse(FfiConverterString.lower(input)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeInputType_lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_breez_sdk_spark_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_config() != 62194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_storage() != 46285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_init_logging() != 8518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_parse() != 58372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos() != 20959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex() != 19571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction() != 61083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener() != 61844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit() != 43529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect() != 30986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info() != 6771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment() != 11540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments() != 16156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits() != 22486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay() != 10147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_poll_lightning_send_payment() != 5478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay() != 37691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment() != 34185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment() != 36984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit() != 33646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener() != 60980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment() != 54349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment_internal() != 37855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet() != 36066) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build() != 8126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service() != 2848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client() != 61720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service() != 56288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item() != 11423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item() != 17965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_list_payments() != 55103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_insert_payment() != 35649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata() != 780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id() != 32084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_add_deposit() != 31647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit() != 19211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_list_deposits() != 11262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_update_deposit() != 58400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new() != 52744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event() != 10824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_logger_log() != 11839) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitBitcoinChainService()
    uniffiCallbackInitStorage()
    uniffiCallbackInitEventListener()
    uniffiCallbackInitLogger()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all