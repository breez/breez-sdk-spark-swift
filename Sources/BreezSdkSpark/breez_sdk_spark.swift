// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation
import BigNumber

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(breez_sdk_sparkFFI)
import breez_sdk_sparkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_breez_sdk_spark_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_breez_sdk_spark_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol BitcoinChainService : AnyObject {
    
    func getAddressUtxos(address: String) async throws  -> [Utxo]
    
    func getTransactionStatus(txid: String) async throws  -> TxStatus
    
    func getTransactionHex(txid: String) async throws  -> String
    
    func broadcastTransaction(tx: String) async throws 
    
}

open class BitcoinChainServiceImpl:
    BitcoinChainService {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(pointer, $0) }
    }

    

    
open func getAddressUtxos(address: String)async throws  -> [Utxo] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(address)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUtxo.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func getTransactionStatus(txid: String)async throws  -> TxStatus {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTxStatus.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func getTransactionHex(txid: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func broadcastTransaction(tx: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(tx)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBitcoinChainService {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBitcoinChainService = UniffiVTableCallbackInterfaceBitcoinChainService(
        getAddressUtxos: { (
            uniffiHandle: UInt64,
            address: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Utxo] in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getAddressUtxos(
                     address: try FfiConverterString.lift(address)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Utxo]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeUtxo.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getTransactionStatus: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> TxStatus in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getTransactionStatus(
                     txid: try FfiConverterString.lift(txid)
                )
            }

            let uniffiHandleSuccess = { (returnValue: TxStatus) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeTxStatus.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getTransactionHex: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getTransactionHex(
                     txid: try FfiConverterString.lift(txid)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        broadcastTransaction: { (
            uniffiHandle: UInt64,
            tx: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.broadcastTransaction(
                     tx: try FfiConverterString.lift(tx)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeBitcoinChainService.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BitcoinChainService: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBitcoinChainService() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(&UniffiCallbackInterfaceBitcoinChainService.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinChainService: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<BitcoinChainService>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BitcoinChainService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinChainService {
        return BitcoinChainServiceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BitcoinChainService) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinChainService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BitcoinChainService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinChainService_lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinChainService {
    return try FfiConverterTypeBitcoinChainService.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinChainService_lower(_ value: BitcoinChainService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBitcoinChainService.lower(value)
}




/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
public protocol BreezSdkProtocol : AnyObject {
    
    /**
     * Registers a listener to receive SDK events
     *
     * # Arguments
     *
     * * `listener` - An implementation of the `EventListener` trait
     *
     * # Returns
     *
     * A unique identifier for the listener, which can be used to remove it later
     */
    func addEventListener(listener: EventListener) async  -> String
    
    func checkLightningAddressAvailable(req: CheckLightningAddressRequest) async throws  -> Bool
    
    /**
     * Verifies a message signature against the provided public key. The message
     * is SHA256 hashed before verification. The signature can be hex encoded
     * in either DER or compact format.
     */
    func checkMessage(request: CheckMessageRequest) async throws  -> CheckMessageResponse
    
    func claimDeposit(request: ClaimDepositRequest) async throws  -> ClaimDepositResponse
    
    func deleteLightningAddress() async throws 
    
    /**
     * Stops the SDK's background tasks
     *
     * This method stops the background tasks started by the `start()` method.
     * It should be called before your application terminates to ensure proper cleanup.
     *
     * # Returns
     *
     * Result containing either success or an `SdkError` if the background task couldn't be stopped
     */
    func disconnect() async throws 
    
    /**
     * Returns the balance of the wallet in satoshis
     */
    func getInfo(request: GetInfoRequest) async throws  -> GetInfoResponse
    
    func getLightningAddress() async throws  -> LightningAddressInfo?
    
    func getPayment(request: GetPaymentRequest) async throws  -> GetPaymentResponse
    
    /**
     * Returns the metadata for the given token identifiers.
     *
     * Results are not guaranteed to be in the same order as the input token identifiers.
     *
     * If the metadata is not found locally in cache, it will be queried from
     * the Spark network and then cached.
     */
    func getTokensMetadata(request: GetTokensMetadataRequest) async throws  -> GetTokensMetadataResponse
    
    /**
     * List fiat currencies for which there is a known exchange rate,
     * sorted by the canonical name of the currency.
     */
    func listFiatCurrencies() async throws  -> ListFiatCurrenciesResponse
    
    /**
     * List the latest rates of fiat currencies, sorted by name.
     */
    func listFiatRates() async throws  -> ListFiatRatesResponse
    
    /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
    func listPayments(request: ListPaymentsRequest) async throws  -> ListPaymentsResponse
    
    func listUnclaimedDeposits(request: ListUnclaimedDepositsRequest) async throws  -> ListUnclaimedDepositsResponse
    
    func lnurlPay(request: LnurlPayRequest) async throws  -> LnurlPayResponse
    
    /**
     * Performs an LNURL withdraw operation for the amount of satoshis to
     * withdraw and the LNURL withdraw request details. The LNURL withdraw request
     * details can be obtained from calling [`BreezSdk::parse`].
     *
     * The method generates a Lightning invoice for the withdraw amount, stores
     * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
     * invoice.
     *
     * If the `completion_timeout_secs` parameter is provided and greater than 0, the
     * method will wait for the payment to be completed within that period. If the
     * withdraw is completed within the timeout, the `payment` field in the response
     * will be set with the payment details. If the `completion_timeout_secs`
     * parameter is not provided or set to 0, the method will not wait for the payment
     * to be completed. If the withdraw is not completed within the
     * timeout, the `payment` field will be empty.
     *
     * # Arguments
     *
     * * `request` - The LNURL withdraw request
     *
     * # Returns
     *
     * Result containing either:
     * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
     * * `SdkError` - If there was an error during the withdraw process
     */
    func lnurlWithdraw(request: LnurlWithdrawRequest) async throws  -> LnurlWithdrawResponse
    
    func parse(input: String) async throws  -> InputType
    
    func prepareLnurlPay(request: PrepareLnurlPayRequest) async throws  -> PrepareLnurlPayResponse
    
    func prepareSendPayment(request: PrepareSendPaymentRequest) async throws  -> PrepareSendPaymentResponse
    
    func receivePayment(request: ReceivePaymentRequest) async throws  -> ReceivePaymentResponse
    
    func refundDeposit(request: RefundDepositRequest) async throws  -> RefundDepositResponse
    
    func registerLightningAddress(request: RegisterLightningAddressRequest) async throws  -> LightningAddressInfo
    
    /**
     * Removes a previously registered event listener
     *
     * # Arguments
     *
     * * `id` - The listener ID returned from `add_event_listener`
     *
     * # Returns
     *
     * `true` if the listener was found and removed, `false` otherwise
     */
    func removeEventListener(id: String) async  -> Bool
    
    func sendPayment(request: SendPaymentRequest) async throws  -> SendPaymentResponse
    
    /**
     * Signs a message with the wallet's identity key. The message is SHA256
     * hashed before signing. The returned signature will be hex encoded in
     * DER format by default, or compact format if specified.
     */
    func signMessage(request: SignMessageRequest) async throws  -> SignMessageResponse
    
    /**
     * Synchronizes the wallet with the Spark network
     */
    func syncWallet(request: SyncWalletRequest) async throws  -> SyncWalletResponse
    
    func waitForPayment(request: WaitForPaymentRequest) async throws  -> WaitForPaymentResponse
    
}

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
open class BreezSdk:
    BreezSdkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_breezsdk(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_breezsdk(pointer, $0) }
    }

    

    
    /**
     * Registers a listener to receive SDK events
     *
     * # Arguments
     *
     * * `listener` - An implementation of the `EventListener` trait
     *
     * # Returns
     *
     * A unique identifier for the listener, which can be used to remove it later
     */
open func addEventListener(listener: EventListener)async  -> String {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceEventListener.lower(listener)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}
    
open func checkLightningAddressAvailable(req: CheckLightningAddressRequest)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCheckLightningAddressRequest.lower(req)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_i8,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_i8,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Verifies a message signature against the provided public key. The message
     * is SHA256 hashed before verification. The signature can be hex encoded
     * in either DER or compact format.
     */
open func checkMessage(request: CheckMessageRequest)async throws  -> CheckMessageResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCheckMessageRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeCheckMessageResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func claimDeposit(request: ClaimDepositRequest)async throws  -> ClaimDepositResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClaimDepositRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeClaimDepositResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func deleteLightningAddress()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Stops the SDK's background tasks
     *
     * This method stops the background tasks started by the `start()` method.
     * It should be called before your application terminates to ensure proper cleanup.
     *
     * # Returns
     *
     * Result containing either success or an `SdkError` if the background task couldn't be stopped
     */
open func disconnect()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns the balance of the wallet in satoshis
     */
open func getInfo(request: GetInfoRequest)async throws  -> GetInfoResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetInfoRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetInfoResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func getLightningAddress()async throws  -> LightningAddressInfo? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeLightningAddressInfo.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func getPayment(request: GetPaymentRequest)async throws  -> GetPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns the metadata for the given token identifiers.
     *
     * Results are not guaranteed to be in the same order as the input token identifiers.
     *
     * If the metadata is not found locally in cache, it will be queried from
     * the Spark network and then cached.
     */
open func getTokensMetadata(request: GetTokensMetadataRequest)async throws  -> GetTokensMetadataResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetTokensMetadataRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetTokensMetadataResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * List fiat currencies for which there is a known exchange rate,
     * sorted by the canonical name of the currency.
     */
open func listFiatCurrencies()async throws  -> ListFiatCurrenciesResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListFiatCurrenciesResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * List the latest rates of fiat currencies, sorted by name.
     */
open func listFiatRates()async throws  -> ListFiatRatesResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListFiatRatesResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage

     */
open func listPayments(request: ListPaymentsRequest)async throws  -> ListPaymentsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListPaymentsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListPaymentsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func listUnclaimedDeposits(request: ListUnclaimedDepositsRequest)async throws  -> ListUnclaimedDepositsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListUnclaimedDepositsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListUnclaimedDepositsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func lnurlPay(request: LnurlPayRequest)async throws  -> LnurlPayResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLnurlPayRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLnurlPayResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Performs an LNURL withdraw operation for the amount of satoshis to
     * withdraw and the LNURL withdraw request details. The LNURL withdraw request
     * details can be obtained from calling [`BreezSdk::parse`].
     *
     * The method generates a Lightning invoice for the withdraw amount, stores
     * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
     * invoice.
     *
     * If the `completion_timeout_secs` parameter is provided and greater than 0, the
     * method will wait for the payment to be completed within that period. If the
     * withdraw is completed within the timeout, the `payment` field in the response
     * will be set with the payment details. If the `completion_timeout_secs`
     * parameter is not provided or set to 0, the method will not wait for the payment
     * to be completed. If the withdraw is not completed within the
     * timeout, the `payment` field will be empty.
     *
     * # Arguments
     *
     * * `request` - The LNURL withdraw request
     *
     * # Returns
     *
     * Result containing either:
     * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
     * * `SdkError` - If there was an error during the withdraw process
     */
open func lnurlWithdraw(request: LnurlWithdrawRequest)async throws  -> LnurlWithdrawResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLnurlWithdrawRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLnurlWithdrawResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func parse(input: String)async throws  -> InputType {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(input)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeInputType_lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func prepareLnurlPay(request: PrepareLnurlPayRequest)async throws  -> PrepareLnurlPayResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrepareLnurlPayRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrepareLnurlPayResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func prepareSendPayment(request: PrepareSendPaymentRequest)async throws  -> PrepareSendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrepareSendPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrepareSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func receivePayment(request: ReceivePaymentRequest)async throws  -> ReceivePaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReceivePaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReceivePaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func refundDeposit(request: RefundDepositRequest)async throws  -> RefundDepositResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRefundDepositRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRefundDepositResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func registerLightningAddress(request: RegisterLightningAddressRequest)async throws  -> LightningAddressInfo {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRegisterLightningAddressRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLightningAddressInfo.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Removes a previously registered event listener
     *
     * # Arguments
     *
     * * `id` - The listener ID returned from `add_event_listener`
     *
     * # Returns
     *
     * `true` if the listener was found and removed, `false` otherwise
     */
open func removeEventListener(id: String)async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_i8,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_i8,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
open func sendPayment(request: SendPaymentRequest)async throws  -> SendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Signs a message with the wallet's identity key. The message is SHA256
     * hashed before signing. The returned signature will be hex encoded in
     * DER format by default, or compact format if specified.
     */
open func signMessage(request: SignMessageRequest)async throws  -> SignMessageResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSignMessageRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignMessageResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Synchronizes the wallet with the Spark network
     */
open func syncWallet(request: SyncWalletRequest)async throws  -> SyncWalletResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSyncWalletRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSyncWalletResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func waitForPayment(request: WaitForPaymentRequest)async throws  -> WaitForPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_wait_for_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWaitForPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWaitForPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBreezSdk: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BreezSdk

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BreezSdk {
        return BreezSdk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BreezSdk) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezSdk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BreezSdk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdk_lift(_ pointer: UnsafeMutableRawPointer) throws -> BreezSdk {
    return try FfiConverterTypeBreezSdk.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdk_lower(_ value: BreezSdk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBreezSdk.lower(value)
}




/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
public protocol PaymentObserver : AnyObject {
    
    /**
     * Called before Lightning, Spark or onchain Bitcoin payments are made
     */
    func beforeSend(payments: [ProvisionalPayment]) async throws 
    
}

/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
open class PaymentObserverImpl:
    PaymentObserver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_paymentobserver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_paymentobserver(pointer, $0) }
    }

    

    
    /**
     * Called before Lightning, Spark or onchain Bitcoin payments are made
     */
open func beforeSend(payments: [ProvisionalPayment])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeProvisionalPayment.lower(payments)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypePaymentObserverError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePaymentObserver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfacePaymentObserver = UniffiVTableCallbackInterfacePaymentObserver(
        beforeSend: { (
            uniffiHandle: UInt64,
            payments: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypePaymentObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.beforeSend(
                     payments: try FfiConverterSequenceTypeProvisionalPayment.lift(payments)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypePaymentObserverError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypePaymentObserver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PaymentObserver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitPaymentObserver() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(&UniffiCallbackInterfacePaymentObserver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentObserver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<PaymentObserver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaymentObserver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaymentObserver {
        return PaymentObserverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaymentObserver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentObserver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaymentObserver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentObserver_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaymentObserver {
    return try FfiConverterTypePaymentObserver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentObserver_lower(_ value: PaymentObserver) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaymentObserver.lower(value)
}




/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
public protocol SdkBuilderProtocol : AnyObject {
    
    /**
     * Builds the `BreezSdk` instance with the configured components.
     */
    func build() async throws  -> BreezSdk
    
    /**
     * Sets the chain service to be used by the SDK.
     * Arguments:
     * - `chain_service`: The chain service to be used.
     */
    func withChainService(chainService: BitcoinChainService) async 
    
    /**
     * Sets the fiat service to be used by the SDK.
     * Arguments:
     * - `fiat_service`: The fiat service to be used.
     */
    func withFiatService(fiatService: FiatService) async 
    
    /**
     * Sets the key set type to be used by the SDK.
     * Arguments:
     * - `key_set_type`: The key set type which determines the derivation path.
     * - `use_address_index`: Controls the structure of the BIP derivation path.
     */
    func withKeySet(keySetType: KeySetType, useAddressIndex: Bool, accountNumber: UInt32?) async 
    
    func withLnurlClient(lnurlClient: RestClient) async 
    
    /**
     * Sets the payment observer to be used by the SDK.
     * Arguments:
     * - `payment_observer`: The payment observer to be used.
     */
    func withPaymentObserver(paymentObserver: PaymentObserver) async 
    
    func withRealTimeSyncStorage(storage: SyncStorage) async 
    
    /**
     * Sets the REST chain service to be used by the SDK.
     * Arguments:
     * - `url`: The base URL of the REST API.
     * - `credentials`: Optional credentials for basic authentication.
     */
    func withRestChainService(url: String, credentials: Credentials?) async 
    
}

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
open class SdkBuilder:
    SdkBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_sdkbuilder(self.pointer, $0) }
    }
    /**
     * Creates a new `SdkBuilder` with the provided configuration.
     * Arguments:
     * - `config`: The configuration to be used.
     * - `seed`: The seed for wallet generation.
     * - `storage`: The storage backend to be used.
     */
public convenience init(config: Config, seed: Seed, storage: Storage) {
    let pointer =
        try! rustCall() {
    uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
        FfiConverterTypeConfig.lower(config),
        FfiConverterTypeSeed.lower(seed),
        FfiConverterTypeStorage.lower(storage),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_sdkbuilder(pointer, $0) }
    }

    

    
    /**
     * Builds the `BreezSdk` instance with the configured components.
     */
open func build()async throws  -> BreezSdk {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBreezSdk.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Sets the chain service to be used by the SDK.
     * Arguments:
     * - `chain_service`: The chain service to be used.
     */
open func withChainService(chainService: BitcoinChainService)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBitcoinChainService.lower(chainService)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the fiat service to be used by the SDK.
     * Arguments:
     * - `fiat_service`: The fiat service to be used.
     */
open func withFiatService(fiatService: FiatService)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFiatService_lower(fiatService)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the key set type to be used by the SDK.
     * Arguments:
     * - `key_set_type`: The key set type which determines the derivation path.
     * - `use_address_index`: Controls the structure of the BIP derivation path.
     */
open func withKeySet(keySetType: KeySetType, useAddressIndex: Bool, accountNumber: UInt32?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKeySetType.lower(keySetType),FfiConverterBool.lower(useAddressIndex),FfiConverterOptionUInt32.lower(accountNumber)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func withLnurlClient(lnurlClient: RestClient)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRestClient_lower(lnurlClient)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the payment observer to be used by the SDK.
     * Arguments:
     * - `payment_observer`: The payment observer to be used.
     */
open func withPaymentObserver(paymentObserver: PaymentObserver)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
                    self.uniffiClonePointer(),
                    FfiConverterTypePaymentObserver.lower(paymentObserver)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func withRealTimeSyncStorage(storage: SyncStorage)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSyncStorage_lower(storage)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the REST chain service to be used by the SDK.
     * Arguments:
     * - `url`: The base URL of the REST API.
     * - `credentials`: Optional credentials for basic authentication.
     */
open func withRestChainService(url: String, credentials: Credentials?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionTypeCredentials.lower(credentials)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SdkBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SdkBuilder {
        return SdkBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SdkBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SdkBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SdkBuilder {
    return try FfiConverterTypeSdkBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkBuilder_lower(_ value: SdkBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSdkBuilder.lower(value)
}




/**
 * Trait for persistent storage
 */
public protocol Storage : AnyObject {
    
    func deleteCachedItem(key: String) async throws 
    
    func getCachedItem(key: String) async throws  -> String?
    
    func setCachedItem(key: String, value: String) async throws 
    
    /**
     * Lists payments with optional filters and pagination
     *
     * # Arguments
     *
     * * `list_payments_request` - The request to list payments
     *
     * # Returns
     *
     * A vector of payments or a `StorageError`
     */
    func listPayments(request: ListPaymentsRequest) async throws  -> [Payment]
    
    /**
     * Inserts a payment into storage
     *
     * # Arguments
     *
     * * `payment` - The payment to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func insertPayment(payment: Payment) async throws 
    
    /**
     * Inserts payment metadata into storage
     *
     * # Arguments
     *
     * * `payment_id` - The ID of the payment
     * * `metadata` - The metadata to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func setPaymentMetadata(paymentId: String, metadata: PaymentMetadata) async throws 
    
    /**
     * Gets a payment by its ID
     * # Arguments
     *
     * * `id` - The ID of the payment to retrieve
     *
     * # Returns
     *
     * The payment if found or None if not found
     */
    func getPaymentById(id: String) async throws  -> Payment
    
    /**
     * Gets a payment by its invoice
     * # Arguments
     *
     * * `invoice` - The invoice of the payment to retrieve
     * # Returns
     *
     * The payment if found or None if not found
     */
    func getPaymentByInvoice(invoice: String) async throws  -> Payment?
    
    /**
     * Add a deposit to storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `amount_sats` - The amount of the deposit in sats
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func addDeposit(txid: String, vout: UInt32, amountSats: UInt64) async throws 
    
    /**
     * Removes an unclaimed deposit from storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func deleteDeposit(txid: String, vout: UInt32) async throws 
    
    /**
     * Lists all unclaimed deposits from storage
     * # Returns
     *
     * A vector of `DepositInfo` or a `StorageError`
     */
    func listDeposits() async throws  -> [DepositInfo]
    
    /**
     * Updates or inserts unclaimed deposit details
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `payload` - The payload for the update
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func updateDeposit(txid: String, vout: UInt32, payload: UpdateDepositPayload) async throws 
    
}

/**
 * Trait for persistent storage
 */
open class StorageImpl:
    Storage {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_storage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_storage(pointer, $0) }
    }

    

    
open func deleteCachedItem(key: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func getCachedItem(key: String)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func setCachedItem(key: String, value: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key),FfiConverterString.lower(value)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Lists payments with optional filters and pagination
     *
     * # Arguments
     *
     * * `list_payments_request` - The request to list payments
     *
     * # Returns
     *
     * A vector of payments or a `StorageError`
     */
open func listPayments(request: ListPaymentsRequest)async throws  -> [Payment] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_list_payments(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListPaymentsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Inserts a payment into storage
     *
     * # Arguments
     *
     * * `payment` - The payment to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func insertPayment(payment: Payment)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayment.lower(payment)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Inserts payment metadata into storage
     *
     * # Arguments
     *
     * * `payment_id` - The ID of the payment
     * * `metadata` - The metadata to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func setPaymentMetadata(paymentId: String, metadata: PaymentMetadata)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(paymentId),FfiConverterTypePaymentMetadata.lower(metadata)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Gets a payment by its ID
     * # Arguments
     *
     * * `id` - The ID of the payment to retrieve
     *
     * # Returns
     *
     * The payment if found or None if not found
     */
open func getPaymentById(id: String)async throws  -> Payment {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Gets a payment by its invoice
     * # Arguments
     *
     * * `invoice` - The invoice of the payment to retrieve
     * # Returns
     *
     * The payment if found or None if not found
     */
open func getPaymentByInvoice(invoice: String)async throws  -> Payment? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(invoice)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Add a deposit to storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `amount_sats` - The amount of the deposit in sats
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func addDeposit(txid: String, vout: UInt32, amountSats: UInt64)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterUInt64.lower(amountSats)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Removes an unclaimed deposit from storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func deleteDeposit(txid: String, vout: UInt32)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Lists all unclaimed deposits from storage
     * # Returns
     *
     * A vector of `DepositInfo` or a `StorageError`
     */
open func listDeposits()async throws  -> [DepositInfo] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeDepositInfo.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Updates or inserts unclaimed deposit details
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `payload` - The payload for the update
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func updateDeposit(txid: String, vout: UInt32, payload: UpdateDepositPayload)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterTypeUpdateDepositPayload.lower(payload)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceStorage {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceStorage = UniffiVTableCallbackInterfaceStorage(
        deleteCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteCachedItem(
                     key: try FfiConverterString.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String? in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getCachedItem(
                     key: try FfiConverterString.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setCachedItem(
                     key: try FfiConverterString.lift(key),
                     value: try FfiConverterString.lift(value)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listPayments: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Payment] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listPayments(
                     request: try FfiConverterTypeListPaymentsRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Payment]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        insertPayment: { (
            uniffiHandle: UInt64,
            payment: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.insertPayment(
                     payment: try FfiConverterTypePayment.lift(payment)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setPaymentMetadata: { (
            uniffiHandle: UInt64,
            paymentId: RustBuffer,
            metadata: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setPaymentMetadata(
                     paymentId: try FfiConverterString.lift(paymentId),
                     metadata: try FfiConverterTypePaymentMetadata.lift(metadata)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPaymentById: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Payment in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPaymentById(
                     id: try FfiConverterString.lift(id)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Payment) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPaymentByInvoice: { (
            uniffiHandle: UInt64,
            invoice: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Payment? in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPaymentByInvoice(
                     invoice: try FfiConverterString.lift(invoice)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Payment?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        addDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            amountSats: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.addDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout),
                     amountSats: try FfiConverterUInt64.lift(amountSats)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listDeposits: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [DepositInfo] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listDeposits(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [DepositInfo]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeDepositInfo.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        updateDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            payload: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.updateDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout),
                     payload: try FfiConverterTypeUpdateDepositPayload.lift(payload)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Storage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitStorage() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(&UniffiCallbackInterfaceStorage.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<Storage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Storage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Storage {
        return StorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Storage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Storage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Storage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> Storage {
    return try FfiConverterTypeStorage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorage_lower(_ value: Storage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStorage.lower(value)
}


public struct CheckLightningAddressRequest {
    public var username: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String) {
        self.username = username
    }
}



extension CheckLightningAddressRequest: Equatable, Hashable {
    public static func ==(lhs: CheckLightningAddressRequest, rhs: CheckLightningAddressRequest) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckLightningAddressRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckLightningAddressRequest {
        return
            try CheckLightningAddressRequest(
                username: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CheckLightningAddressRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckLightningAddressRequest_lift(_ buf: RustBuffer) throws -> CheckLightningAddressRequest {
    return try FfiConverterTypeCheckLightningAddressRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckLightningAddressRequest_lower(_ value: CheckLightningAddressRequest) -> RustBuffer {
    return FfiConverterTypeCheckLightningAddressRequest.lower(value)
}


public struct CheckMessageRequest {
    /**
     * The message that was signed
     */
    public var message: String
    /**
     * The public key that signed the message
     */
    public var pubkey: String
    /**
     * The DER or compact hex encoded signature
     */
    public var signature: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The message that was signed
         */message: String, 
        /**
         * The public key that signed the message
         */pubkey: String, 
        /**
         * The DER or compact hex encoded signature
         */signature: String) {
        self.message = message
        self.pubkey = pubkey
        self.signature = signature
    }
}



extension CheckMessageRequest: Equatable, Hashable {
    public static func ==(lhs: CheckMessageRequest, rhs: CheckMessageRequest) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(pubkey)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckMessageRequest {
        return
            try CheckMessageRequest(
                message: FfiConverterString.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CheckMessageRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageRequest_lift(_ buf: RustBuffer) throws -> CheckMessageRequest {
    return try FfiConverterTypeCheckMessageRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageRequest_lower(_ value: CheckMessageRequest) -> RustBuffer {
    return FfiConverterTypeCheckMessageRequest.lower(value)
}


public struct CheckMessageResponse {
    public var isValid: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isValid: Bool) {
        self.isValid = isValid
    }
}



extension CheckMessageResponse: Equatable, Hashable {
    public static func ==(lhs: CheckMessageResponse, rhs: CheckMessageResponse) -> Bool {
        if lhs.isValid != rhs.isValid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isValid)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckMessageResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckMessageResponse {
        return
            try CheckMessageResponse(
                isValid: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CheckMessageResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isValid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageResponse_lift(_ buf: RustBuffer) throws -> CheckMessageResponse {
    return try FfiConverterTypeCheckMessageResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageResponse_lower(_ value: CheckMessageResponse) -> RustBuffer {
    return FfiConverterTypeCheckMessageResponse.lower(value)
}


public struct ClaimDepositRequest {
    public var txid: String
    public var vout: UInt32
    public var maxFee: Fee?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, maxFee: Fee? = nil) {
        self.txid = txid
        self.vout = vout
        self.maxFee = maxFee
    }
}



extension ClaimDepositRequest: Equatable, Hashable {
    public static func ==(lhs: ClaimDepositRequest, rhs: ClaimDepositRequest) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.maxFee != rhs.maxFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(maxFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimDepositRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimDepositRequest {
        return
            try ClaimDepositRequest(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                maxFee: FfiConverterOptionTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimDepositRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterOptionTypeFee.write(value.maxFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositRequest_lift(_ buf: RustBuffer) throws -> ClaimDepositRequest {
    return try FfiConverterTypeClaimDepositRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositRequest_lower(_ value: ClaimDepositRequest) -> RustBuffer {
    return FfiConverterTypeClaimDepositRequest.lower(value)
}


public struct ClaimDepositResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension ClaimDepositResponse: Equatable, Hashable {
    public static func ==(lhs: ClaimDepositResponse, rhs: ClaimDepositResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimDepositResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimDepositResponse {
        return
            try ClaimDepositResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimDepositResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositResponse_lift(_ buf: RustBuffer) throws -> ClaimDepositResponse {
    return try FfiConverterTypeClaimDepositResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositResponse_lower(_ value: ClaimDepositResponse) -> RustBuffer {
    return FfiConverterTypeClaimDepositResponse.lower(value)
}


public struct Config {
    public var apiKey: String?
    public var network: Network
    public var syncIntervalSecs: UInt32
    public var maxDepositClaimFee: Fee?
    /**
     * The domain used for receiving through lnurl-pay and lightning address.
     */
    public var lnurlDomain: String?
    /**
     * When this is set to `true` we will prefer to use spark payments over
     * lightning when sending and receiving. This has the benefit of lower fees
     * but is at the cost of privacy.
     */
    public var preferSparkOverLightning: Bool
    /**
     * A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
     * is not recognized. See [`ExternalInputParser`] for more details on how to configure
     * external parsing.
     */
    public var externalInputParsers: [ExternalInputParser]?
    /**
     * The SDK includes some default external input parsers
     * ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
     * Set this to false in order to prevent their use.
     */
    public var useDefaultExternalInputParsers: Bool
    /**
     * Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
     */
    public var realTimeSyncServerUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(apiKey: String?, network: Network, syncIntervalSecs: UInt32, maxDepositClaimFee: Fee?, 
        /**
         * The domain used for receiving through lnurl-pay and lightning address.
         */lnurlDomain: String?, 
        /**
         * When this is set to `true` we will prefer to use spark payments over
         * lightning when sending and receiving. This has the benefit of lower fees
         * but is at the cost of privacy.
         */preferSparkOverLightning: Bool, 
        /**
         * A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
         * is not recognized. See [`ExternalInputParser`] for more details on how to configure
         * external parsing.
         */externalInputParsers: [ExternalInputParser]?, 
        /**
         * The SDK includes some default external input parsers
         * ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
         * Set this to false in order to prevent their use.
         */useDefaultExternalInputParsers: Bool, 
        /**
         * Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
         */realTimeSyncServerUrl: String?) {
        self.apiKey = apiKey
        self.network = network
        self.syncIntervalSecs = syncIntervalSecs
        self.maxDepositClaimFee = maxDepositClaimFee
        self.lnurlDomain = lnurlDomain
        self.preferSparkOverLightning = preferSparkOverLightning
        self.externalInputParsers = externalInputParsers
        self.useDefaultExternalInputParsers = useDefaultExternalInputParsers
        self.realTimeSyncServerUrl = realTimeSyncServerUrl
    }
}



extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.apiKey != rhs.apiKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.syncIntervalSecs != rhs.syncIntervalSecs {
            return false
        }
        if lhs.maxDepositClaimFee != rhs.maxDepositClaimFee {
            return false
        }
        if lhs.lnurlDomain != rhs.lnurlDomain {
            return false
        }
        if lhs.preferSparkOverLightning != rhs.preferSparkOverLightning {
            return false
        }
        if lhs.externalInputParsers != rhs.externalInputParsers {
            return false
        }
        if lhs.useDefaultExternalInputParsers != rhs.useDefaultExternalInputParsers {
            return false
        }
        if lhs.realTimeSyncServerUrl != rhs.realTimeSyncServerUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(apiKey)
        hasher.combine(network)
        hasher.combine(syncIntervalSecs)
        hasher.combine(maxDepositClaimFee)
        hasher.combine(lnurlDomain)
        hasher.combine(preferSparkOverLightning)
        hasher.combine(externalInputParsers)
        hasher.combine(useDefaultExternalInputParsers)
        hasher.combine(realTimeSyncServerUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                apiKey: FfiConverterOptionString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                syncIntervalSecs: FfiConverterUInt32.read(from: &buf), 
                maxDepositClaimFee: FfiConverterOptionTypeFee.read(from: &buf), 
                lnurlDomain: FfiConverterOptionString.read(from: &buf), 
                preferSparkOverLightning: FfiConverterBool.read(from: &buf), 
                externalInputParsers: FfiConverterOptionSequenceTypeExternalInputParser.read(from: &buf), 
                useDefaultExternalInputParsers: FfiConverterBool.read(from: &buf), 
                realTimeSyncServerUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.apiKey, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.syncIntervalSecs, into: &buf)
        FfiConverterOptionTypeFee.write(value.maxDepositClaimFee, into: &buf)
        FfiConverterOptionString.write(value.lnurlDomain, into: &buf)
        FfiConverterBool.write(value.preferSparkOverLightning, into: &buf)
        FfiConverterOptionSequenceTypeExternalInputParser.write(value.externalInputParsers, into: &buf)
        FfiConverterBool.write(value.useDefaultExternalInputParsers, into: &buf)
        FfiConverterOptionString.write(value.realTimeSyncServerUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct ConnectRequest {
    public var config: Config
    public var seed: Seed
    public var storageDir: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(config: Config, seed: Seed, storageDir: String) {
        self.config = config
        self.seed = seed
        self.storageDir = storageDir
    }
}



extension ConnectRequest: Equatable, Hashable {
    public static func ==(lhs: ConnectRequest, rhs: ConnectRequest) -> Bool {
        if lhs.config != rhs.config {
            return false
        }
        if lhs.seed != rhs.seed {
            return false
        }
        if lhs.storageDir != rhs.storageDir {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(config)
        hasher.combine(seed)
        hasher.combine(storageDir)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectRequest {
        return
            try ConnectRequest(
                config: FfiConverterTypeConfig.read(from: &buf), 
                seed: FfiConverterTypeSeed.read(from: &buf), 
                storageDir: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ConnectRequest, into buf: inout [UInt8]) {
        FfiConverterTypeConfig.write(value.config, into: &buf)
        FfiConverterTypeSeed.write(value.seed, into: &buf)
        FfiConverterString.write(value.storageDir, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectRequest_lift(_ buf: RustBuffer) throws -> ConnectRequest {
    return try FfiConverterTypeConnectRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectRequest_lower(_ value: ConnectRequest) -> RustBuffer {
    return FfiConverterTypeConnectRequest.lower(value)
}


public struct Credentials {
    public var username: String
    public var password: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String, password: String) {
        self.username = username
        self.password = password
    }
}



extension Credentials: Equatable, Hashable {
    public static func ==(lhs: Credentials, rhs: Credentials) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentials: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Credentials {
        return
            try Credentials(
                username: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Credentials, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentials_lift(_ buf: RustBuffer) throws -> Credentials {
    return try FfiConverterTypeCredentials.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentials_lower(_ value: Credentials) -> RustBuffer {
    return FfiConverterTypeCredentials.lower(value)
}


public struct DepositInfo {
    public var txid: String
    public var vout: UInt32
    public var amountSats: UInt64
    public var refundTx: String?
    public var refundTxId: String?
    public var claimError: DepositClaimError?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, amountSats: UInt64, refundTx: String?, refundTxId: String?, claimError: DepositClaimError?) {
        self.txid = txid
        self.vout = vout
        self.amountSats = amountSats
        self.refundTx = refundTx
        self.refundTxId = refundTxId
        self.claimError = claimError
    }
}



extension DepositInfo: Equatable, Hashable {
    public static func ==(lhs: DepositInfo, rhs: DepositInfo) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.refundTx != rhs.refundTx {
            return false
        }
        if lhs.refundTxId != rhs.refundTxId {
            return false
        }
        if lhs.claimError != rhs.claimError {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(amountSats)
        hasher.combine(refundTx)
        hasher.combine(refundTxId)
        hasher.combine(claimError)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositInfo {
        return
            try DepositInfo(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                amountSats: FfiConverterUInt64.read(from: &buf), 
                refundTx: FfiConverterOptionString.read(from: &buf), 
                refundTxId: FfiConverterOptionString.read(from: &buf), 
                claimError: FfiConverterOptionTypeDepositClaimError.read(from: &buf)
        )
    }

    public static func write(_ value: DepositInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.refundTx, into: &buf)
        FfiConverterOptionString.write(value.refundTxId, into: &buf)
        FfiConverterOptionTypeDepositClaimError.write(value.claimError, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositInfo_lift(_ buf: RustBuffer) throws -> DepositInfo {
    return try FfiConverterTypeDepositInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositInfo_lower(_ value: DepositInfo) -> RustBuffer {
    return FfiConverterTypeDepositInfo.lower(value)
}


/**
 * Request to get the balance of the wallet
 */
public struct GetInfoRequest {
    public var ensureSynced: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ensureSynced: Bool?) {
        self.ensureSynced = ensureSynced
    }
}



extension GetInfoRequest: Equatable, Hashable {
    public static func ==(lhs: GetInfoRequest, rhs: GetInfoRequest) -> Bool {
        if lhs.ensureSynced != rhs.ensureSynced {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ensureSynced)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoRequest {
        return
            try GetInfoRequest(
                ensureSynced: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoRequest, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.ensureSynced, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoRequest_lift(_ buf: RustBuffer) throws -> GetInfoRequest {
    return try FfiConverterTypeGetInfoRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoRequest_lower(_ value: GetInfoRequest) -> RustBuffer {
    return FfiConverterTypeGetInfoRequest.lower(value)
}


/**
 * Response containing the balance of the wallet
 */
public struct GetInfoResponse {
    /**
     * The balance in satoshis
     */
    public var balanceSats: UInt64
    /**
     * The balances of the tokens in the wallet keyed by the token identifier
     */
    public var tokenBalances: [String: TokenBalance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The balance in satoshis
         */balanceSats: UInt64, 
        /**
         * The balances of the tokens in the wallet keyed by the token identifier
         */tokenBalances: [String: TokenBalance]) {
        self.balanceSats = balanceSats
        self.tokenBalances = tokenBalances
    }
}



extension GetInfoResponse: Equatable, Hashable {
    public static func ==(lhs: GetInfoResponse, rhs: GetInfoResponse) -> Bool {
        if lhs.balanceSats != rhs.balanceSats {
            return false
        }
        if lhs.tokenBalances != rhs.tokenBalances {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balanceSats)
        hasher.combine(tokenBalances)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoResponse {
        return
            try GetInfoResponse(
                balanceSats: FfiConverterUInt64.read(from: &buf), 
                tokenBalances: FfiConverterDictionaryStringTypeTokenBalance.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.balanceSats, into: &buf)
        FfiConverterDictionaryStringTypeTokenBalance.write(value.tokenBalances, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lift(_ buf: RustBuffer) throws -> GetInfoResponse {
    return try FfiConverterTypeGetInfoResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lower(_ value: GetInfoResponse) -> RustBuffer {
    return FfiConverterTypeGetInfoResponse.lower(value)
}


public struct GetPaymentRequest {
    public var paymentId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentId: String) {
        self.paymentId = paymentId
    }
}



extension GetPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: GetPaymentRequest, rhs: GetPaymentRequest) -> Bool {
        if lhs.paymentId != rhs.paymentId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPaymentRequest {
        return
            try GetPaymentRequest(
                paymentId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GetPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentRequest_lift(_ buf: RustBuffer) throws -> GetPaymentRequest {
    return try FfiConverterTypeGetPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentRequest_lower(_ value: GetPaymentRequest) -> RustBuffer {
    return FfiConverterTypeGetPaymentRequest.lower(value)
}


public struct GetPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension GetPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: GetPaymentResponse, rhs: GetPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPaymentResponse {
        return
            try GetPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: GetPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentResponse_lift(_ buf: RustBuffer) throws -> GetPaymentResponse {
    return try FfiConverterTypeGetPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentResponse_lower(_ value: GetPaymentResponse) -> RustBuffer {
    return FfiConverterTypeGetPaymentResponse.lower(value)
}


public struct GetTokensMetadataRequest {
    public var tokenIdentifiers: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokenIdentifiers: [String]) {
        self.tokenIdentifiers = tokenIdentifiers
    }
}



extension GetTokensMetadataRequest: Equatable, Hashable {
    public static func ==(lhs: GetTokensMetadataRequest, rhs: GetTokensMetadataRequest) -> Bool {
        if lhs.tokenIdentifiers != rhs.tokenIdentifiers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokenIdentifiers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetTokensMetadataRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetTokensMetadataRequest {
        return
            try GetTokensMetadataRequest(
                tokenIdentifiers: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GetTokensMetadataRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.tokenIdentifiers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataRequest_lift(_ buf: RustBuffer) throws -> GetTokensMetadataRequest {
    return try FfiConverterTypeGetTokensMetadataRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataRequest_lower(_ value: GetTokensMetadataRequest) -> RustBuffer {
    return FfiConverterTypeGetTokensMetadataRequest.lower(value)
}


public struct GetTokensMetadataResponse {
    public var tokensMetadata: [TokenMetadata]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokensMetadata: [TokenMetadata]) {
        self.tokensMetadata = tokensMetadata
    }
}



extension GetTokensMetadataResponse: Equatable, Hashable {
    public static func ==(lhs: GetTokensMetadataResponse, rhs: GetTokensMetadataResponse) -> Bool {
        if lhs.tokensMetadata != rhs.tokensMetadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokensMetadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetTokensMetadataResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetTokensMetadataResponse {
        return
            try GetTokensMetadataResponse(
                tokensMetadata: FfiConverterSequenceTypeTokenMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: GetTokensMetadataResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTokenMetadata.write(value.tokensMetadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataResponse_lift(_ buf: RustBuffer) throws -> GetTokensMetadataResponse {
    return try FfiConverterTypeGetTokensMetadataResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataResponse_lower(_ value: GetTokensMetadataResponse) -> RustBuffer {
    return FfiConverterTypeGetTokensMetadataResponse.lower(value)
}


public struct LightningAddressInfo {
    public var description: String
    public var lightningAddress: String
    public var lnurl: String
    public var username: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String, lightningAddress: String, lnurl: String, username: String) {
        self.description = description
        self.lightningAddress = lightningAddress
        self.lnurl = lnurl
        self.username = username
    }
}



extension LightningAddressInfo: Equatable, Hashable {
    public static func ==(lhs: LightningAddressInfo, rhs: LightningAddressInfo) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.lightningAddress != rhs.lightningAddress {
            return false
        }
        if lhs.lnurl != rhs.lnurl {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(lightningAddress)
        hasher.combine(lnurl)
        hasher.combine(username)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningAddressInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningAddressInfo {
        return
            try LightningAddressInfo(
                description: FfiConverterString.read(from: &buf), 
                lightningAddress: FfiConverterString.read(from: &buf), 
                lnurl: FfiConverterString.read(from: &buf), 
                username: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LightningAddressInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.lightningAddress, into: &buf)
        FfiConverterString.write(value.lnurl, into: &buf)
        FfiConverterString.write(value.username, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressInfo_lift(_ buf: RustBuffer) throws -> LightningAddressInfo {
    return try FfiConverterTypeLightningAddressInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressInfo_lower(_ value: LightningAddressInfo) -> RustBuffer {
    return FfiConverterTypeLightningAddressInfo.lower(value)
}


/**
 * Response from listing fiat currencies
 */
public struct ListFiatCurrenciesResponse {
    /**
     * The list of fiat currencies
     */
    public var currencies: [FiatCurrency]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of fiat currencies
         */currencies: [FiatCurrency]) {
        self.currencies = currencies
    }
}



extension ListFiatCurrenciesResponse: Equatable, Hashable {
    public static func ==(lhs: ListFiatCurrenciesResponse, rhs: ListFiatCurrenciesResponse) -> Bool {
        if lhs.currencies != rhs.currencies {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currencies)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListFiatCurrenciesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListFiatCurrenciesResponse {
        return
            try ListFiatCurrenciesResponse(
                currencies: FfiConverterSequenceTypeFiatCurrency.read(from: &buf)
        )
    }

    public static func write(_ value: ListFiatCurrenciesResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFiatCurrency.write(value.currencies, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatCurrenciesResponse_lift(_ buf: RustBuffer) throws -> ListFiatCurrenciesResponse {
    return try FfiConverterTypeListFiatCurrenciesResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatCurrenciesResponse_lower(_ value: ListFiatCurrenciesResponse) -> RustBuffer {
    return FfiConverterTypeListFiatCurrenciesResponse.lower(value)
}


/**
 * Response from listing fiat rates
 */
public struct ListFiatRatesResponse {
    /**
     * The list of fiat rates
     */
    public var rates: [Rate]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of fiat rates
         */rates: [Rate]) {
        self.rates = rates
    }
}



extension ListFiatRatesResponse: Equatable, Hashable {
    public static func ==(lhs: ListFiatRatesResponse, rhs: ListFiatRatesResponse) -> Bool {
        if lhs.rates != rhs.rates {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rates)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListFiatRatesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListFiatRatesResponse {
        return
            try ListFiatRatesResponse(
                rates: FfiConverterSequenceTypeRate.read(from: &buf)
        )
    }

    public static func write(_ value: ListFiatRatesResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRate.write(value.rates, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatRatesResponse_lift(_ buf: RustBuffer) throws -> ListFiatRatesResponse {
    return try FfiConverterTypeListFiatRatesResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatRatesResponse_lower(_ value: ListFiatRatesResponse) -> RustBuffer {
    return FfiConverterTypeListFiatRatesResponse.lower(value)
}


/**
 * Request to list payments with optional filters and pagination
 */
public struct ListPaymentsRequest {
    public var typeFilter: [PaymentType]?
    public var statusFilter: [PaymentStatus]?
    public var assetFilter: AssetFilter?
    /**
     * Only include payments created after this timestamp (inclusive)
     */
    public var fromTimestamp: UInt64?
    /**
     * Only include payments created before this timestamp (exclusive)
     */
    public var toTimestamp: UInt64?
    /**
     * Number of records to skip
     */
    public var offset: UInt32?
    /**
     * Maximum number of records to return
     */
    public var limit: UInt32?
    public var sortAscending: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typeFilter: [PaymentType]? = nil, statusFilter: [PaymentStatus]? = nil, assetFilter: AssetFilter? = nil, 
        /**
         * Only include payments created after this timestamp (inclusive)
         */fromTimestamp: UInt64? = nil, 
        /**
         * Only include payments created before this timestamp (exclusive)
         */toTimestamp: UInt64? = nil, 
        /**
         * Number of records to skip
         */offset: UInt32? = nil, 
        /**
         * Maximum number of records to return
         */limit: UInt32? = nil, sortAscending: Bool? = nil) {
        self.typeFilter = typeFilter
        self.statusFilter = statusFilter
        self.assetFilter = assetFilter
        self.fromTimestamp = fromTimestamp
        self.toTimestamp = toTimestamp
        self.offset = offset
        self.limit = limit
        self.sortAscending = sortAscending
    }
}



extension ListPaymentsRequest: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsRequest, rhs: ListPaymentsRequest) -> Bool {
        if lhs.typeFilter != rhs.typeFilter {
            return false
        }
        if lhs.statusFilter != rhs.statusFilter {
            return false
        }
        if lhs.assetFilter != rhs.assetFilter {
            return false
        }
        if lhs.fromTimestamp != rhs.fromTimestamp {
            return false
        }
        if lhs.toTimestamp != rhs.toTimestamp {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.sortAscending != rhs.sortAscending {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typeFilter)
        hasher.combine(statusFilter)
        hasher.combine(assetFilter)
        hasher.combine(fromTimestamp)
        hasher.combine(toTimestamp)
        hasher.combine(offset)
        hasher.combine(limit)
        hasher.combine(sortAscending)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListPaymentsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsRequest {
        return
            try ListPaymentsRequest(
                typeFilter: FfiConverterOptionSequenceTypePaymentType.read(from: &buf), 
                statusFilter: FfiConverterOptionSequenceTypePaymentStatus.read(from: &buf), 
                assetFilter: FfiConverterOptionTypeAssetFilter.read(from: &buf), 
                fromTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                toTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                offset: FfiConverterOptionUInt32.read(from: &buf), 
                limit: FfiConverterOptionUInt32.read(from: &buf), 
                sortAscending: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsRequest, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypePaymentType.write(value.typeFilter, into: &buf)
        FfiConverterOptionSequenceTypePaymentStatus.write(value.statusFilter, into: &buf)
        FfiConverterOptionTypeAssetFilter.write(value.assetFilter, into: &buf)
        FfiConverterOptionUInt64.write(value.fromTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.toTimestamp, into: &buf)
        FfiConverterOptionUInt32.write(value.offset, into: &buf)
        FfiConverterOptionUInt32.write(value.limit, into: &buf)
        FfiConverterOptionBool.write(value.sortAscending, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsRequest_lift(_ buf: RustBuffer) throws -> ListPaymentsRequest {
    return try FfiConverterTypeListPaymentsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsRequest_lower(_ value: ListPaymentsRequest) -> RustBuffer {
    return FfiConverterTypeListPaymentsRequest.lower(value)
}


/**
 * Response from listing payments
 */
public struct ListPaymentsResponse {
    /**
     * The list of payments
     */
    public var payments: [Payment]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of payments
         */payments: [Payment]) {
        self.payments = payments
    }
}



extension ListPaymentsResponse: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsResponse, rhs: ListPaymentsResponse) -> Bool {
        if lhs.payments != rhs.payments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payments)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListPaymentsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsResponse {
        return
            try ListPaymentsResponse(
                payments: FfiConverterSequenceTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePayment.write(value.payments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsResponse_lift(_ buf: RustBuffer) throws -> ListPaymentsResponse {
    return try FfiConverterTypeListPaymentsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsResponse_lower(_ value: ListPaymentsResponse) -> RustBuffer {
    return FfiConverterTypeListPaymentsResponse.lower(value)
}


public struct ListUnclaimedDepositsRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension ListUnclaimedDepositsRequest: Equatable, Hashable {
    public static func ==(lhs: ListUnclaimedDepositsRequest, rhs: ListUnclaimedDepositsRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUnclaimedDepositsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUnclaimedDepositsRequest {
        return
            ListUnclaimedDepositsRequest()
    }

    public static func write(_ value: ListUnclaimedDepositsRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsRequest_lift(_ buf: RustBuffer) throws -> ListUnclaimedDepositsRequest {
    return try FfiConverterTypeListUnclaimedDepositsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsRequest_lower(_ value: ListUnclaimedDepositsRequest) -> RustBuffer {
    return FfiConverterTypeListUnclaimedDepositsRequest.lower(value)
}


public struct ListUnclaimedDepositsResponse {
    public var deposits: [DepositInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deposits: [DepositInfo]) {
        self.deposits = deposits
    }
}



extension ListUnclaimedDepositsResponse: Equatable, Hashable {
    public static func ==(lhs: ListUnclaimedDepositsResponse, rhs: ListUnclaimedDepositsResponse) -> Bool {
        if lhs.deposits != rhs.deposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deposits)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUnclaimedDepositsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUnclaimedDepositsResponse {
        return
            try ListUnclaimedDepositsResponse(
                deposits: FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ListUnclaimedDepositsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeDepositInfo.write(value.deposits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsResponse_lift(_ buf: RustBuffer) throws -> ListUnclaimedDepositsResponse {
    return try FfiConverterTypeListUnclaimedDepositsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsResponse_lower(_ value: ListUnclaimedDepositsResponse) -> RustBuffer {
    return FfiConverterTypeListUnclaimedDepositsResponse.lower(value)
}


/**
 * Represents the payment LNURL info
 */
public struct LnurlPayInfo {
    public var lnAddress: String?
    public var comment: String?
    public var domain: String?
    public var metadata: String?
    public var processedSuccessAction: SuccessActionProcessed?
    public var rawSuccessAction: SuccessAction?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lnAddress: String?, comment: String?, domain: String?, metadata: String?, processedSuccessAction: SuccessActionProcessed?, rawSuccessAction: SuccessAction?) {
        self.lnAddress = lnAddress
        self.comment = comment
        self.domain = domain
        self.metadata = metadata
        self.processedSuccessAction = processedSuccessAction
        self.rawSuccessAction = rawSuccessAction
    }
}



extension LnurlPayInfo: Equatable, Hashable {
    public static func ==(lhs: LnurlPayInfo, rhs: LnurlPayInfo) -> Bool {
        if lhs.lnAddress != rhs.lnAddress {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.processedSuccessAction != rhs.processedSuccessAction {
            return false
        }
        if lhs.rawSuccessAction != rhs.rawSuccessAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lnAddress)
        hasher.combine(comment)
        hasher.combine(domain)
        hasher.combine(metadata)
        hasher.combine(processedSuccessAction)
        hasher.combine(rawSuccessAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayInfo {
        return
            try LnurlPayInfo(
                lnAddress: FfiConverterOptionString.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                domain: FfiConverterOptionString.read(from: &buf), 
                metadata: FfiConverterOptionString.read(from: &buf), 
                processedSuccessAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf), 
                rawSuccessAction: FfiConverterOptionTypeSuccessAction.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.lnAddress, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterOptionString.write(value.domain, into: &buf)
        FfiConverterOptionString.write(value.metadata, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.processedSuccessAction, into: &buf)
        FfiConverterOptionTypeSuccessAction.write(value.rawSuccessAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayInfo_lift(_ buf: RustBuffer) throws -> LnurlPayInfo {
    return try FfiConverterTypeLnurlPayInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayInfo_lower(_ value: LnurlPayInfo) -> RustBuffer {
    return FfiConverterTypeLnurlPayInfo.lower(value)
}


public struct LnurlPayRequest {
    public var prepareResponse: PrepareLnurlPayResponse

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prepareResponse: PrepareLnurlPayResponse) {
        self.prepareResponse = prepareResponse
    }
}



extension LnurlPayRequest: Equatable, Hashable {
    public static func ==(lhs: LnurlPayRequest, rhs: LnurlPayRequest) -> Bool {
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prepareResponse)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayRequest {
        return
            try LnurlPayRequest(
                prepareResponse: FfiConverterTypePrepareLnurlPayResponse.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayRequest, into buf: inout [UInt8]) {
        FfiConverterTypePrepareLnurlPayResponse.write(value.prepareResponse, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequest_lift(_ buf: RustBuffer) throws -> LnurlPayRequest {
    return try FfiConverterTypeLnurlPayRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequest_lower(_ value: LnurlPayRequest) -> RustBuffer {
    return FfiConverterTypeLnurlPayRequest.lower(value)
}


public struct LnurlPayResponse {
    public var payment: Payment
    public var successAction: SuccessActionProcessed?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment, successAction: SuccessActionProcessed?) {
        self.payment = payment
        self.successAction = successAction
    }
}



extension LnurlPayResponse: Equatable, Hashable {
    public static func ==(lhs: LnurlPayResponse, rhs: LnurlPayResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        if lhs.successAction != rhs.successAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
        hasher.combine(successAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayResponse {
        return
            try LnurlPayResponse(
                payment: FfiConverterTypePayment.read(from: &buf), 
                successAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.successAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayResponse_lift(_ buf: RustBuffer) throws -> LnurlPayResponse {
    return try FfiConverterTypeLnurlPayResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayResponse_lower(_ value: LnurlPayResponse) -> RustBuffer {
    return FfiConverterTypeLnurlPayResponse.lower(value)
}


/**
 * Represents the withdraw LNURL info
 */
public struct LnurlWithdrawInfo {
    public var withdrawUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(withdrawUrl: String) {
        self.withdrawUrl = withdrawUrl
    }
}



extension LnurlWithdrawInfo: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawInfo, rhs: LnurlWithdrawInfo) -> Bool {
        if lhs.withdrawUrl != rhs.withdrawUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(withdrawUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawInfo {
        return
            try LnurlWithdrawInfo(
                withdrawUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.withdrawUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawInfo_lift(_ buf: RustBuffer) throws -> LnurlWithdrawInfo {
    return try FfiConverterTypeLnurlWithdrawInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawInfo_lower(_ value: LnurlWithdrawInfo) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawInfo.lower(value)
}


public struct LnurlWithdrawRequest {
    /**
     * The amount to withdraw in satoshis
     * Must be within the min and max withdrawable limits
     */
    public var amountSats: UInt64
    public var withdrawRequest: LnurlWithdrawRequestDetails
    /**
     * If set, the function will return the payment if it is still pending after this
     * number of seconds. If unset, the function will return immediately after
     * initiating the LNURL withdraw.
     */
    public var completionTimeoutSecs: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The amount to withdraw in satoshis
         * Must be within the min and max withdrawable limits
         */amountSats: UInt64, withdrawRequest: LnurlWithdrawRequestDetails, 
        /**
         * If set, the function will return the payment if it is still pending after this
         * number of seconds. If unset, the function will return immediately after
         * initiating the LNURL withdraw.
         */completionTimeoutSecs: UInt32? = nil) {
        self.amountSats = amountSats
        self.withdrawRequest = withdrawRequest
        self.completionTimeoutSecs = completionTimeoutSecs
    }
}



extension LnurlWithdrawRequest: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawRequest, rhs: LnurlWithdrawRequest) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.withdrawRequest != rhs.withdrawRequest {
            return false
        }
        if lhs.completionTimeoutSecs != rhs.completionTimeoutSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(withdrawRequest)
        hasher.combine(completionTimeoutSecs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawRequest {
        return
            try LnurlWithdrawRequest(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                withdrawRequest: FfiConverterTypeLnurlWithdrawRequestDetails.read(from: &buf), 
                completionTimeoutSecs: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterTypeLnurlWithdrawRequestDetails.write(value.withdrawRequest, into: &buf)
        FfiConverterOptionUInt32.write(value.completionTimeoutSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequest_lift(_ buf: RustBuffer) throws -> LnurlWithdrawRequest {
    return try FfiConverterTypeLnurlWithdrawRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequest_lower(_ value: LnurlWithdrawRequest) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawRequest.lower(value)
}


public struct LnurlWithdrawResponse {
    /**
     * The Lightning invoice generated for the LNURL withdraw
     */
    public var paymentRequest: String
    public var payment: Payment?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The Lightning invoice generated for the LNURL withdraw
         */paymentRequest: String, payment: Payment?) {
        self.paymentRequest = paymentRequest
        self.payment = payment
    }
}



extension LnurlWithdrawResponse: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawResponse, rhs: LnurlWithdrawResponse) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawResponse {
        return
            try LnurlWithdrawResponse(
                paymentRequest: FfiConverterString.read(from: &buf), 
                payment: FfiConverterOptionTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterOptionTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawResponse_lift(_ buf: RustBuffer) throws -> LnurlWithdrawResponse {
    return try FfiConverterTypeLnurlWithdrawResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawResponse_lower(_ value: LnurlWithdrawResponse) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawResponse.lower(value)
}


public struct LogEntry {
    public var line: String
    public var level: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(line: String, level: String) {
        self.line = line
        self.level = level
    }
}



extension LogEntry: Equatable, Hashable {
    public static func ==(lhs: LogEntry, rhs: LogEntry) -> Bool {
        if lhs.line != rhs.line {
            return false
        }
        if lhs.level != rhs.level {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(line)
        hasher.combine(level)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogEntry {
        return
            try LogEntry(
                line: FfiConverterString.read(from: &buf), 
                level: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LogEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.line, into: &buf)
        FfiConverterString.write(value.level, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogEntry_lift(_ buf: RustBuffer) throws -> LogEntry {
    return try FfiConverterTypeLogEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogEntry_lower(_ value: LogEntry) -> RustBuffer {
    return FfiConverterTypeLogEntry.lower(value)
}


/**
 * Represents a payment (sent or received)
 */
public struct Payment {
    /**
     * Unique identifier for the payment
     */
    public var id: String
    /**
     * Type of payment (send or receive)
     */
    public var paymentType: PaymentType
    /**
     * Status of the payment
     */
    public var status: PaymentStatus
    /**
     * Amount in satoshis or token base units
     */
    public var amount: U128
    /**
     * Fee paid in satoshis or token base units
     */
    public var fees: U128
    /**
     * Timestamp of when the payment was created
     */
    public var timestamp: UInt64
    /**
     * Method of payment. Sometimes the payment details is empty so this field
     * is used to determine the payment method.
     */
    public var method: PaymentMethod
    /**
     * Details of the payment
     */
    public var details: PaymentDetails?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for the payment
         */id: String, 
        /**
         * Type of payment (send or receive)
         */paymentType: PaymentType, 
        /**
         * Status of the payment
         */status: PaymentStatus, 
        /**
         * Amount in satoshis or token base units
         */amount: U128, 
        /**
         * Fee paid in satoshis or token base units
         */fees: U128, 
        /**
         * Timestamp of when the payment was created
         */timestamp: UInt64, 
        /**
         * Method of payment. Sometimes the payment details is empty so this field
         * is used to determine the payment method.
         */method: PaymentMethod, 
        /**
         * Details of the payment
         */details: PaymentDetails?) {
        self.id = id
        self.paymentType = paymentType
        self.status = status
        self.amount = amount
        self.fees = fees
        self.timestamp = timestamp
        self.method = method
        self.details = details
    }
}



extension Payment: Equatable, Hashable {
    public static func ==(lhs: Payment, rhs: Payment) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.paymentType != rhs.paymentType {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(paymentType)
        hasher.combine(status)
        hasher.combine(amount)
        hasher.combine(fees)
        hasher.combine(timestamp)
        hasher.combine(method)
        hasher.combine(details)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return
            try Payment(
                id: FfiConverterString.read(from: &buf), 
                paymentType: FfiConverterTypePaymentType.read(from: &buf), 
                status: FfiConverterTypePaymentStatus.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                fees: FfiConverterTypeu128.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                method: FfiConverterTypePaymentMethod.read(from: &buf), 
                details: FfiConverterOptionTypePaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypePaymentType.write(value.paymentType, into: &buf)
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterTypeu128.write(value.fees, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterTypePaymentMethod.write(value.method, into: &buf)
        FfiConverterOptionTypePaymentDetails.write(value.details, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayment_lift(_ buf: RustBuffer) throws -> Payment {
    return try FfiConverterTypePayment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayment_lower(_ value: Payment) -> RustBuffer {
    return FfiConverterTypePayment.lower(value)
}


/**
 * Metadata associated with a payment that cannot be extracted from the Spark operator.
 */
public struct PaymentMetadata {
    public var lnurlPayInfo: LnurlPayInfo?
    public var lnurlWithdrawInfo: LnurlWithdrawInfo?
    public var lnurlDescription: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lnurlPayInfo: LnurlPayInfo?, lnurlWithdrawInfo: LnurlWithdrawInfo?, lnurlDescription: String?) {
        self.lnurlPayInfo = lnurlPayInfo
        self.lnurlWithdrawInfo = lnurlWithdrawInfo
        self.lnurlDescription = lnurlDescription
    }
}



extension PaymentMetadata: Equatable, Hashable {
    public static func ==(lhs: PaymentMetadata, rhs: PaymentMetadata) -> Bool {
        if lhs.lnurlPayInfo != rhs.lnurlPayInfo {
            return false
        }
        if lhs.lnurlWithdrawInfo != rhs.lnurlWithdrawInfo {
            return false
        }
        if lhs.lnurlDescription != rhs.lnurlDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lnurlPayInfo)
        hasher.combine(lnurlWithdrawInfo)
        hasher.combine(lnurlDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMetadata {
        return
            try PaymentMetadata(
                lnurlPayInfo: FfiConverterOptionTypeLnurlPayInfo.read(from: &buf), 
                lnurlWithdrawInfo: FfiConverterOptionTypeLnurlWithdrawInfo.read(from: &buf), 
                lnurlDescription: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionTypeLnurlPayInfo.write(value.lnurlPayInfo, into: &buf)
        FfiConverterOptionTypeLnurlWithdrawInfo.write(value.lnurlWithdrawInfo, into: &buf)
        FfiConverterOptionString.write(value.lnurlDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lift(_ buf: RustBuffer) throws -> PaymentMetadata {
    return try FfiConverterTypePaymentMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lower(_ value: PaymentMetadata) -> RustBuffer {
    return FfiConverterTypePaymentMetadata.lower(value)
}


public struct PrepareLnurlPayRequest {
    public var amountSats: UInt64
    public var payRequest: LnurlPayRequestDetails
    public var comment: String?
    public var validateSuccessActionUrl: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSats: UInt64, payRequest: LnurlPayRequestDetails, comment: String? = nil, validateSuccessActionUrl: Bool? = nil) {
        self.amountSats = amountSats
        self.payRequest = payRequest
        self.comment = comment
        self.validateSuccessActionUrl = validateSuccessActionUrl
    }
}



extension PrepareLnurlPayRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareLnurlPayRequest, rhs: PrepareLnurlPayRequest) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.validateSuccessActionUrl != rhs.validateSuccessActionUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(payRequest)
        hasher.combine(comment)
        hasher.combine(validateSuccessActionUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareLnurlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareLnurlPayRequest {
        return
            try PrepareLnurlPayRequest(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                validateSuccessActionUrl: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareLnurlPayRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterOptionBool.write(value.validateSuccessActionUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayRequest_lift(_ buf: RustBuffer) throws -> PrepareLnurlPayRequest {
    return try FfiConverterTypePrepareLnurlPayRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayRequest_lower(_ value: PrepareLnurlPayRequest) -> RustBuffer {
    return FfiConverterTypePrepareLnurlPayRequest.lower(value)
}


public struct PrepareLnurlPayResponse {
    public var amountSats: UInt64
    public var comment: String?
    public var payRequest: LnurlPayRequestDetails
    public var feeSats: UInt64
    public var invoiceDetails: Bolt11InvoiceDetails
    public var successAction: SuccessAction?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSats: UInt64, comment: String?, payRequest: LnurlPayRequestDetails, feeSats: UInt64, invoiceDetails: Bolt11InvoiceDetails, successAction: SuccessAction?) {
        self.amountSats = amountSats
        self.comment = comment
        self.payRequest = payRequest
        self.feeSats = feeSats
        self.invoiceDetails = invoiceDetails
        self.successAction = successAction
    }
}



extension PrepareLnurlPayResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareLnurlPayResponse, rhs: PrepareLnurlPayResponse) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        if lhs.feeSats != rhs.feeSats {
            return false
        }
        if lhs.invoiceDetails != rhs.invoiceDetails {
            return false
        }
        if lhs.successAction != rhs.successAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(comment)
        hasher.combine(payRequest)
        hasher.combine(feeSats)
        hasher.combine(invoiceDetails)
        hasher.combine(successAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareLnurlPayResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareLnurlPayResponse {
        return
            try PrepareLnurlPayResponse(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf), 
                feeSats: FfiConverterUInt64.read(from: &buf), 
                invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from: &buf), 
                successAction: FfiConverterOptionTypeSuccessAction.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareLnurlPayResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
        FfiConverterUInt64.write(value.feeSats, into: &buf)
        FfiConverterTypeBolt11InvoiceDetails.write(value.invoiceDetails, into: &buf)
        FfiConverterOptionTypeSuccessAction.write(value.successAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayResponse_lift(_ buf: RustBuffer) throws -> PrepareLnurlPayResponse {
    return try FfiConverterTypePrepareLnurlPayResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayResponse_lower(_ value: PrepareLnurlPayResponse) -> RustBuffer {
    return FfiConverterTypePrepareLnurlPayResponse.lower(value)
}


public struct PrepareSendPaymentRequest {
    public var paymentRequest: String
    /**
     * Amount to send. By default is denominated in sats.
     * If a token identifier is provided, the amount will be denominated in the token base units.
     */
    public var amount: U128?
    /**
     * If provided, the payment will be for a token
     * May only be provided if the payment request is a spark address
     */
    public var tokenIdentifier: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentRequest: String, 
        /**
         * Amount to send. By default is denominated in sats.
         * If a token identifier is provided, the amount will be denominated in the token base units.
         */amount: U128? = nil, 
        /**
         * If provided, the payment will be for a token
         * May only be provided if the payment request is a spark address
         */tokenIdentifier: String? = nil) {
        self.paymentRequest = paymentRequest
        self.amount = amount
        self.tokenIdentifier = tokenIdentifier
    }
}



extension PrepareSendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareSendPaymentRequest, rhs: PrepareSendPaymentRequest) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(amount)
        hasher.combine(tokenIdentifier)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSendPaymentRequest {
        return
            try PrepareSendPaymentRequest(
                paymentRequest: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionTypeu128.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterOptionTypeu128.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentRequest_lift(_ buf: RustBuffer) throws -> PrepareSendPaymentRequest {
    return try FfiConverterTypePrepareSendPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentRequest_lower(_ value: PrepareSendPaymentRequest) -> RustBuffer {
    return FfiConverterTypePrepareSendPaymentRequest.lower(value)
}


public struct PrepareSendPaymentResponse {
    public var paymentMethod: SendPaymentMethod
    /**
     * Amount to send. By default is denominated in sats.
     * If a token identifier is provided, the amount will be denominated in the token base units.
     */
    public var amount: U128
    /**
     * The presence of this field indicates that the payment is for a token
     * If empty, it is a Bitcoin payment
     */
    public var tokenIdentifier: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentMethod: SendPaymentMethod, 
        /**
         * Amount to send. By default is denominated in sats.
         * If a token identifier is provided, the amount will be denominated in the token base units.
         */amount: U128, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?) {
        self.paymentMethod = paymentMethod
        self.amount = amount
        self.tokenIdentifier = tokenIdentifier
    }
}



extension PrepareSendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareSendPaymentResponse, rhs: PrepareSendPaymentResponse) -> Bool {
        if lhs.paymentMethod != rhs.paymentMethod {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentMethod)
        hasher.combine(amount)
        hasher.combine(tokenIdentifier)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSendPaymentResponse {
        return
            try PrepareSendPaymentResponse(
                paymentMethod: FfiConverterTypeSendPaymentMethod.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypeSendPaymentMethod.write(value.paymentMethod, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentResponse_lift(_ buf: RustBuffer) throws -> PrepareSendPaymentResponse {
    return try FfiConverterTypePrepareSendPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentResponse_lower(_ value: PrepareSendPaymentResponse) -> RustBuffer {
    return FfiConverterTypePrepareSendPaymentResponse.lower(value)
}


public struct ProvisionalPayment {
    /**
     * Unique identifier for the payment
     */
    public var paymentId: String
    /**
     * Amount in satoshis or token base units
     */
    public var amount: U128
    /**
     * Details of the payment
     */
    public var details: ProvisionalPaymentDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for the payment
         */paymentId: String, 
        /**
         * Amount in satoshis or token base units
         */amount: U128, 
        /**
         * Details of the payment
         */details: ProvisionalPaymentDetails) {
        self.paymentId = paymentId
        self.amount = amount
        self.details = details
    }
}



extension ProvisionalPayment: Equatable, Hashable {
    public static func ==(lhs: ProvisionalPayment, rhs: ProvisionalPayment) -> Bool {
        if lhs.paymentId != rhs.paymentId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentId)
        hasher.combine(amount)
        hasher.combine(details)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProvisionalPayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProvisionalPayment {
        return
            try ProvisionalPayment(
                paymentId: FfiConverterString.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                details: FfiConverterTypeProvisionalPaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: ProvisionalPayment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentId, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterTypeProvisionalPaymentDetails.write(value.details, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPayment_lift(_ buf: RustBuffer) throws -> ProvisionalPayment {
    return try FfiConverterTypeProvisionalPayment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPayment_lower(_ value: ProvisionalPayment) -> RustBuffer {
    return FfiConverterTypeProvisionalPayment.lower(value)
}


public struct ReceivePaymentRequest {
    public var paymentMethod: ReceivePaymentMethod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentMethod: ReceivePaymentMethod) {
        self.paymentMethod = paymentMethod
    }
}



extension ReceivePaymentRequest: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentRequest, rhs: ReceivePaymentRequest) -> Bool {
        if lhs.paymentMethod != rhs.paymentMethod {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentMethod)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentRequest {
        return
            try ReceivePaymentRequest(
                paymentMethod: FfiConverterTypeReceivePaymentMethod.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypeReceivePaymentMethod.write(value.paymentMethod, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentRequest_lift(_ buf: RustBuffer) throws -> ReceivePaymentRequest {
    return try FfiConverterTypeReceivePaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentRequest_lower(_ value: ReceivePaymentRequest) -> RustBuffer {
    return FfiConverterTypeReceivePaymentRequest.lower(value)
}


public struct ReceivePaymentResponse {
    public var paymentRequest: String
    /**
     * Fee to pay to receive the payment
     * Denominated in sats or token base units
     */
    public var fee: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentRequest: String, 
        /**
         * Fee to pay to receive the payment
         * Denominated in sats or token base units
         */fee: U128) {
        self.paymentRequest = paymentRequest
        self.fee = fee
    }
}



extension ReceivePaymentResponse: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentResponse, rhs: ReceivePaymentResponse) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(fee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentResponse {
        return
            try ReceivePaymentResponse(
                paymentRequest: FfiConverterString.read(from: &buf), 
                fee: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterTypeu128.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentResponse_lift(_ buf: RustBuffer) throws -> ReceivePaymentResponse {
    return try FfiConverterTypeReceivePaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentResponse_lower(_ value: ReceivePaymentResponse) -> RustBuffer {
    return FfiConverterTypeReceivePaymentResponse.lower(value)
}


public struct RefundDepositRequest {
    public var txid: String
    public var vout: UInt32
    public var destinationAddress: String
    public var fee: Fee

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, destinationAddress: String, fee: Fee) {
        self.txid = txid
        self.vout = vout
        self.destinationAddress = destinationAddress
        self.fee = fee
    }
}



extension RefundDepositRequest: Equatable, Hashable {
    public static func ==(lhs: RefundDepositRequest, rhs: RefundDepositRequest) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.destinationAddress != rhs.destinationAddress {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(destinationAddress)
        hasher.combine(fee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefundDepositRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundDepositRequest {
        return
            try RefundDepositRequest(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                destinationAddress: FfiConverterString.read(from: &buf), 
                fee: FfiConverterTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: RefundDepositRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterString.write(value.destinationAddress, into: &buf)
        FfiConverterTypeFee.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositRequest_lift(_ buf: RustBuffer) throws -> RefundDepositRequest {
    return try FfiConverterTypeRefundDepositRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositRequest_lower(_ value: RefundDepositRequest) -> RustBuffer {
    return FfiConverterTypeRefundDepositRequest.lower(value)
}


public struct RefundDepositResponse {
    public var txId: String
    public var txHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txId: String, txHex: String) {
        self.txId = txId
        self.txHex = txHex
    }
}



extension RefundDepositResponse: Equatable, Hashable {
    public static func ==(lhs: RefundDepositResponse, rhs: RefundDepositResponse) -> Bool {
        if lhs.txId != rhs.txId {
            return false
        }
        if lhs.txHex != rhs.txHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txId)
        hasher.combine(txHex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefundDepositResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundDepositResponse {
        return
            try RefundDepositResponse(
                txId: FfiConverterString.read(from: &buf), 
                txHex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RefundDepositResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txId, into: &buf)
        FfiConverterString.write(value.txHex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositResponse_lift(_ buf: RustBuffer) throws -> RefundDepositResponse {
    return try FfiConverterTypeRefundDepositResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositResponse_lower(_ value: RefundDepositResponse) -> RustBuffer {
    return FfiConverterTypeRefundDepositResponse.lower(value)
}


public struct RegisterLightningAddressRequest {
    public var username: String
    public var description: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String, description: String? = nil) {
        self.username = username
        self.description = description
    }
}



extension RegisterLightningAddressRequest: Equatable, Hashable {
    public static func ==(lhs: RegisterLightningAddressRequest, rhs: RegisterLightningAddressRequest) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(description)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRegisterLightningAddressRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterLightningAddressRequest {
        return
            try RegisterLightningAddressRequest(
                username: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterLightningAddressRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRegisterLightningAddressRequest_lift(_ buf: RustBuffer) throws -> RegisterLightningAddressRequest {
    return try FfiConverterTypeRegisterLightningAddressRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRegisterLightningAddressRequest_lower(_ value: RegisterLightningAddressRequest) -> RustBuffer {
    return FfiConverterTypeRegisterLightningAddressRequest.lower(value)
}


public struct SendOnchainFeeQuote {
    public var id: String
    public var expiresAt: UInt64
    public var speedFast: SendOnchainSpeedFeeQuote
    public var speedMedium: SendOnchainSpeedFeeQuote
    public var speedSlow: SendOnchainSpeedFeeQuote

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, expiresAt: UInt64, speedFast: SendOnchainSpeedFeeQuote, speedMedium: SendOnchainSpeedFeeQuote, speedSlow: SendOnchainSpeedFeeQuote) {
        self.id = id
        self.expiresAt = expiresAt
        self.speedFast = speedFast
        self.speedMedium = speedMedium
        self.speedSlow = speedSlow
    }
}



extension SendOnchainFeeQuote: Equatable, Hashable {
    public static func ==(lhs: SendOnchainFeeQuote, rhs: SendOnchainFeeQuote) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        if lhs.speedFast != rhs.speedFast {
            return false
        }
        if lhs.speedMedium != rhs.speedMedium {
            return false
        }
        if lhs.speedSlow != rhs.speedSlow {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(expiresAt)
        hasher.combine(speedFast)
        hasher.combine(speedMedium)
        hasher.combine(speedSlow)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendOnchainFeeQuote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainFeeQuote {
        return
            try SendOnchainFeeQuote(
                id: FfiConverterString.read(from: &buf), 
                expiresAt: FfiConverterUInt64.read(from: &buf), 
                speedFast: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf), 
                speedMedium: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf), 
                speedSlow: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainFeeQuote, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.expiresAt, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedFast, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedMedium, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedSlow, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainFeeQuote_lift(_ buf: RustBuffer) throws -> SendOnchainFeeQuote {
    return try FfiConverterTypeSendOnchainFeeQuote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainFeeQuote_lower(_ value: SendOnchainFeeQuote) -> RustBuffer {
    return FfiConverterTypeSendOnchainFeeQuote.lower(value)
}


public struct SendOnchainSpeedFeeQuote {
    public var userFeeSat: UInt64
    public var l1BroadcastFeeSat: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userFeeSat: UInt64, l1BroadcastFeeSat: UInt64) {
        self.userFeeSat = userFeeSat
        self.l1BroadcastFeeSat = l1BroadcastFeeSat
    }
}



extension SendOnchainSpeedFeeQuote: Equatable, Hashable {
    public static func ==(lhs: SendOnchainSpeedFeeQuote, rhs: SendOnchainSpeedFeeQuote) -> Bool {
        if lhs.userFeeSat != rhs.userFeeSat {
            return false
        }
        if lhs.l1BroadcastFeeSat != rhs.l1BroadcastFeeSat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userFeeSat)
        hasher.combine(l1BroadcastFeeSat)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendOnchainSpeedFeeQuote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainSpeedFeeQuote {
        return
            try SendOnchainSpeedFeeQuote(
                userFeeSat: FfiConverterUInt64.read(from: &buf), 
                l1BroadcastFeeSat: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainSpeedFeeQuote, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.userFeeSat, into: &buf)
        FfiConverterUInt64.write(value.l1BroadcastFeeSat, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainSpeedFeeQuote_lift(_ buf: RustBuffer) throws -> SendOnchainSpeedFeeQuote {
    return try FfiConverterTypeSendOnchainSpeedFeeQuote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainSpeedFeeQuote_lower(_ value: SendOnchainSpeedFeeQuote) -> RustBuffer {
    return FfiConverterTypeSendOnchainSpeedFeeQuote.lower(value)
}


public struct SendPaymentRequest {
    public var prepareResponse: PrepareSendPaymentResponse
    public var options: SendPaymentOptions?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prepareResponse: PrepareSendPaymentResponse, options: SendPaymentOptions? = nil) {
        self.prepareResponse = prepareResponse
        self.options = options
    }
}



extension SendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: SendPaymentRequest, rhs: SendPaymentRequest) -> Bool {
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        if lhs.options != rhs.options {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prepareResponse)
        hasher.combine(options)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentRequest {
        return
            try SendPaymentRequest(
                prepareResponse: FfiConverterTypePrepareSendPaymentResponse.read(from: &buf), 
                options: FfiConverterOptionTypeSendPaymentOptions.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypePrepareSendPaymentResponse.write(value.prepareResponse, into: &buf)
        FfiConverterOptionTypeSendPaymentOptions.write(value.options, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentRequest_lift(_ buf: RustBuffer) throws -> SendPaymentRequest {
    return try FfiConverterTypeSendPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentRequest_lower(_ value: SendPaymentRequest) -> RustBuffer {
    return FfiConverterTypeSendPaymentRequest.lower(value)
}


public struct SendPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension SendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: SendPaymentResponse, rhs: SendPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentResponse {
        return
            try SendPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentResponse_lift(_ buf: RustBuffer) throws -> SendPaymentResponse {
    return try FfiConverterTypeSendPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentResponse_lower(_ value: SendPaymentResponse) -> RustBuffer {
    return FfiConverterTypeSendPaymentResponse.lower(value)
}


public struct SignMessageRequest {
    public var message: String
    /**
     * If true, the signature will be encoded in compact format instead of DER format
     */
    public var compact: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String, 
        /**
         * If true, the signature will be encoded in compact format instead of DER format
         */compact: Bool) {
        self.message = message
        self.compact = compact
    }
}



extension SignMessageRequest: Equatable, Hashable {
    public static func ==(lhs: SignMessageRequest, rhs: SignMessageRequest) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.compact != rhs.compact {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(compact)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageRequest {
        return
            try SignMessageRequest(
                message: FfiConverterString.read(from: &buf), 
                compact: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterBool.write(value.compact, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageRequest_lift(_ buf: RustBuffer) throws -> SignMessageRequest {
    return try FfiConverterTypeSignMessageRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageRequest_lower(_ value: SignMessageRequest) -> RustBuffer {
    return FfiConverterTypeSignMessageRequest.lower(value)
}


public struct SignMessageResponse {
    public var pubkey: String
    /**
     * The DER or compact hex encoded signature
     */
    public var signature: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pubkey: String, 
        /**
         * The DER or compact hex encoded signature
         */signature: String) {
        self.pubkey = pubkey
        self.signature = signature
    }
}



extension SignMessageResponse: Equatable, Hashable {
    public static func ==(lhs: SignMessageResponse, rhs: SignMessageResponse) -> Bool {
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pubkey)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignMessageResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageResponse {
        return
            try SignMessageResponse(
                pubkey: FfiConverterString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageResponse_lift(_ buf: RustBuffer) throws -> SignMessageResponse {
    return try FfiConverterTypeSignMessageResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageResponse_lower(_ value: SignMessageResponse) -> RustBuffer {
    return FfiConverterTypeSignMessageResponse.lower(value)
}


public struct SparkInvoicePaymentDetails {
    /**
     * Represents the spark invoice description
     */
    public var description: String?
    /**
     * The raw spark invoice string
     */
    public var invoice: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Represents the spark invoice description
         */description: String?, 
        /**
         * The raw spark invoice string
         */invoice: String) {
        self.description = description
        self.invoice = invoice
    }
}



extension SparkInvoicePaymentDetails: Equatable, Hashable {
    public static func ==(lhs: SparkInvoicePaymentDetails, rhs: SparkInvoicePaymentDetails) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(invoice)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkInvoicePaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkInvoicePaymentDetails {
        return
            try SparkInvoicePaymentDetails(
                description: FfiConverterOptionString.read(from: &buf), 
                invoice: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SparkInvoicePaymentDetails, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterString.write(value.invoice, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoicePaymentDetails_lift(_ buf: RustBuffer) throws -> SparkInvoicePaymentDetails {
    return try FfiConverterTypeSparkInvoicePaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoicePaymentDetails_lower(_ value: SparkInvoicePaymentDetails) -> RustBuffer {
    return FfiConverterTypeSparkInvoicePaymentDetails.lower(value)
}


/**
 * Request to sync the wallet with the Spark network
 */
public struct SyncWalletRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension SyncWalletRequest: Equatable, Hashable {
    public static func ==(lhs: SyncWalletRequest, rhs: SyncWalletRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncWalletRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncWalletRequest {
        return
            SyncWalletRequest()
    }

    public static func write(_ value: SyncWalletRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletRequest_lift(_ buf: RustBuffer) throws -> SyncWalletRequest {
    return try FfiConverterTypeSyncWalletRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletRequest_lower(_ value: SyncWalletRequest) -> RustBuffer {
    return FfiConverterTypeSyncWalletRequest.lower(value)
}


/**
 * Response from synchronizing the wallet
 */
public struct SyncWalletResponse {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension SyncWalletResponse: Equatable, Hashable {
    public static func ==(lhs: SyncWalletResponse, rhs: SyncWalletResponse) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncWalletResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncWalletResponse {
        return
            SyncWalletResponse()
    }

    public static func write(_ value: SyncWalletResponse, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletResponse_lift(_ buf: RustBuffer) throws -> SyncWalletResponse {
    return try FfiConverterTypeSyncWalletResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletResponse_lower(_ value: SyncWalletResponse) -> RustBuffer {
    return FfiConverterTypeSyncWalletResponse.lower(value)
}


public struct TokenBalance {
    public var balance: U128
    public var tokenMetadata: TokenMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(balance: U128, tokenMetadata: TokenMetadata) {
        self.balance = balance
        self.tokenMetadata = tokenMetadata
    }
}



extension TokenBalance: Equatable, Hashable {
    public static func ==(lhs: TokenBalance, rhs: TokenBalance) -> Bool {
        if lhs.balance != rhs.balance {
            return false
        }
        if lhs.tokenMetadata != rhs.tokenMetadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balance)
        hasher.combine(tokenMetadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenBalance {
        return
            try TokenBalance(
                balance: FfiConverterTypeu128.read(from: &buf), 
                tokenMetadata: FfiConverterTypeTokenMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: TokenBalance, into buf: inout [UInt8]) {
        FfiConverterTypeu128.write(value.balance, into: &buf)
        FfiConverterTypeTokenMetadata.write(value.tokenMetadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalance_lift(_ buf: RustBuffer) throws -> TokenBalance {
    return try FfiConverterTypeTokenBalance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalance_lower(_ value: TokenBalance) -> RustBuffer {
    return FfiConverterTypeTokenBalance.lower(value)
}


public struct TokenMetadata {
    public var identifier: String
    /**
     * Hex representation of the issuer public key
     */
    public var issuerPublicKey: String
    public var name: String
    public var ticker: String
    /**
     * Number of decimals the token uses
     */
    public var decimals: UInt32
    public var maxSupply: U128
    public var isFreezable: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: String, 
        /**
         * Hex representation of the issuer public key
         */issuerPublicKey: String, name: String, ticker: String, 
        /**
         * Number of decimals the token uses
         */decimals: UInt32, maxSupply: U128, isFreezable: Bool) {
        self.identifier = identifier
        self.issuerPublicKey = issuerPublicKey
        self.name = name
        self.ticker = ticker
        self.decimals = decimals
        self.maxSupply = maxSupply
        self.isFreezable = isFreezable
    }
}



extension TokenMetadata: Equatable, Hashable {
    public static func ==(lhs: TokenMetadata, rhs: TokenMetadata) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.issuerPublicKey != rhs.issuerPublicKey {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.maxSupply != rhs.maxSupply {
            return false
        }
        if lhs.isFreezable != rhs.isFreezable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(issuerPublicKey)
        hasher.combine(name)
        hasher.combine(ticker)
        hasher.combine(decimals)
        hasher.combine(maxSupply)
        hasher.combine(isFreezable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenMetadata {
        return
            try TokenMetadata(
                identifier: FfiConverterString.read(from: &buf), 
                issuerPublicKey: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                ticker: FfiConverterString.read(from: &buf), 
                decimals: FfiConverterUInt32.read(from: &buf), 
                maxSupply: FfiConverterTypeu128.read(from: &buf), 
                isFreezable: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TokenMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterString.write(value.issuerPublicKey, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.ticker, into: &buf)
        FfiConverterUInt32.write(value.decimals, into: &buf)
        FfiConverterTypeu128.write(value.maxSupply, into: &buf)
        FfiConverterBool.write(value.isFreezable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenMetadata_lift(_ buf: RustBuffer) throws -> TokenMetadata {
    return try FfiConverterTypeTokenMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenMetadata_lower(_ value: TokenMetadata) -> RustBuffer {
    return FfiConverterTypeTokenMetadata.lower(value)
}


public struct TxStatus {
    public var confirmed: Bool
    public var blockHeight: UInt32?
    public var blockTime: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(confirmed: Bool, blockHeight: UInt32?, blockTime: UInt64?) {
        self.confirmed = confirmed
        self.blockHeight = blockHeight
        self.blockTime = blockTime
    }
}



extension TxStatus: Equatable, Hashable {
    public static func ==(lhs: TxStatus, rhs: TxStatus) -> Bool {
        if lhs.confirmed != rhs.confirmed {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.blockTime != rhs.blockTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(confirmed)
        hasher.combine(blockHeight)
        hasher.combine(blockTime)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxStatus {
        return
            try TxStatus(
                confirmed: FfiConverterBool.read(from: &buf), 
                blockHeight: FfiConverterOptionUInt32.read(from: &buf), 
                blockTime: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TxStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.confirmed, into: &buf)
        FfiConverterOptionUInt32.write(value.blockHeight, into: &buf)
        FfiConverterOptionUInt64.write(value.blockTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lift(_ buf: RustBuffer) throws -> TxStatus {
    return try FfiConverterTypeTxStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lower(_ value: TxStatus) -> RustBuffer {
    return FfiConverterTypeTxStatus.lower(value)
}


public struct Utxo {
    public var txid: String
    public var vout: UInt32
    public var value: UInt64
    public var status: TxStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, value: UInt64, status: TxStatus) {
        self.txid = txid
        self.vout = vout
        self.value = value
        self.status = status
    }
}



extension Utxo: Equatable, Hashable {
    public static func ==(lhs: Utxo, rhs: Utxo) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(value)
        hasher.combine(status)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Utxo {
        return
            try Utxo(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                value: FfiConverterUInt64.read(from: &buf), 
                status: FfiConverterTypeTxStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Utxo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.value, into: &buf)
        FfiConverterTypeTxStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lift(_ buf: RustBuffer) throws -> Utxo {
    return try FfiConverterTypeUtxo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lower(_ value: Utxo) -> RustBuffer {
    return FfiConverterTypeUtxo.lower(value)
}


public struct WaitForPaymentRequest {
    public var identifier: WaitForPaymentIdentifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: WaitForPaymentIdentifier) {
        self.identifier = identifier
    }
}



extension WaitForPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: WaitForPaymentRequest, rhs: WaitForPaymentRequest) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWaitForPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WaitForPaymentRequest {
        return
            try WaitForPaymentRequest(
                identifier: FfiConverterTypeWaitForPaymentIdentifier.read(from: &buf)
        )
    }

    public static func write(_ value: WaitForPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypeWaitForPaymentIdentifier.write(value.identifier, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWaitForPaymentRequest_lift(_ buf: RustBuffer) throws -> WaitForPaymentRequest {
    return try FfiConverterTypeWaitForPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWaitForPaymentRequest_lower(_ value: WaitForPaymentRequest) -> RustBuffer {
    return FfiConverterTypeWaitForPaymentRequest.lower(value)
}


public struct WaitForPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension WaitForPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: WaitForPaymentResponse, rhs: WaitForPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWaitForPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WaitForPaymentResponse {
        return
            try WaitForPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: WaitForPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWaitForPaymentResponse_lift(_ buf: RustBuffer) throws -> WaitForPaymentResponse {
    return try FfiConverterTypeWaitForPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWaitForPaymentResponse_lower(_ value: WaitForPaymentResponse) -> RustBuffer {
    return FfiConverterTypeWaitForPaymentResponse.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */

public enum AssetFilter {
    
    case bitcoin
    case token(
        /**
         * Optional token identifier to filter by
         */tokenIdentifier: String?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAssetFilter: FfiConverterRustBuffer {
    typealias SwiftType = AssetFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .token(tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case let .token(tokenIdentifier):
            writeInt(&buf, Int32(2))
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetFilter_lift(_ buf: RustBuffer) throws -> AssetFilter {
    return try FfiConverterTypeAssetFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetFilter_lower(_ value: AssetFilter) -> RustBuffer {
    return FfiConverterTypeAssetFilter.lower(value)
}



extension AssetFilter: Equatable, Hashable {}




public enum ChainServiceError {

    
    
    case InvalidAddress(String
    )
    case ServiceConnectivity(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainServiceError: FfiConverterRustBuffer {
    typealias SwiftType = ChainServiceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainServiceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidAddress(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ServiceConnectivity(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChainServiceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ServiceConnectivity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ChainServiceError: Equatable, Hashable {}

extension ChainServiceError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DepositClaimError {
    
    case depositClaimFeeExceeded(tx: String, vout: UInt32, maxFee: Fee?, actualFee: UInt64
    )
    case missingUtxo(tx: String, vout: UInt32
    )
    case generic(message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositClaimError: FfiConverterRustBuffer {
    typealias SwiftType = DepositClaimError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositClaimError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .depositClaimFeeExceeded(tx: try FfiConverterString.read(from: &buf), vout: try FfiConverterUInt32.read(from: &buf), maxFee: try FfiConverterOptionTypeFee.read(from: &buf), actualFee: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .missingUtxo(tx: try FfiConverterString.read(from: &buf), vout: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .generic(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositClaimError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .depositClaimFeeExceeded(tx,vout,maxFee,actualFee):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            FfiConverterOptionTypeFee.write(maxFee, into: &buf)
            FfiConverterUInt64.write(actualFee, into: &buf)
            
        
        case let .missingUtxo(tx,vout):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            
        
        case let .generic(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositClaimError_lift(_ buf: RustBuffer) throws -> DepositClaimError {
    return try FfiConverterTypeDepositClaimError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositClaimError_lower(_ value: DepositClaimError) -> RustBuffer {
    return FfiConverterTypeDepositClaimError.lower(value)
}



extension DepositClaimError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Fee {
    
    case fixed(amount: UInt64
    )
    case rate(satPerVbyte: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFee: FfiConverterRustBuffer {
    typealias SwiftType = Fee

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fee {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fixed(amount: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .rate(satPerVbyte: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Fee, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fixed(amount):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amount, into: &buf)
            
        
        case let .rate(satPerVbyte):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(satPerVbyte, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lift(_ buf: RustBuffer) throws -> Fee {
    return try FfiConverterTypeFee.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lower(_ value: Fee) -> RustBuffer {
    return FfiConverterTypeFee.lower(value)
}



extension Fee: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum KeySetType {
    
    case `default`
    case taproot
    case nativeSegwit
    case wrappedSegwit
    case legacy
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeySetType: FfiConverterRustBuffer {
    typealias SwiftType = KeySetType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySetType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .taproot
        
        case 3: return .nativeSegwit
        
        case 4: return .wrappedSegwit
        
        case 5: return .legacy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeySetType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .taproot:
            writeInt(&buf, Int32(2))
        
        
        case .nativeSegwit:
            writeInt(&buf, Int32(3))
        
        
        case .wrappedSegwit:
            writeInt(&buf, Int32(4))
        
        
        case .legacy:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySetType_lift(_ buf: RustBuffer) throws -> KeySetType {
    return try FfiConverterTypeKeySetType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySetType_lower(_ value: KeySetType) -> RustBuffer {
    return FfiConverterTypeKeySetType.lower(value)
}



extension KeySetType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case mainnet
    case regtest
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .regtest:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OnchainConfirmationSpeed {
    
    case fast
    case medium
    case slow
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnchainConfirmationSpeed: FfiConverterRustBuffer {
    typealias SwiftType = OnchainConfirmationSpeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainConfirmationSpeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fast
        
        case 2: return .medium
        
        case 3: return .slow
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OnchainConfirmationSpeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fast:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .slow:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainConfirmationSpeed_lift(_ buf: RustBuffer) throws -> OnchainConfirmationSpeed {
    return try FfiConverterTypeOnchainConfirmationSpeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainConfirmationSpeed_lower(_ value: OnchainConfirmationSpeed) -> RustBuffer {
    return FfiConverterTypeOnchainConfirmationSpeed.lower(value)
}



extension OnchainConfirmationSpeed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentDetails {
    
    case spark(
        /**
         * The invoice details if the payment fulfilled a spark invoice
         */invoiceDetails: SparkInvoicePaymentDetails?
    )
    case token(metadata: TokenMetadata, txHash: String, 
        /**
         * The invoice details if the payment fulfilled a spark invoice
         */invoiceDetails: SparkInvoicePaymentDetails?
    )
    case lightning(
        /**
         * Represents the invoice description
         */description: String?, 
        /**
         * The preimage of the paid invoice (proof of payment).
         */preimage: String?, 
        /**
         * Represents the Bolt11/Bolt12 invoice associated with a payment
         * In the case of a Send payment, this is the invoice paid by the user
         * In the case of a Receive payment, this is the invoice paid to the user
         */invoice: String, 
        /**
         * The payment hash of the invoice
         */paymentHash: String, 
        /**
         * The invoice destination/payee pubkey
         */destinationPubkey: String, 
        /**
         * Lnurl payment information if this was an lnurl payment.
         */lnurlPayInfo: LnurlPayInfo?, 
        /**
         * Lnurl withdrawal information if this was an lnurl payment.
         */lnurlWithdrawInfo: LnurlWithdrawInfo?
    )
    case withdraw(txId: String
    )
    case deposit(txId: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .spark(invoiceDetails: try FfiConverterOptionTypeSparkInvoicePaymentDetails.read(from: &buf)
        )
        
        case 2: return .token(metadata: try FfiConverterTypeTokenMetadata.read(from: &buf), txHash: try FfiConverterString.read(from: &buf), invoiceDetails: try FfiConverterOptionTypeSparkInvoicePaymentDetails.read(from: &buf)
        )
        
        case 3: return .lightning(description: try FfiConverterOptionString.read(from: &buf), preimage: try FfiConverterOptionString.read(from: &buf), invoice: try FfiConverterString.read(from: &buf), paymentHash: try FfiConverterString.read(from: &buf), destinationPubkey: try FfiConverterString.read(from: &buf), lnurlPayInfo: try FfiConverterOptionTypeLnurlPayInfo.read(from: &buf), lnurlWithdrawInfo: try FfiConverterOptionTypeLnurlWithdrawInfo.read(from: &buf)
        )
        
        case 4: return .withdraw(txId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .deposit(txId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .spark(invoiceDetails):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeSparkInvoicePaymentDetails.write(invoiceDetails, into: &buf)
            
        
        case let .token(metadata,txHash,invoiceDetails):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTokenMetadata.write(metadata, into: &buf)
            FfiConverterString.write(txHash, into: &buf)
            FfiConverterOptionTypeSparkInvoicePaymentDetails.write(invoiceDetails, into: &buf)
            
        
        case let .lightning(description,preimage,invoice,paymentHash,destinationPubkey,lnurlPayInfo,lnurlWithdrawInfo):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterOptionString.write(preimage, into: &buf)
            FfiConverterString.write(invoice, into: &buf)
            FfiConverterString.write(paymentHash, into: &buf)
            FfiConverterString.write(destinationPubkey, into: &buf)
            FfiConverterOptionTypeLnurlPayInfo.write(lnurlPayInfo, into: &buf)
            FfiConverterOptionTypeLnurlWithdrawInfo.write(lnurlWithdrawInfo, into: &buf)
            
        
        case let .withdraw(txId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(txId, into: &buf)
            
        
        case let .deposit(txId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(txId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}



extension PaymentDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentMethod {
    
    case lightning
    case spark
    case token
    case deposit
    case withdraw
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = PaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lightning
        
        case 2: return .spark
        
        case 3: return .token
        
        case 4: return .deposit
        
        case 5: return .withdraw
        
        case 6: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lightning:
            writeInt(&buf, Int32(1))
        
        
        case .spark:
            writeInt(&buf, Int32(2))
        
        
        case .token:
            writeInt(&buf, Int32(3))
        
        
        case .deposit:
            writeInt(&buf, Int32(4))
        
        
        case .withdraw:
            writeInt(&buf, Int32(5))
        
        
        case .unknown:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lift(_ buf: RustBuffer) throws -> PaymentMethod {
    return try FfiConverterTypePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lower(_ value: PaymentMethod) -> RustBuffer {
    return FfiConverterTypePaymentMethod.lower(value)
}



extension PaymentMethod: Equatable, Hashable {}




public enum PaymentObserverError {

    
    
    case ServiceConnectivity(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentObserverError: FfiConverterRustBuffer {
    typealias SwiftType = PaymentObserverError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentObserverError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ServiceConnectivity(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentObserverError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ServiceConnectivity(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension PaymentObserverError: Equatable, Hashable {}

extension PaymentObserverError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The status of a payment
 */

public enum PaymentStatus {
    
    /**
     * Payment is completed successfully
     */
    case completed
    /**
     * Payment is in progress
     */
    case pending
    /**
     * Payment has failed
     */
    case failed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .completed
        
        case 2: return .pending
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .completed:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}



extension PaymentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of payment
 */

public enum PaymentType {
    
    /**
     * Payment sent from this wallet
     */
    case send
    /**
     * Payment received to this wallet
     */
    case receive
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .send
        
        case 2: return .receive
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .send:
            writeInt(&buf, Int32(1))
        
        
        case .receive:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentType_lift(_ buf: RustBuffer) throws -> PaymentType {
    return try FfiConverterTypePaymentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentType_lower(_ value: PaymentType) -> RustBuffer {
    return FfiConverterTypePaymentType.lower(value)
}



extension PaymentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProvisionalPaymentDetails {
    
    case bitcoin(
        /**
         * Onchain Bitcoin address
         */withdrawalAddress: String
    )
    case lightning(
        /**
         * BOLT11 invoice
         */invoice: String
    )
    case spark(
        /**
         * Spark pay request being paid (either a Spark address or a Spark invoice)
         */payRequest: String
    )
    case token(
        /**
         * Token identifier
         */tokenId: String, 
        /**
         * Spark pay request being paid (either a Spark address or a Spark invoice)
         */payRequest: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProvisionalPaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProvisionalPaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProvisionalPaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin(withdrawalAddress: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .lightning(invoice: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .spark(payRequest: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .token(tokenId: try FfiConverterString.read(from: &buf), payRequest: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProvisionalPaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoin(withdrawalAddress):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(withdrawalAddress, into: &buf)
            
        
        case let .lightning(invoice):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(invoice, into: &buf)
            
        
        case let .spark(payRequest):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(payRequest, into: &buf)
            
        
        case let .token(tokenId,payRequest):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(tokenId, into: &buf)
            FfiConverterString.write(payRequest, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPaymentDetails_lift(_ buf: RustBuffer) throws -> ProvisionalPaymentDetails {
    return try FfiConverterTypeProvisionalPaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPaymentDetails_lower(_ value: ProvisionalPaymentDetails) -> RustBuffer {
    return FfiConverterTypeProvisionalPaymentDetails.lower(value)
}



extension ProvisionalPaymentDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ReceivePaymentMethod {
    
    case sparkAddress
    case sparkInvoice(
        /**
         * Amount to receive. Denominated in sats if token identifier is empty, otherwise in the token base units
         */amount: U128?, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?, 
        /**
         * The expiry time of the invoice in seconds since the Unix epoch
         */expiryTime: UInt64?, 
        /**
         * A description to embed in the invoice.
         */description: String?, 
        /**
         * If set, the invoice may only be fulfilled by a payer with this public key
         */senderPublicKey: String?
    )
    case bitcoinAddress
    case bolt11Invoice(description: String, amountSats: UInt64?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = ReceivePaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sparkAddress
        
        case 2: return .sparkInvoice(amount: try FfiConverterOptionTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf), expiryTime: try FfiConverterOptionUInt64.read(from: &buf), description: try FfiConverterOptionString.read(from: &buf), senderPublicKey: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 3: return .bitcoinAddress
        
        case 4: return .bolt11Invoice(description: try FfiConverterString.read(from: &buf), amountSats: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceivePaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sparkAddress:
            writeInt(&buf, Int32(1))
        
        
        case let .sparkInvoice(amount,tokenIdentifier,expiryTime,description,senderPublicKey):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeu128.write(amount, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            FfiConverterOptionUInt64.write(expiryTime, into: &buf)
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterOptionString.write(senderPublicKey, into: &buf)
            
        
        case .bitcoinAddress:
            writeInt(&buf, Int32(3))
        
        
        case let .bolt11Invoice(description,amountSats):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(description, into: &buf)
            FfiConverterOptionUInt64.write(amountSats, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentMethod_lift(_ buf: RustBuffer) throws -> ReceivePaymentMethod {
    return try FfiConverterTypeReceivePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentMethod_lower(_ value: ReceivePaymentMethod) -> RustBuffer {
    return FfiConverterTypeReceivePaymentMethod.lower(value)
}



extension ReceivePaymentMethod: Equatable, Hashable {}




/**
 * Error type for the `BreezSdk`
 */
public enum SdkError {

    
    
    case SparkError(String
    )
    case InvalidUuid(String
    )
    /**
     * Invalid input error
     */
    case InvalidInput(String
    )
    /**
     * Network error
     */
    case NetworkError(String
    )
    /**
     * Storage error
     */
    case StorageError(String
    )
    case ChainServiceError(String
    )
    case DepositClaimFeeExceeded(tx: String, vout: UInt32, maxFee: Fee?, actualFee: UInt64
    )
    case MissingUtxo(tx: String, vout: UInt32
    )
    case LnurlError(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkError: FfiConverterRustBuffer {
    typealias SwiftType = SdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SparkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidUuid(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidInput(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .NetworkError(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .StorageError(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .ChainServiceError(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .DepositClaimFeeExceeded(
            tx: try FfiConverterString.read(from: &buf), 
            vout: try FfiConverterUInt32.read(from: &buf), 
            maxFee: try FfiConverterOptionTypeFee.read(from: &buf), 
            actualFee: try FfiConverterUInt64.read(from: &buf)
            )
        case 8: return .MissingUtxo(
            tx: try FfiConverterString.read(from: &buf), 
            vout: try FfiConverterUInt32.read(from: &buf)
            )
        case 9: return .LnurlError(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SparkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidUuid(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidInput(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NetworkError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .StorageError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ChainServiceError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .DepositClaimFeeExceeded(tx,vout,maxFee,actualFee):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            FfiConverterOptionTypeFee.write(maxFee, into: &buf)
            FfiConverterUInt64.write(actualFee, into: &buf)
            
        
        case let .MissingUtxo(tx,vout):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            
        
        case let .LnurlError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension SdkError: Equatable, Hashable {}

extension SdkError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Events emitted by the SDK
 */

public enum SdkEvent {
    
    /**
     * Emitted when the wallet has been synchronized with the network
     */
    case synced
    /**
     * Emitted when data was pushed and/or pulled to/from real-time sync storage.
     */
    case dataSynced(
        /**
         * Value indicating whether new data was pulled through real-time sync.
         */didPullNewRecords: Bool
    )
    /**
     * Emitted when the SDK was unable to claim deposits
     */
    case unclaimedDeposits(unclaimedDeposits: [DepositInfo]
    )
    case claimedDeposits(claimedDeposits: [DepositInfo]
    )
    case paymentSucceeded(payment: Payment
    )
    case paymentFailed(payment: Payment
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkEvent: FfiConverterRustBuffer {
    typealias SwiftType = SdkEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .synced
        
        case 2: return .dataSynced(didPullNewRecords: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .unclaimedDeposits(unclaimedDeposits: try FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
        
        case 4: return .claimedDeposits(claimedDeposits: try FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
        
        case 5: return .paymentSucceeded(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        case 6: return .paymentFailed(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .synced:
            writeInt(&buf, Int32(1))
        
        
        case let .dataSynced(didPullNewRecords):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(didPullNewRecords, into: &buf)
            
        
        case let .unclaimedDeposits(unclaimedDeposits):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeDepositInfo.write(unclaimedDeposits, into: &buf)
            
        
        case let .claimedDeposits(claimedDeposits):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeDepositInfo.write(claimedDeposits, into: &buf)
            
        
        case let .paymentSucceeded(payment):
            writeInt(&buf, Int32(5))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        
        case let .paymentFailed(payment):
            writeInt(&buf, Int32(6))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkEvent_lift(_ buf: RustBuffer) throws -> SdkEvent {
    return try FfiConverterTypeSdkEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkEvent_lower(_ value: SdkEvent) -> RustBuffer {
    return FfiConverterTypeSdkEvent.lower(value)
}



extension SdkEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */

public enum Seed {
    
    /**
     * A BIP-39 mnemonic phrase with an optional passphrase.
     */
    case mnemonic(
        /**
         * The mnemonic phrase. 12 or 24 words.
         */mnemonic: String, 
        /**
         * An optional passphrase for the mnemonic.
         */passphrase: String?
    )
    /**
     * Raw entropy bytes.
     */
    case entropy(Data
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSeed: FfiConverterRustBuffer {
    typealias SwiftType = Seed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Seed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mnemonic(mnemonic: try FfiConverterString.read(from: &buf), passphrase: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 2: return .entropy(try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Seed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .mnemonic(mnemonic,passphrase):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(mnemonic, into: &buf)
            FfiConverterOptionString.write(passphrase, into: &buf)
            
        
        case let .entropy(v1):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeed_lift(_ buf: RustBuffer) throws -> Seed {
    return try FfiConverterTypeSeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeed_lower(_ value: Seed) -> RustBuffer {
    return FfiConverterTypeSeed.lower(value)
}



extension Seed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendPaymentMethod {
    
    case bitcoinAddress(address: BitcoinAddressDetails, feeQuote: SendOnchainFeeQuote
    )
    case bolt11Invoice(invoiceDetails: Bolt11InvoiceDetails, sparkTransferFeeSats: UInt64?, lightningFeeSats: UInt64
    )
    case sparkAddress(address: String, 
        /**
         * Fee to pay for the transaction
         * Denominated in sats if token identifier is empty, otherwise in the token base units
         */fee: U128, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?
    )
    case sparkInvoice(sparkInvoiceDetails: SparkInvoiceDetails, 
        /**
         * Fee to pay for the transaction
         * Denominated in sats if token identifier is empty, otherwise in the token base units
         */fee: U128, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(address: try FfiConverterTypeBitcoinAddressDetails.read(from: &buf), feeQuote: try FfiConverterTypeSendOnchainFeeQuote.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(invoiceDetails: try FfiConverterTypeBolt11InvoiceDetails.read(from: &buf), sparkTransferFeeSats: try FfiConverterOptionUInt64.read(from: &buf), lightningFeeSats: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .sparkAddress(address: try FfiConverterString.read(from: &buf), fee: try FfiConverterTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .sparkInvoice(sparkInvoiceDetails: try FfiConverterTypeSparkInvoiceDetails.read(from: &buf), fee: try FfiConverterTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(address,feeQuote):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressDetails.write(address, into: &buf)
            FfiConverterTypeSendOnchainFeeQuote.write(feeQuote, into: &buf)
            
        
        case let .bolt11Invoice(invoiceDetails,sparkTransferFeeSats,lightningFeeSats):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBolt11InvoiceDetails.write(invoiceDetails, into: &buf)
            FfiConverterOptionUInt64.write(sparkTransferFeeSats, into: &buf)
            FfiConverterUInt64.write(lightningFeeSats, into: &buf)
            
        
        case let .sparkAddress(address,fee,tokenIdentifier):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(address, into: &buf)
            FfiConverterTypeu128.write(fee, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        
        case let .sparkInvoice(sparkInvoiceDetails,fee,tokenIdentifier):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSparkInvoiceDetails.write(sparkInvoiceDetails, into: &buf)
            FfiConverterTypeu128.write(fee, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentMethod_lift(_ buf: RustBuffer) throws -> SendPaymentMethod {
    return try FfiConverterTypeSendPaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentMethod_lower(_ value: SendPaymentMethod) -> RustBuffer {
    return FfiConverterTypeSendPaymentMethod.lower(value)
}



extension SendPaymentMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendPaymentOptions {
    
    case bitcoinAddress(confirmationSpeed: OnchainConfirmationSpeed
    )
    case bolt11Invoice(preferSpark: Bool, 
        /**
         * If set, the function will return the payment if it is still pending after this
         * number of seconds. If unset, the function will return immediately after initiating the payment.
         */completionTimeoutSecs: UInt32?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentOptions: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(confirmationSpeed: try FfiConverterTypeOnchainConfirmationSpeed.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(preferSpark: try FfiConverterBool.read(from: &buf), completionTimeoutSecs: try FfiConverterOptionUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(confirmationSpeed):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOnchainConfirmationSpeed.write(confirmationSpeed, into: &buf)
            
        
        case let .bolt11Invoice(preferSpark,completionTimeoutSecs):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(preferSpark, into: &buf)
            FfiConverterOptionUInt32.write(completionTimeoutSecs, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentOptions_lift(_ buf: RustBuffer) throws -> SendPaymentOptions {
    return try FfiConverterTypeSendPaymentOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentOptions_lower(_ value: SendPaymentOptions) -> RustBuffer {
    return FfiConverterTypeSendPaymentOptions.lower(value)
}



extension SendPaymentOptions: Equatable, Hashable {}




/**
 * Errors that can occur during storage operations
 */
public enum StorageError {

    
    
    case Implementation(String
    )
    /**
     * Database initialization error
     */
    case InitializationError(String
    )
    case Serialization(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageError: FfiConverterRustBuffer {
    typealias SwiftType = StorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Implementation(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InitializationError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Implementation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InitializationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension StorageError: Equatable, Hashable {}

extension StorageError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UpdateDepositPayload {
    
    case claimError(error: DepositClaimError
    )
    case refund(refundTxid: String, refundTx: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateDepositPayload: FfiConverterRustBuffer {
    typealias SwiftType = UpdateDepositPayload

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateDepositPayload {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .claimError(error: try FfiConverterTypeDepositClaimError.read(from: &buf)
        )
        
        case 2: return .refund(refundTxid: try FfiConverterString.read(from: &buf), refundTx: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UpdateDepositPayload, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .claimError(error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDepositClaimError.write(error, into: &buf)
            
        
        case let .refund(refundTxid,refundTx):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(refundTxid, into: &buf)
            FfiConverterString.write(refundTx, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateDepositPayload_lift(_ buf: RustBuffer) throws -> UpdateDepositPayload {
    return try FfiConverterTypeUpdateDepositPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateDepositPayload_lower(_ value: UpdateDepositPayload) -> RustBuffer {
    return FfiConverterTypeUpdateDepositPayload.lower(value)
}



extension UpdateDepositPayload: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WaitForPaymentIdentifier {
    
    case paymentId(String
    )
    case paymentRequest(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWaitForPaymentIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = WaitForPaymentIdentifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WaitForPaymentIdentifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .paymentId(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .paymentRequest(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WaitForPaymentIdentifier, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .paymentId(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .paymentRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWaitForPaymentIdentifier_lift(_ buf: RustBuffer) throws -> WaitForPaymentIdentifier {
    return try FfiConverterTypeWaitForPaymentIdentifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWaitForPaymentIdentifier_lower(_ value: WaitForPaymentIdentifier) -> RustBuffer {
    return FfiConverterTypeWaitForPaymentIdentifier.lower(value)
}



extension WaitForPaymentIdentifier: Equatable, Hashable {}






/**
 * Trait for event listeners
 */
public protocol EventListener : AnyObject {
    
    /**
     * Called when an event occurs
     */
    func onEvent(event: SdkEvent) async 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEventListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEventListener = UniffiVTableCallbackInterfaceEventListener(
        onEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.onEvent(
                     event: try FfiConverterTypeSdkEvent.lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceEventListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EventListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEventListener() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(&UniffiCallbackInterfaceEventListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceEventListener {
    fileprivate static var handleMap = UniffiHandleMap<EventListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceEventListener : FfiConverter {
    typealias SwiftType = EventListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol Logger : AnyObject {
    
    func log(l: LogEntry) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogger {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLogger = UniffiVTableCallbackInterfaceLogger(
        log: { (
            uniffiHandle: UInt64,
            l: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.log(
                     l: try FfiConverterTypeLogEntry.lift(l)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Logger: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLogger() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(&UniffiCallbackInterfaceLogger.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLogger {
    fileprivate static var handleMap = UniffiHandleMap<Logger>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLogger : FfiConverter {
    typealias SwiftType = Logger
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCredentials: FfiConverterRustBuffer {
    typealias SwiftType = Credentials?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredentials.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredentials.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLightningAddressInfo: FfiConverterRustBuffer {
    typealias SwiftType = LightningAddressInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLightningAddressInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLightningAddressInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlPayInfo: FfiConverterRustBuffer {
    typealias SwiftType = LnurlPayInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlPayInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlPayInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlWithdrawInfo: FfiConverterRustBuffer {
    typealias SwiftType = LnurlWithdrawInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlWithdrawInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlWithdrawInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = Payment?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePayment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePayment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkInvoicePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = SparkInvoicePaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkInvoicePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkInvoicePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAssetFilter: FfiConverterRustBuffer {
    typealias SwiftType = AssetFilter?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAssetFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAssetFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDepositClaimError: FfiConverterRustBuffer {
    typealias SwiftType = DepositClaimError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDepositClaimError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDepositClaimError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFee: FfiConverterRustBuffer {
    typealias SwiftType = Fee?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFee.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFee.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSendPaymentOptions: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendPaymentOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendPaymentOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceLogger: FfiConverterRustBuffer {
    typealias SwiftType = Logger?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceLogger.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceLogger.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentStatus]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePaymentStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePaymentStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentType]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePaymentType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePaymentType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeExternalInputParser: FfiConverterRustBuffer {
    typealias SwiftType = [ExternalInputParser]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeExternalInputParser.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeExternalInputParser.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessAction: FfiConverterRustBuffer {
    typealias SwiftType = SuccessAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessActionProcessed.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessActionProcessed.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeu128: FfiConverterRustBuffer {
    typealias SwiftType = U128?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeu128.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeu128.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDepositInfo: FfiConverterRustBuffer {
    typealias SwiftType = [DepositInfo]

    public static func write(_ value: [DepositInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDepositInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DepositInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [DepositInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDepositInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeProvisionalPayment: FfiConverterRustBuffer {
    typealias SwiftType = [ProvisionalPayment]

    public static func write(_ value: [ProvisionalPayment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProvisionalPayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProvisionalPayment] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProvisionalPayment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeProvisionalPayment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTokenMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [TokenMetadata]

    public static func write(_ value: [TokenMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTokenMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TokenMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [TokenMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTokenMetadata.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [Utxo]

    public static func write(_ value: [Utxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUtxo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Utxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [Utxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUtxo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentStatus]

    public static func write(_ value: [PaymentStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentStatus.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentStatus] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentStatus]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentStatus.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentType]

    public static func write(_ value: [PaymentType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentType] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeExternalInputParser: FfiConverterRustBuffer {
    typealias SwiftType = [ExternalInputParser]

    public static func write(_ value: [ExternalInputParser], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExternalInputParser.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ExternalInputParser] {
        let len: Int32 = try readInt(&buf)
        var seq = [ExternalInputParser]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeExternalInputParser.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = [FiatCurrency]

    public static func write(_ value: [FiatCurrency], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFiatCurrency.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FiatCurrency] {
        let len: Int32 = try readInt(&buf)
        var seq = [FiatCurrency]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFiatCurrency.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRate: FfiConverterRustBuffer {
    typealias SwiftType = [Rate]

    public static func write(_ value: [Rate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Rate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Rate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeTokenBalance: FfiConverterRustBuffer {
    public static func write(_ value: [String: TokenBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeTokenBalance.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: TokenBalance] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: TokenBalance]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeTokenBalance.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
































/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias U128 = BInt


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeu128: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U128 {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return BInt(builtinValue)!
    }

    public static func write(_ value: U128, into buf: inout [UInt8]) {
        let builtinValue = value.asString(radix: 10)
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> U128 {
        let builtinValue = try FfiConverterString.lift(value)
        return BInt(builtinValue)!
    }

    public static func lower(_ value: U128) -> RustBuffer {
        let builtinValue = value.asString(radix: 10)
        return FfiConverterString.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeu128_lift(_ value: RustBuffer) throws -> U128 {
    return try FfiConverterTypeu128.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeu128_lower(_ value: U128) -> RustBuffer {
    return FfiConverterTypeu128.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountBreezSdkSpark() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
/**
 * Connects to the Spark network using the provided configuration and mnemonic.
 *
 * # Arguments
 *
 * * `request` - The connection request object
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */
public func connect(request: ConnectRequest)async throws  -> BreezSdk {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_func_connect(FfiConverterTypeConnectRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBreezSdk.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
public func defaultConfig(network: Network) -> Config {
    return try!  FfiConverterTypeConfig.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_func_default_config(
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
public func defaultStorage(dataDir: String)throws  -> Storage {
    return try  FfiConverterTypeStorage.lift(try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_func_default_storage(
        FfiConverterString.lower(dataDir),$0
    )
})
}
public func defaultSyncStorage(dataDir: String)throws  -> SyncStorage {
    return try  FfiConverterTypeSyncStorage_lift(try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_func_default_sync_storage(
        FfiConverterString.lower(dataDir),$0
    )
})
}
public func initLogging(logDir: String?, appLogger: Logger?, logFilter: String?)throws  {try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_func_init_logging(
        FfiConverterOptionString.lower(logDir),
        FfiConverterOptionCallbackInterfaceLogger.lower(appLogger),
        FfiConverterOptionString.lower(logFilter),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_breez_sdk_spark_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_connect() != 40345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_config() != 62194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_storage() != 46285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_sync_storage() != 62413) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_init_logging() != 8518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos() != 20959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status() != 23018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex() != 59376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction() != 65179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener() != 37737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available() != 31624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message() != 4385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit() != 43529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address() != 44132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect() != 330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info() != 6771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address() != 36552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment() != 11540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata() != 40125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies() != 63366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates() != 5904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments() != 16156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits() != 22486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay() != 10147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw() != 45652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_parse() != 195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay() != 37691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment() != 34185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment() != 36984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit() != 33646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address() != 530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener() != 41066) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment() != 54349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message() != 57563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet() != 30368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_wait_for_payment() != 64922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send() != 30686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build() != 8126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service() != 2848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service() != 41113) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set() != 42926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client() != 61720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer() != 21617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage() != 36431) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service() != 56288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item() != 6883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item() != 30248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item() != 7970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_list_payments() != 19728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_insert_payment() != 28075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata() != 45500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id() != 35394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice() != 57075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_add_deposit() != 60240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit() != 60586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_list_deposits() != 54118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_update_deposit() != 39803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new() != 53882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event() != 24807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_logger_log() != 11839) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitBitcoinChainService()
    uniffiCallbackInitPaymentObserver()
    uniffiCallbackInitStorage()
    uniffiCallbackInitEventListener()
    uniffiCallbackInitLogger()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all