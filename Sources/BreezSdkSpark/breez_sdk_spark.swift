// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation
import BigNumber

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(breez_sdk_sparkFFI)
import breez_sdk_sparkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_breez_sdk_spark_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_breez_sdk_spark_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol BitcoinChainService : AnyObject {
    
    func getAddressUtxos(address: String) async throws  -> [Utxo]
    
    func getTransactionStatus(txid: String) async throws  -> TxStatus
    
    func getTransactionHex(txid: String) async throws  -> String
    
    func broadcastTransaction(tx: String) async throws 
    
    func recommendedFees() async throws  -> RecommendedFees
    
}

open class BitcoinChainServiceImpl:
    BitcoinChainService {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(pointer, $0) }
    }

    

    
open func getAddressUtxos(address: String)async throws  -> [Utxo] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(address)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUtxo.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func getTransactionStatus(txid: String)async throws  -> TxStatus {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTxStatus.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func getTransactionHex(txid: String)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func broadcastTransaction(tx: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(tx)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    
open func recommendedFees()async throws  -> RecommendedFees {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_recommended_fees(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRecommendedFees.lift,
            errorHandler: FfiConverterTypeChainServiceError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBitcoinChainService {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceBitcoinChainService = UniffiVTableCallbackInterfaceBitcoinChainService(
        getAddressUtxos: { (
            uniffiHandle: UInt64,
            address: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Utxo] in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getAddressUtxos(
                     address: try FfiConverterString.lift(address)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Utxo]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeUtxo.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getTransactionStatus: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> TxStatus in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getTransactionStatus(
                     txid: try FfiConverterString.lift(txid)
                )
            }

            let uniffiHandleSuccess = { (returnValue: TxStatus) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeTxStatus.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getTransactionHex: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getTransactionHex(
                     txid: try FfiConverterString.lift(txid)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        broadcastTransaction: { (
            uniffiHandle: UInt64,
            tx: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.broadcastTransaction(
                     tx: try FfiConverterString.lift(tx)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        recommendedFees: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RecommendedFees in
                guard let uniffiObj = try? FfiConverterTypeBitcoinChainService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.recommendedFees(
                )
            }

            let uniffiHandleSuccess = { (returnValue: RecommendedFees) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRecommendedFees.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeChainServiceError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeBitcoinChainService.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BitcoinChainService: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitBitcoinChainService() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(&UniffiCallbackInterfaceBitcoinChainService.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinChainService: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<BitcoinChainService>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BitcoinChainService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinChainService {
        return BitcoinChainServiceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BitcoinChainService) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinChainService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BitcoinChainService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinChainService_lift(_ pointer: UnsafeMutableRawPointer) throws -> BitcoinChainService {
    return try FfiConverterTypeBitcoinChainService.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinChainService_lower(_ value: BitcoinChainService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBitcoinChainService.lower(value)
}




/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
public protocol BreezSdkProtocol : AnyObject {
    
    /**
     * Registers a listener to receive SDK events
     *
     * # Arguments
     *
     * * `listener` - An implementation of the `EventListener` trait
     *
     * # Returns
     *
     * A unique identifier for the listener, which can be used to remove it later
     */
    func addEventListener(listener: EventListener) async  -> String
    
    /**
     * Initiates a Bitcoin purchase flow via an external provider (`MoonPay`).
     *
     * This method generates a URL that the user can open in a browser to complete
     * the Bitcoin purchase. The purchased Bitcoin will be sent to an automatically
     * generated deposit address.
     *
     * # Arguments
     *
     * * `request` - The purchase request containing optional amount and redirect URL
     *
     * # Returns
     *
     * A response containing the URL to open in a browser to complete the purchase
     */
    func buyBitcoin(request: BuyBitcoinRequest) async throws  -> BuyBitcoinResponse
    
    /**
     * Cancels the ongoing leaf optimization.
     *
     * This method cancels the ongoing optimization and waits for it to fully stop.
     * The current round will complete before stopping. This method blocks
     * until the optimization has fully stopped and leaves reserved for optimization
     * are available again.
     *
     * If no optimization is running, this method returns immediately.
     */
    func cancelLeafOptimization() async throws 
    
    func checkLightningAddressAvailable(req: CheckLightningAddressRequest) async throws  -> Bool
    
    /**
     * Verifies a message signature against the provided public key. The message
     * is SHA256 hashed before verification. The signature can be hex encoded
     * in either DER or compact format.
     */
    func checkMessage(request: CheckMessageRequest) async throws  -> CheckMessageResponse
    
    func claimDeposit(request: ClaimDepositRequest) async throws  -> ClaimDepositResponse
    
    func claimHtlcPayment(request: ClaimHtlcPaymentRequest) async throws  -> ClaimHtlcPaymentResponse
    
    func deleteLightningAddress() async throws 
    
    /**
     * Stops the SDK's background tasks
     *
     * This method stops the background tasks started by the `start()` method.
     * It should be called before your application terminates to ensure proper cleanup.
     *
     * # Returns
     *
     * Result containing either success or an `SdkError` if the background task couldn't be stopped
     */
    func disconnect() async throws 
    
    func fetchConversionLimits(request: FetchConversionLimitsRequest) async throws  -> FetchConversionLimitsResponse
    
    /**
     * Returns the balance of the wallet in satoshis
     */
    func getInfo(request: GetInfoRequest) async throws  -> GetInfoResponse
    
    /**
     * Returns the current optimization progress snapshot.
     */
    func getLeafOptimizationProgress()  -> OptimizationProgress
    
    func getLightningAddress() async throws  -> LightningAddressInfo?
    
    func getPayment(request: GetPaymentRequest) async throws  -> GetPaymentResponse
    
    /**
     * Returns an instance of the [`TokenIssuer`] for managing token issuance.
     */
    func getTokenIssuer()  -> TokenIssuer
    
    /**
     * Returns the metadata for the given token identifiers.
     *
     * Results are not guaranteed to be in the same order as the input token identifiers.
     *
     * If the metadata is not found locally in cache, it will be queried from
     * the Spark network and then cached.
     */
    func getTokensMetadata(request: GetTokensMetadataRequest) async throws  -> GetTokensMetadataResponse
    
    /**
     * Returns the user settings for the wallet.
     *
     * Some settings are fetched from the Spark network so network requests are performed.
     */
    func getUserSettings() async throws  -> UserSettings
    
    /**
     * List fiat currencies for which there is a known exchange rate,
     * sorted by the canonical name of the currency.
     */
    func listFiatCurrencies() async throws  -> ListFiatCurrenciesResponse
    
    /**
     * List the latest rates of fiat currencies, sorted by name.
     */
    func listFiatRates() async throws  -> ListFiatRatesResponse
    
    /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage
     */
    func listPayments(request: ListPaymentsRequest) async throws  -> ListPaymentsResponse
    
    func listUnclaimedDeposits(request: ListUnclaimedDepositsRequest) async throws  -> ListUnclaimedDepositsResponse
    
    /**
     * Performs LNURL-auth with the service.
     *
     * This method implements the LNURL-auth protocol as specified in LUD-04 and LUD-05.
     * It derives a domain-specific linking key, signs the challenge, and sends the
     * authentication request to the service.
     */
    func lnurlAuth(requestData: LnurlAuthRequestDetails) async throws  -> LnurlCallbackStatus
    
    func lnurlPay(request: LnurlPayRequest) async throws  -> LnurlPayResponse
    
    /**
     * Performs an LNURL withdraw operation for the amount of satoshis to
     * withdraw and the LNURL withdraw request details. The LNURL withdraw request
     * details can be obtained from calling [`BreezSdk::parse`].
     *
     * The method generates a Lightning invoice for the withdraw amount, stores
     * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
     * invoice.
     *
     * If the `completion_timeout_secs` parameter is provided and greater than 0, the
     * method will wait for the payment to be completed within that period. If the
     * withdraw is completed within the timeout, the `payment` field in the response
     * will be set with the payment details. If the `completion_timeout_secs`
     * parameter is not provided or set to 0, the method will not wait for the payment
     * to be completed. If the withdraw is not completed within the
     * timeout, the `payment` field will be empty.
     *
     * # Arguments
     *
     * * `request` - The LNURL withdraw request
     *
     * # Returns
     *
     * Result containing either:
     * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
     * * `SdkError` - If there was an error during the withdraw process
     */
    func lnurlWithdraw(request: LnurlWithdrawRequest) async throws  -> LnurlWithdrawResponse
    
    func parse(input: String) async throws  -> InputType
    
    func prepareLnurlPay(request: PrepareLnurlPayRequest) async throws  -> PrepareLnurlPayResponse
    
    func prepareSendPayment(request: PrepareSendPaymentRequest) async throws  -> PrepareSendPaymentResponse
    
    func receivePayment(request: ReceivePaymentRequest) async throws  -> ReceivePaymentResponse
    
    /**
     * Get the recommended BTC fees based on the configured chain service.
     */
    func recommendedFees() async throws  -> RecommendedFees
    
    func refundDeposit(request: RefundDepositRequest) async throws  -> RefundDepositResponse
    
    func registerLightningAddress(request: RegisterLightningAddressRequest) async throws  -> LightningAddressInfo
    
    /**
     * Removes a previously registered event listener
     *
     * # Arguments
     *
     * * `id` - The listener ID returned from `add_event_listener`
     *
     * # Returns
     *
     * `true` if the listener was found and removed, `false` otherwise
     */
    func removeEventListener(id: String) async  -> Bool
    
    func sendPayment(request: SendPaymentRequest) async throws  -> SendPaymentResponse
    
    /**
     * Signs a message with the wallet's identity key. The message is SHA256
     * hashed before signing. The returned signature will be hex encoded in
     * DER format by default, or compact format if specified.
     */
    func signMessage(request: SignMessageRequest) async throws  -> SignMessageResponse
    
    /**
     * Starts leaf optimization in the background.
     *
     * This method spawns the optimization work in a background task and returns
     * immediately. Progress is reported via events.
     * If optimization is already running, no new task will be started.
     */
    func startLeafOptimization() 
    
    /**
     * Synchronizes the wallet with the Spark network
     */
    func syncWallet(request: SyncWalletRequest) async throws  -> SyncWalletResponse
    
    /**
     * Updates the user settings for the wallet.
     *
     * Some settings are updated on the Spark network so network requests may be performed.
     */
    func updateUserSettings(request: UpdateUserSettingsRequest) async throws 
    
}

/**
 * `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
 * with request/response objects and comprehensive error handling.
 */
open class BreezSdk:
    BreezSdkProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_breezsdk(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_breezsdk(pointer, $0) }
    }

    

    
    /**
     * Registers a listener to receive SDK events
     *
     * # Arguments
     *
     * * `listener` - An implementation of the `EventListener` trait
     *
     * # Returns
     *
     * A unique identifier for the listener, which can be used to remove it later
     */
open func addEventListener(listener: EventListener)async  -> String {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceEventListener.lower(listener)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Initiates a Bitcoin purchase flow via an external provider (`MoonPay`).
     *
     * This method generates a URL that the user can open in a browser to complete
     * the Bitcoin purchase. The purchased Bitcoin will be sent to an automatically
     * generated deposit address.
     *
     * # Arguments
     *
     * * `request` - The purchase request containing optional amount and redirect URL
     *
     * # Returns
     *
     * A response containing the URL to open in a browser to complete the purchase
     */
open func buyBitcoin(request: BuyBitcoinRequest)async throws  -> BuyBitcoinResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_buy_bitcoin(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBuyBitcoinRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeBuyBitcoinResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Cancels the ongoing leaf optimization.
     *
     * This method cancels the ongoing optimization and waits for it to fully stop.
     * The current round will complete before stopping. This method blocks
     * until the optimization has fully stopped and leaves reserved for optimization
     * are available again.
     *
     * If no optimization is running, this method returns immediately.
     */
open func cancelLeafOptimization()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_cancel_leaf_optimization(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func checkLightningAddressAvailable(req: CheckLightningAddressRequest)async throws  -> Bool {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCheckLightningAddressRequest.lower(req)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_i8,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_i8,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Verifies a message signature against the provided public key. The message
     * is SHA256 hashed before verification. The signature can be hex encoded
     * in either DER or compact format.
     */
open func checkMessage(request: CheckMessageRequest)async throws  -> CheckMessageResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCheckMessageRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeCheckMessageResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func claimDeposit(request: ClaimDepositRequest)async throws  -> ClaimDepositResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClaimDepositRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeClaimDepositResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func claimHtlcPayment(request: ClaimHtlcPaymentRequest)async throws  -> ClaimHtlcPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_claim_htlc_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeClaimHtlcPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeClaimHtlcPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func deleteLightningAddress()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Stops the SDK's background tasks
     *
     * This method stops the background tasks started by the `start()` method.
     * It should be called before your application terminates to ensure proper cleanup.
     *
     * # Returns
     *
     * Result containing either success or an `SdkError` if the background task couldn't be stopped
     */
open func disconnect()async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func fetchConversionLimits(request: FetchConversionLimitsRequest)async throws  -> FetchConversionLimitsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_fetch_conversion_limits(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFetchConversionLimitsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFetchConversionLimitsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns the balance of the wallet in satoshis
     */
open func getInfo(request: GetInfoRequest)async throws  -> GetInfoResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetInfoRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetInfoResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns the current optimization progress snapshot.
     */
open func getLeafOptimizationProgress() -> OptimizationProgress {
    return try!  FfiConverterTypeOptimizationProgress.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_method_breezsdk_get_leaf_optimization_progress(self.uniffiClonePointer(),$0
    )
})
}
    
open func getLightningAddress()async throws  -> LightningAddressInfo? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeLightningAddressInfo.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func getPayment(request: GetPaymentRequest)async throws  -> GetPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns an instance of the [`TokenIssuer`] for managing token issuance.
     */
open func getTokenIssuer() -> TokenIssuer {
    return try!  FfiConverterTypeTokenIssuer.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_method_breezsdk_get_token_issuer(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the metadata for the given token identifiers.
     *
     * Results are not guaranteed to be in the same order as the input token identifiers.
     *
     * If the metadata is not found locally in cache, it will be queried from
     * the Spark network and then cached.
     */
open func getTokensMetadata(request: GetTokensMetadataRequest)async throws  -> GetTokensMetadataResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetTokensMetadataRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetTokensMetadataResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Returns the user settings for the wallet.
     *
     * Some settings are fetched from the Spark network so network requests are performed.
     */
open func getUserSettings()async throws  -> UserSettings {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_get_user_settings(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserSettings.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * List fiat currencies for which there is a known exchange rate,
     * sorted by the canonical name of the currency.
     */
open func listFiatCurrencies()async throws  -> ListFiatCurrenciesResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListFiatCurrenciesResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * List the latest rates of fiat currencies, sorted by name.
     */
open func listFiatRates()async throws  -> ListFiatRatesResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListFiatRatesResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Lists payments from the storage with pagination
     *
     * This method provides direct access to the payment history stored in the database.
     * It returns payments in reverse chronological order (newest first).
     *
     * # Arguments
     *
     * * `request` - Contains pagination parameters (offset and limit)
     *
     * # Returns
     *
     * * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
     * * `Err(SdkError)` - If there was an error accessing the storage
     */
open func listPayments(request: ListPaymentsRequest)async throws  -> ListPaymentsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListPaymentsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListPaymentsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func listUnclaimedDeposits(request: ListUnclaimedDepositsRequest)async throws  -> ListUnclaimedDepositsResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListUnclaimedDepositsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListUnclaimedDepositsResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Performs LNURL-auth with the service.
     *
     * This method implements the LNURL-auth protocol as specified in LUD-04 and LUD-05.
     * It derives a domain-specific linking key, signs the challenge, and sends the
     * authentication request to the service.
     */
open func lnurlAuth(requestData: LnurlAuthRequestDetails)async throws  -> LnurlCallbackStatus {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_auth(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLnurlAuthRequestDetails.lower(requestData)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLnurlCallbackStatus.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func lnurlPay(request: LnurlPayRequest)async throws  -> LnurlPayResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLnurlPayRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLnurlPayResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Performs an LNURL withdraw operation for the amount of satoshis to
     * withdraw and the LNURL withdraw request details. The LNURL withdraw request
     * details can be obtained from calling [`BreezSdk::parse`].
     *
     * The method generates a Lightning invoice for the withdraw amount, stores
     * the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
     * invoice.
     *
     * If the `completion_timeout_secs` parameter is provided and greater than 0, the
     * method will wait for the payment to be completed within that period. If the
     * withdraw is completed within the timeout, the `payment` field in the response
     * will be set with the payment details. If the `completion_timeout_secs`
     * parameter is not provided or set to 0, the method will not wait for the payment
     * to be completed. If the withdraw is not completed within the
     * timeout, the `payment` field will be empty.
     *
     * # Arguments
     *
     * * `request` - The LNURL withdraw request
     *
     * # Returns
     *
     * Result containing either:
     * * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
     * * `SdkError` - If there was an error during the withdraw process
     */
open func lnurlWithdraw(request: LnurlWithdrawRequest)async throws  -> LnurlWithdrawResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLnurlWithdrawRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLnurlWithdrawResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func parse(input: String)async throws  -> InputType {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_parse(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(input)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeInputType.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func prepareLnurlPay(request: PrepareLnurlPayRequest)async throws  -> PrepareLnurlPayResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrepareLnurlPayRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrepareLnurlPayResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func prepareSendPayment(request: PrepareSendPaymentRequest)async throws  -> PrepareSendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrepareSendPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrepareSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func receivePayment(request: ReceivePaymentRequest)async throws  -> ReceivePaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeReceivePaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeReceivePaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Get the recommended BTC fees based on the configured chain service.
     */
open func recommendedFees()async throws  -> RecommendedFees {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_recommended_fees(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRecommendedFees.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func refundDeposit(request: RefundDepositRequest)async throws  -> RefundDepositResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRefundDepositRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRefundDepositResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
open func registerLightningAddress(request: RegisterLightningAddressRequest)async throws  -> LightningAddressInfo {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRegisterLightningAddressRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLightningAddressInfo.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Removes a previously registered event listener
     *
     * # Arguments
     *
     * * `id` - The listener ID returned from `add_event_listener`
     *
     * # Returns
     *
     * `true` if the listener was found and removed, `false` otherwise
     */
open func removeEventListener(id: String)async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_i8,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_i8,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
open func sendPayment(request: SendPaymentRequest)async throws  -> SendPaymentResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSendPaymentRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSendPaymentResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Signs a message with the wallet's identity key. The message is SHA256
     * hashed before signing. The returned signature will be hex encoded in
     * DER format by default, or compact format if specified.
     */
open func signMessage(request: SignMessageRequest)async throws  -> SignMessageResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSignMessageRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignMessageResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Starts leaf optimization in the background.
     *
     * This method spawns the optimization work in a background task and returns
     * immediately. Progress is reported via events.
     * If optimization is already running, no new task will be started.
     */
open func startLeafOptimization() {try! rustCall() {
    uniffi_breez_sdk_spark_fn_method_breezsdk_start_leaf_optimization(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Synchronizes the wallet with the Spark network
     */
open func syncWallet(request: SyncWalletRequest)async throws  -> SyncWalletResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSyncWalletRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSyncWalletResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Updates the user settings for the wallet.
     *
     * Some settings are updated on the Spark network so network requests may be performed.
     */
open func updateUserSettings(request: UpdateUserSettingsRequest)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_breezsdk_update_user_settings(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUpdateUserSettingsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBreezSdk: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BreezSdk

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BreezSdk {
        return BreezSdk(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BreezSdk) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezSdk {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BreezSdk, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdk_lift(_ pointer: UnsafeMutableRawPointer) throws -> BreezSdk {
    return try FfiConverterTypeBreezSdk.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBreezSdk_lower(_ value: BreezSdk) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBreezSdk.lower(value)
}




/**
 * External signer trait that can be implemented by users and passed to the SDK.
 *
 * This trait mirrors the `BreezSigner` trait but uses FFI-compatible types (bytes, strings)
 * instead of Rust-specific types. This allows it to be exposed through FFI and WASM bindings.
 *
 * All methods accept and return simple types:
 * - Derivation paths as strings (e.g., "m/44'/0'/0'")
 * - Public keys, signatures, and other crypto primitives as Vec<u8>
 * - Spark-specific types as serialized representations
 *
 * Errors are returned as `SignerError` for FFI compatibility.
 */
public protocol ExternalSigner : AnyObject {
    
    /**
     * Returns the identity public key as 33 bytes (compressed secp256k1 key).
     *
     * See also: [JavaScript `getIdentityPublicKey`](https://docs.spark.money/wallets/spark-signer#get-identity-public-key)
     */
    func identityPublicKey() throws  -> PublicKeyBytes
    
    /**
     * Derives a public key for the given BIP32 derivation path.
     *
     * # Arguments
     * * `path` - BIP32 derivation path as a string (e.g., "m/44'/0'/0'/0/0")
     *
     * # Returns
     * The derived public key as 33 bytes, or a `SignerError`
     *
     * See also: [JavaScript `getPublicKeyFromDerivation`](https://docs.spark.money/wallets/spark-signer#get-public-key-from-derivation)
     */
    func derivePublicKey(path: String) async throws  -> PublicKeyBytes
    
    /**
     * Signs a message using ECDSA at the given derivation path.
     *
     * The message should be a 32-byte digest (typically a hash of the original data).
     *
     * # Arguments
     * * `message` - The 32-byte message digest to sign
     * * `path` - BIP32 derivation path as a string
     *
     * # Returns
     * 64-byte compact ECDSA signature, or a `SignerError`
     */
    func signEcdsa(message: MessageBytes, path: String) async throws  -> EcdsaSignatureBytes
    
    /**
     * Signs a message using recoverable ECDSA at the given derivation path.
     *
     * The message should be a 32-byte digest (typically a hash of the original data).
     *
     * # Arguments
     * * `message` - The 32-byte message digest to sign
     * * `path` - BIP32 derivation path as a string
     *
     * # Returns
     * 65 bytes: recovery ID (31 + `recovery_id`) + 64-byte signature, or a `SignerError`
     */
    func signEcdsaRecoverable(message: MessageBytes, path: String) async throws  -> RecoverableEcdsaSignatureBytes
    
    /**
     * Encrypts a message using ECIES at the given derivation path.
     *
     * # Arguments
     * * `message` - The message to encrypt
     * * `path` - BIP32 derivation path for the encryption key
     *
     * # Returns
     * Encrypted data, or a `SignerError`
     */
    func encryptEcies(message: Data, path: String) async throws  -> Data
    
    /**
     * Decrypts a message using ECIES at the given derivation path.
     *
     * # Arguments
     * * `message` - The encrypted message
     * * `path` - BIP32 derivation path for the decryption key
     *
     * # Returns
     * Decrypted data, or a `SignerError`
     *
     * See also: [JavaScript `decryptEcies`](https://docs.spark.money/wallets/spark-signer#decrypt-ecies)
     */
    func decryptEcies(message: Data, path: String) async throws  -> Data
    
    /**
     * Signs a hash using Schnorr signature at the given derivation path.
     *
     * # Arguments
     * * `hash` - The 32-byte hash to sign (must be 32 bytes)
     * * `path` - BIP32 derivation path as a string
     *
     * # Returns
     * 64-byte Schnorr signature, or a `SignerError`
     */
    func signHashSchnorr(hash: Data, path: String) async throws  -> SchnorrSignatureBytes
    
    /**
     * HMAC-SHA256 of a message at the given derivation path.
     *
     * # Arguments
     * * `message` - The message to hash
     * * `path` - BIP32 derivation path as a string
     *
     * # Returns
     * 32-byte HMAC-SHA256, or a `SignerError`
     *
     * See also: [JavaScript `htlcHMAC`](https://docs.spark.money/wallets/spark-signer#generate-htlc-hmac)
     */
    func hmacSha256(message: Data, path: String) async throws  -> HashedMessageBytes
    
    /**
     * Generates Frost signing commitments for multi-party signing.
     *
     * # Returns
     * Frost commitments with nonces, or a `SignerError`
     *
     * See also: [JavaScript `getRandomSigningCommitment`](https://docs.spark.money/wallets/spark-signer#get-random-signing-commitment)
     */
    func generateRandomSigningCommitment() async throws  -> ExternalFrostCommitments
    
    /**
     * Gets the public key for a specific tree node in the Spark wallet.
     *
     * # Arguments
     * * `id` - The tree node identifier
     *
     * # Returns
     * The public key for the node, or a `SignerError`
     */
    func getPublicKeyForNode(id: ExternalTreeNodeId) async throws  -> PublicKeyBytes
    
    /**
     * Generates a random secret that is encrypted and known only to the signer.
     *
     * This method creates a new random secret and returns it in encrypted form.
     * The plaintext secret never leaves the signer boundary, providing a secure way
     * to create secrets that can be referenced in subsequent operations without
     * exposing them.
     *
     * This is conceptually similar to Spark's key derivation system where secrets
     * are represented by opaque references (like tree node IDs or Random) rather than raw values.
     * The encrypted secret can be passed to other signer methods that need to operate
     * on it, while keeping the actual secret material protected within the signer.
     *
     * # Returns
     * An encrypted secret that can be used in subsequent signer operations,
     * or a `SignerError` if generation fails.
     *
     * See also: [Key Derivation System](https://docs.spark.money/wallets/spark-signer#the-keyderivation-system)
     */
    func generateRandomSecret() async throws  -> ExternalEncryptedSecret
    
    /**
     * Gets an encrypted static deposit secret by index.
     *
     * # Arguments
     * * `index` - The index of the static deposit secret
     *
     * # Returns
     * The encrypted secret, or a `SignerError`
     *
     * This is the encrypted version of: [JavaScript `getStaticDepositSecretKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-secret-key)
     */
    func staticDepositSecretEncrypted(index: UInt32) async throws  -> ExternalSecretSource
    
    /**
     * Gets a static deposit secret by index.
     *
     * # Arguments
     * * `index` - The index of the static deposit secret
     *
     * # Returns
     * The 32-byte secret, or a `SignerError`
     *
     * See also: [JavaScript `getStaticDepositSecretKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-secret-key)
     */
    func staticDepositSecret(index: UInt32) async throws  -> SecretBytes
    
    /**
     * Gets a static deposit signing public key by index.
     *
     * # Arguments
     * * `index` - The index of the static deposit public signing key
     *
     * # Returns
     * The 33-byte public key, or a `SignerError`
     *
     * See also: [JavaScript `getStaticDepositSigningKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-signing-key)
     */
    func staticDepositSigningKey(index: UInt32) async throws  -> PublicKeyBytes
    
    /**
     * Subtracts one secret from another.
     *
     * This is a lower-level primitive used as part of key tweaking operations.
     *
     * # Arguments
     * * `signing_key` - The first secret
     * * `new_signing_key` - The second secret to subtract
     *
     * # Returns
     * The resulting secret, or a `SignerError`
     *
     * See also: [JavaScript `subtractSplitAndEncrypt`](https://docs.spark.money/wallets/spark-signer#subtract,-split,-and-encrypt)
     * (this method provides the subtraction step of that higher-level operation)
     */
    func subtractSecrets(signingKey: ExternalSecretSource, newSigningKey: ExternalSecretSource) async throws  -> ExternalSecretSource
    
    /**
     * Splits a secret with proofs using Shamir's Secret Sharing.
     *
     * # Arguments
     * * `secret` - The secret to split
     * * `threshold` - Minimum number of shares needed to reconstruct
     * * `num_shares` - Total number of shares to create
     *
     * # Returns
     * Vector of verifiable secret shares, or a `SignerError`
     *
     * See also: [JavaScript `splitSecretWithProofs`](https://docs.spark.money/wallets/spark-signer#split-secret-with-proofs)
     */
    func splitSecretWithProofs(secret: ExternalSecretToSplit, threshold: UInt32, numShares: UInt32) async throws  -> [ExternalVerifiableSecretShare]
    
    /**
     * Encrypts a secret for a specific receiver's public key.
     *
     * # Arguments
     * * `encrypted_secret` - The encrypted secret to re-encrypt
     * * `receiver_public_key` - The receiver's 33-byte public key
     *
     * # Returns
     * Encrypted data for the receiver, or a `SignerError`
     */
    func encryptSecretForReceiver(encryptedSecret: ExternalEncryptedSecret, receiverPublicKey: PublicKeyBytes) async throws  -> Data
    
    /**
     * Gets the public key from a secret.
     *
     * # Arguments
     * * `secret` - The secret
     *
     * # Returns
     * The corresponding 33-byte public key, or a `SignerError`
     *
     * See also: [JavaScript `getPublicKeyFromDerivation`](https://docs.spark.money/wallets/spark-signer#get-public-key-from-derivation)
     */
    func publicKeyFromSecret(secret: ExternalSecretSource) async throws  -> PublicKeyBytes
    
    /**
     * Signs using Frost protocol (multi-party signing).
     *
     * # Arguments
     * * `request` - The Frost signing request
     *
     * # Returns
     * A signature share, or a `SignerError`
     *
     * See also: [JavaScript `signFrost`](https://docs.spark.money/wallets/spark-signer#frost-signing)
     */
    func signFrost(request: ExternalSignFrostRequest) async throws  -> ExternalFrostSignatureShare
    
    /**
     * Aggregates Frost signature shares into a final signature.
     *
     * # Arguments
     * * `request` - The Frost aggregation request
     *
     * # Returns
     * The aggregated Frost signature, or a `SignerError`
     *
     * See also: [JavaScript `aggregateFrost`](https://docs.spark.money/wallets/spark-signer#aggregate-frost-signatures)
     */
    func aggregateFrost(request: ExternalAggregateFrostRequest) async throws  -> ExternalFrostSignature
    
}

/**
 * External signer trait that can be implemented by users and passed to the SDK.
 *
 * This trait mirrors the `BreezSigner` trait but uses FFI-compatible types (bytes, strings)
 * instead of Rust-specific types. This allows it to be exposed through FFI and WASM bindings.
 *
 * All methods accept and return simple types:
 * - Derivation paths as strings (e.g., "m/44'/0'/0'")
 * - Public keys, signatures, and other crypto primitives as Vec<u8>
 * - Spark-specific types as serialized representations
 *
 * Errors are returned as `SignerError` for FFI compatibility.
 */
open class ExternalSignerImpl:
    ExternalSigner {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_externalsigner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_externalsigner(pointer, $0) }
    }

    

    
    /**
     * Returns the identity public key as 33 bytes (compressed secp256k1 key).
     *
     * See also: [JavaScript `getIdentityPublicKey`](https://docs.spark.money/wallets/spark-signer#get-identity-public-key)
     */
open func identityPublicKey()throws  -> PublicKeyBytes {
    return try  FfiConverterTypePublicKeyBytes.lift(try rustCallWithError(FfiConverterTypeSignerError.lift) {
    uniffi_breez_sdk_spark_fn_method_externalsigner_identity_public_key(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Derives a public key for the given BIP32 derivation path.
     *
     * # Arguments
     * * `path` - BIP32 derivation path as a string (e.g., "m/44'/0'/0'/0/0")
     *
     * # Returns
     * The derived public key as 33 bytes, or a `SignerError`
     *
     * See also: [JavaScript `getPublicKeyFromDerivation`](https://docs.spark.money/wallets/spark-signer#get-public-key-from-derivation)
     */
open func derivePublicKey(path: String)async throws  -> PublicKeyBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_derive_public_key(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePublicKeyBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Signs a message using ECDSA at the given derivation path.
     *
     * The message should be a 32-byte digest (typically a hash of the original data).
     *
     * # Arguments
     * * `message` - The 32-byte message digest to sign
     * * `path` - BIP32 derivation path as a string
     *
     * # Returns
     * 64-byte compact ECDSA signature, or a `SignerError`
     */
open func signEcdsa(message: MessageBytes, path: String)async throws  -> EcdsaSignatureBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageBytes.lower(message),FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEcdsaSignatureBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Signs a message using recoverable ECDSA at the given derivation path.
     *
     * The message should be a 32-byte digest (typically a hash of the original data).
     *
     * # Arguments
     * * `message` - The 32-byte message digest to sign
     * * `path` - BIP32 derivation path as a string
     *
     * # Returns
     * 65 bytes: recovery ID (31 + `recovery_id`) + 64-byte signature, or a `SignerError`
     */
open func signEcdsaRecoverable(message: MessageBytes, path: String)async throws  -> RecoverableEcdsaSignatureBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_sign_ecdsa_recoverable(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMessageBytes.lower(message),FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRecoverableEcdsaSignatureBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Encrypts a message using ECIES at the given derivation path.
     *
     * # Arguments
     * * `message` - The message to encrypt
     * * `path` - BIP32 derivation path for the encryption key
     *
     * # Returns
     * Encrypted data, or a `SignerError`
     */
open func encryptEcies(message: Data, path: String)async throws  -> Data {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_ecies(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(message),FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Decrypts a message using ECIES at the given derivation path.
     *
     * # Arguments
     * * `message` - The encrypted message
     * * `path` - BIP32 derivation path for the decryption key
     *
     * # Returns
     * Decrypted data, or a `SignerError`
     *
     * See also: [JavaScript `decryptEcies`](https://docs.spark.money/wallets/spark-signer#decrypt-ecies)
     */
open func decryptEcies(message: Data, path: String)async throws  -> Data {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_decrypt_ecies(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(message),FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Signs a hash using Schnorr signature at the given derivation path.
     *
     * # Arguments
     * * `hash` - The 32-byte hash to sign (must be 32 bytes)
     * * `path` - BIP32 derivation path as a string
     *
     * # Returns
     * 64-byte Schnorr signature, or a `SignerError`
     */
open func signHashSchnorr(hash: Data, path: String)async throws  -> SchnorrSignatureBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_sign_hash_schnorr(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(hash),FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSchnorrSignatureBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * HMAC-SHA256 of a message at the given derivation path.
     *
     * # Arguments
     * * `message` - The message to hash
     * * `path` - BIP32 derivation path as a string
     *
     * # Returns
     * 32-byte HMAC-SHA256, or a `SignerError`
     *
     * See also: [JavaScript `htlcHMAC`](https://docs.spark.money/wallets/spark-signer#generate-htlc-hmac)
     */
open func hmacSha256(message: Data, path: String)async throws  -> HashedMessageBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_hmac_sha256(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(message),FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeHashedMessageBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Generates Frost signing commitments for multi-party signing.
     *
     * # Returns
     * Frost commitments with nonces, or a `SignerError`
     *
     * See also: [JavaScript `getRandomSigningCommitment`](https://docs.spark.money/wallets/spark-signer#get-random-signing-commitment)
     */
open func generateRandomSigningCommitment()async throws  -> ExternalFrostCommitments {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_signing_commitment(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeExternalFrostCommitments.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Gets the public key for a specific tree node in the Spark wallet.
     *
     * # Arguments
     * * `id` - The tree node identifier
     *
     * # Returns
     * The public key for the node, or a `SignerError`
     */
open func getPublicKeyForNode(id: ExternalTreeNodeId)async throws  -> PublicKeyBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_get_public_key_for_node(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExternalTreeNodeId.lower(id)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePublicKeyBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Generates a random secret that is encrypted and known only to the signer.
     *
     * This method creates a new random secret and returns it in encrypted form.
     * The plaintext secret never leaves the signer boundary, providing a secure way
     * to create secrets that can be referenced in subsequent operations without
     * exposing them.
     *
     * This is conceptually similar to Spark's key derivation system where secrets
     * are represented by opaque references (like tree node IDs or Random) rather than raw values.
     * The encrypted secret can be passed to other signer methods that need to operate
     * on it, while keeping the actual secret material protected within the signer.
     *
     * # Returns
     * An encrypted secret that can be used in subsequent signer operations,
     * or a `SignerError` if generation fails.
     *
     * See also: [Key Derivation System](https://docs.spark.money/wallets/spark-signer#the-keyderivation-system)
     */
open func generateRandomSecret()async throws  -> ExternalEncryptedSecret {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_generate_random_secret(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeExternalEncryptedSecret.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Gets an encrypted static deposit secret by index.
     *
     * # Arguments
     * * `index` - The index of the static deposit secret
     *
     * # Returns
     * The encrypted secret, or a `SignerError`
     *
     * This is the encrypted version of: [JavaScript `getStaticDepositSecretKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-secret-key)
     */
open func staticDepositSecretEncrypted(index: UInt32)async throws  -> ExternalSecretSource {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_static_deposit_secret_encrypted(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(index)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeExternalSecretSource.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Gets a static deposit secret by index.
     *
     * # Arguments
     * * `index` - The index of the static deposit secret
     *
     * # Returns
     * The 32-byte secret, or a `SignerError`
     *
     * See also: [JavaScript `getStaticDepositSecretKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-secret-key)
     */
open func staticDepositSecret(index: UInt32)async throws  -> SecretBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_static_deposit_secret(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(index)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSecretBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Gets a static deposit signing public key by index.
     *
     * # Arguments
     * * `index` - The index of the static deposit public signing key
     *
     * # Returns
     * The 33-byte public key, or a `SignerError`
     *
     * See also: [JavaScript `getStaticDepositSigningKey`](https://docs.spark.money/wallets/spark-signer#get-static-deposit-signing-key)
     */
open func staticDepositSigningKey(index: UInt32)async throws  -> PublicKeyBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_static_deposit_signing_key(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(index)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePublicKeyBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Subtracts one secret from another.
     *
     * This is a lower-level primitive used as part of key tweaking operations.
     *
     * # Arguments
     * * `signing_key` - The first secret
     * * `new_signing_key` - The second secret to subtract
     *
     * # Returns
     * The resulting secret, or a `SignerError`
     *
     * See also: [JavaScript `subtractSplitAndEncrypt`](https://docs.spark.money/wallets/spark-signer#subtract,-split,-and-encrypt)
     * (this method provides the subtraction step of that higher-level operation)
     */
open func subtractSecrets(signingKey: ExternalSecretSource, newSigningKey: ExternalSecretSource)async throws  -> ExternalSecretSource {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_subtract_secrets(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExternalSecretSource.lower(signingKey),FfiConverterTypeExternalSecretSource.lower(newSigningKey)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeExternalSecretSource.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Splits a secret with proofs using Shamir's Secret Sharing.
     *
     * # Arguments
     * * `secret` - The secret to split
     * * `threshold` - Minimum number of shares needed to reconstruct
     * * `num_shares` - Total number of shares to create
     *
     * # Returns
     * Vector of verifiable secret shares, or a `SignerError`
     *
     * See also: [JavaScript `splitSecretWithProofs`](https://docs.spark.money/wallets/spark-signer#split-secret-with-proofs)
     */
open func splitSecretWithProofs(secret: ExternalSecretToSplit, threshold: UInt32, numShares: UInt32)async throws  -> [ExternalVerifiableSecretShare] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_split_secret_with_proofs(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExternalSecretToSplit.lower(secret),FfiConverterUInt32.lower(threshold),FfiConverterUInt32.lower(numShares)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeExternalVerifiableSecretShare.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Encrypts a secret for a specific receiver's public key.
     *
     * # Arguments
     * * `encrypted_secret` - The encrypted secret to re-encrypt
     * * `receiver_public_key` - The receiver's 33-byte public key
     *
     * # Returns
     * Encrypted data for the receiver, or a `SignerError`
     */
open func encryptSecretForReceiver(encryptedSecret: ExternalEncryptedSecret, receiverPublicKey: PublicKeyBytes)async throws  -> Data {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_encrypt_secret_for_receiver(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExternalEncryptedSecret.lower(encryptedSecret),FfiConverterTypePublicKeyBytes.lower(receiverPublicKey)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Gets the public key from a secret.
     *
     * # Arguments
     * * `secret` - The secret
     *
     * # Returns
     * The corresponding 33-byte public key, or a `SignerError`
     *
     * See also: [JavaScript `getPublicKeyFromDerivation`](https://docs.spark.money/wallets/spark-signer#get-public-key-from-derivation)
     */
open func publicKeyFromSecret(secret: ExternalSecretSource)async throws  -> PublicKeyBytes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_public_key_from_secret(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExternalSecretSource.lower(secret)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePublicKeyBytes.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Signs using Frost protocol (multi-party signing).
     *
     * # Arguments
     * * `request` - The Frost signing request
     *
     * # Returns
     * A signature share, or a `SignerError`
     *
     * See also: [JavaScript `signFrost`](https://docs.spark.money/wallets/spark-signer#frost-signing)
     */
open func signFrost(request: ExternalSignFrostRequest)async throws  -> ExternalFrostSignatureShare {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_sign_frost(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExternalSignFrostRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeExternalFrostSignatureShare.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    
    /**
     * Aggregates Frost signature shares into a final signature.
     *
     * # Arguments
     * * `request` - The Frost aggregation request
     *
     * # Returns
     * The aggregated Frost signature, or a `SignerError`
     *
     * See also: [JavaScript `aggregateFrost`](https://docs.spark.money/wallets/spark-signer#aggregate-frost-signatures)
     */
open func aggregateFrost(request: ExternalAggregateFrostRequest)async throws  -> ExternalFrostSignature {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_externalsigner_aggregate_frost(
                    self.uniffiClonePointer(),
                    FfiConverterTypeExternalAggregateFrostRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeExternalFrostSignature.lift,
            errorHandler: FfiConverterTypeSignerError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceExternalSigner {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceExternalSigner = UniffiVTableCallbackInterfaceExternalSigner(
        identityPublicKey: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> PublicKeyBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.identityPublicKey(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypePublicKeyBytes.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeSignerError.lower
            )
        },
        derivePublicKey: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PublicKeyBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.derivePublicKey(
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: PublicKeyBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePublicKeyBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        signEcdsa: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> EcdsaSignatureBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.signEcdsa(
                     message: try FfiConverterTypeMessageBytes.lift(message),
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: EcdsaSignatureBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeEcdsaSignatureBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        signEcdsaRecoverable: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RecoverableEcdsaSignatureBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.signEcdsaRecoverable(
                     message: try FfiConverterTypeMessageBytes.lift(message),
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RecoverableEcdsaSignatureBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRecoverableEcdsaSignatureBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        encryptEcies: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.encryptEcies(
                     message: try FfiConverterData.lift(message),
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Data) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterData.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        decryptEcies: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.decryptEcies(
                     message: try FfiConverterData.lift(message),
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Data) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterData.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        signHashSchnorr: { (
            uniffiHandle: UInt64,
            hash: RustBuffer,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> SchnorrSignatureBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.signHashSchnorr(
                     hash: try FfiConverterData.lift(hash),
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: SchnorrSignatureBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeSchnorrSignatureBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hmacSha256: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> HashedMessageBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.hmacSha256(
                     message: try FfiConverterData.lift(message),
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: HashedMessageBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeHashedMessageBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        generateRandomSigningCommitment: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> ExternalFrostCommitments in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.generateRandomSigningCommitment(
                )
            }

            let uniffiHandleSuccess = { (returnValue: ExternalFrostCommitments) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeExternalFrostCommitments.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPublicKeyForNode: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PublicKeyBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPublicKeyForNode(
                     id: try FfiConverterTypeExternalTreeNodeId.lift(id)
                )
            }

            let uniffiHandleSuccess = { (returnValue: PublicKeyBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePublicKeyBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        generateRandomSecret: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> ExternalEncryptedSecret in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.generateRandomSecret(
                )
            }

            let uniffiHandleSuccess = { (returnValue: ExternalEncryptedSecret) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeExternalEncryptedSecret.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        staticDepositSecretEncrypted: { (
            uniffiHandle: UInt64,
            index: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> ExternalSecretSource in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.staticDepositSecretEncrypted(
                     index: try FfiConverterUInt32.lift(index)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ExternalSecretSource) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeExternalSecretSource.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        staticDepositSecret: { (
            uniffiHandle: UInt64,
            index: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> SecretBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.staticDepositSecret(
                     index: try FfiConverterUInt32.lift(index)
                )
            }

            let uniffiHandleSuccess = { (returnValue: SecretBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeSecretBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        staticDepositSigningKey: { (
            uniffiHandle: UInt64,
            index: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PublicKeyBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.staticDepositSigningKey(
                     index: try FfiConverterUInt32.lift(index)
                )
            }

            let uniffiHandleSuccess = { (returnValue: PublicKeyBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePublicKeyBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        subtractSecrets: { (
            uniffiHandle: UInt64,
            signingKey: RustBuffer,
            newSigningKey: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> ExternalSecretSource in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.subtractSecrets(
                     signingKey: try FfiConverterTypeExternalSecretSource.lift(signingKey),
                     newSigningKey: try FfiConverterTypeExternalSecretSource.lift(newSigningKey)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ExternalSecretSource) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeExternalSecretSource.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        splitSecretWithProofs: { (
            uniffiHandle: UInt64,
            secret: RustBuffer,
            threshold: UInt32,
            numShares: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [ExternalVerifiableSecretShare] in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.splitSecretWithProofs(
                     secret: try FfiConverterTypeExternalSecretToSplit.lift(secret),
                     threshold: try FfiConverterUInt32.lift(threshold),
                     numShares: try FfiConverterUInt32.lift(numShares)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [ExternalVerifiableSecretShare]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeExternalVerifiableSecretShare.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        encryptSecretForReceiver: { (
            uniffiHandle: UInt64,
            encryptedSecret: RustBuffer,
            receiverPublicKey: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.encryptSecretForReceiver(
                     encryptedSecret: try FfiConverterTypeExternalEncryptedSecret.lift(encryptedSecret),
                     receiverPublicKey: try FfiConverterTypePublicKeyBytes.lift(receiverPublicKey)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Data) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterData.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        publicKeyFromSecret: { (
            uniffiHandle: UInt64,
            secret: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PublicKeyBytes in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.publicKeyFromSecret(
                     secret: try FfiConverterTypeExternalSecretSource.lift(secret)
                )
            }

            let uniffiHandleSuccess = { (returnValue: PublicKeyBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePublicKeyBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        signFrost: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> ExternalFrostSignatureShare in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.signFrost(
                     request: try FfiConverterTypeExternalSignFrostRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ExternalFrostSignatureShare) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeExternalFrostSignatureShare.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        aggregateFrost: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> ExternalFrostSignature in
                guard let uniffiObj = try? FfiConverterTypeExternalSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.aggregateFrost(
                     request: try FfiConverterTypeExternalAggregateFrostRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ExternalFrostSignature) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeExternalFrostSignature.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeSignerError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeExternalSigner.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ExternalSigner: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitExternalSigner() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_externalsigner(&UniffiCallbackInterfaceExternalSigner.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalSigner: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<ExternalSigner>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ExternalSigner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ExternalSigner {
        return ExternalSignerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ExternalSigner) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalSigner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ExternalSigner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSigner_lift(_ pointer: UnsafeMutableRawPointer) throws -> ExternalSigner {
    return try FfiConverterTypeExternalSigner.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSigner_lower(_ value: ExternalSigner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeExternalSigner.lower(value)
}




/**
 * Trait covering fiat-related functionality
 */
public protocol FiatService : AnyObject {
    
    /**
     * List all supported fiat currencies for which there is a known exchange rate.
     */
    func fetchFiatCurrencies() async throws  -> [FiatCurrency]
    
    /**
     * Get the live rates from the server.
     */
    func fetchFiatRates() async throws  -> [Rate]
    
}

/**
 * Trait covering fiat-related functionality
 */
open class FiatServiceImpl:
    FiatService {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_fiatservice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_fiatservice(pointer, $0) }
    }

    

    
    /**
     * List all supported fiat currencies for which there is a known exchange rate.
     */
open func fetchFiatCurrencies()async throws  -> [FiatCurrency] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_currencies(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFiatCurrency.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    
    /**
     * Get the live rates from the server.
     */
open func fetchFiatRates()async throws  -> [Rate] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_fiatservice_fetch_fiat_rates(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeRate.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFiatService {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFiatService = UniffiVTableCallbackInterfaceFiatService(
        fetchFiatCurrencies: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [FiatCurrency] in
                guard let uniffiObj = try? FfiConverterTypeFiatService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.fetchFiatCurrencies(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [FiatCurrency]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeFiatCurrency.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        fetchFiatRates: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Rate] in
                guard let uniffiObj = try? FfiConverterTypeFiatService.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.fetchFiatRates(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Rate]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeRate.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFiatService.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FiatService: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFiatService() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_fiatservice(&UniffiCallbackInterfaceFiatService.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatService: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<FiatService>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FiatService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatService {
        return FiatServiceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FiatService) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FiatService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatService_lift(_ pointer: UnsafeMutableRawPointer) throws -> FiatService {
    return try FfiConverterTypeFiatService.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatService_lower(_ value: FiatService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFiatService.lower(value)
}




/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
public protocol PaymentObserver : AnyObject {
    
    /**
     * Called before Lightning, Spark or onchain Bitcoin payments are made
     */
    func beforeSend(payments: [ProvisionalPayment]) async throws 
    
}

/**
 * This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
 * If the implementation returns an error, the payment is cancelled.
 */
open class PaymentObserverImpl:
    PaymentObserver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_paymentobserver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_paymentobserver(pointer, $0) }
    }

    

    
    /**
     * Called before Lightning, Spark or onchain Bitcoin payments are made
     */
open func beforeSend(payments: [ProvisionalPayment])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeProvisionalPayment.lower(payments)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypePaymentObserverError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePaymentObserver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfacePaymentObserver = UniffiVTableCallbackInterfacePaymentObserver(
        beforeSend: { (
            uniffiHandle: UInt64,
            payments: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypePaymentObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.beforeSend(
                     payments: try FfiConverterSequenceTypeProvisionalPayment.lift(payments)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypePaymentObserverError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypePaymentObserver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PaymentObserver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitPaymentObserver() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(&UniffiCallbackInterfacePaymentObserver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentObserver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<PaymentObserver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PaymentObserver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PaymentObserver {
        return PaymentObserverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PaymentObserver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentObserver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PaymentObserver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentObserver_lift(_ pointer: UnsafeMutableRawPointer) throws -> PaymentObserver {
    return try FfiConverterTypePaymentObserver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentObserver_lower(_ value: PaymentObserver) -> UnsafeMutableRawPointer {
    return FfiConverterTypePaymentObserver.lower(value)
}




/**
 * REST client trait for making HTTP requests.
 *
 * This trait provides a way for users to supply their own HTTP client implementation
 * for use with the SDK. The SDK will use this client for all HTTP operations including
 * LNURL flows and chain service requests.
 */
public protocol RestClient : AnyObject {
    
    /**
     * Makes a GET request and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which GET will be called
     * - `headers`: optional headers that will be set on the request
     */
    func getRequest(url: String, headers: [String: String]?) async throws  -> RestResponse
    
    /**
     * Makes a POST request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which POST will be called
     * - `headers`: the optional POST headers
     * - `body`: the optional POST body
     */
    func postRequest(url: String, headers: [String: String]?, body: String?) async throws  -> RestResponse
    
    /**
     * Makes a DELETE request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which DELETE will be called
     * - `headers`: the optional DELETE headers
     * - `body`: the optional DELETE body
     */
    func deleteRequest(url: String, headers: [String: String]?, body: String?) async throws  -> RestResponse
    
}

/**
 * REST client trait for making HTTP requests.
 *
 * This trait provides a way for users to supply their own HTTP client implementation
 * for use with the SDK. The SDK will use this client for all HTTP operations including
 * LNURL flows and chain service requests.
 */
open class RestClientImpl:
    RestClient {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_restclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_restclient(pointer, $0) }
    }

    

    
    /**
     * Makes a GET request and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which GET will be called
     * - `headers`: optional headers that will be set on the request
     */
open func getRequest(url: String, headers: [String: String]?)async throws  -> RestResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_restclient_get_request(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDictionaryStringString.lower(headers)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRestResponse.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    
    /**
     * Makes a POST request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which POST will be called
     * - `headers`: the optional POST headers
     * - `body`: the optional POST body
     */
open func postRequest(url: String, headers: [String: String]?, body: String?)async throws  -> RestResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_restclient_post_request(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDictionaryStringString.lower(headers),FfiConverterOptionString.lower(body)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRestResponse.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    
    /**
     * Makes a DELETE request, and logs on DEBUG.
     * ### Arguments
     * - `url`: the URL on which DELETE will be called
     * - `headers`: the optional DELETE headers
     * - `body`: the optional DELETE body
     */
open func deleteRequest(url: String, headers: [String: String]?, body: String?)async throws  -> RestResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_restclient_delete_request(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterOptionDictionaryStringString.lower(headers),FfiConverterOptionString.lower(body)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRestResponse.lift,
            errorHandler: FfiConverterTypeServiceConnectivityError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRestClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRestClient = UniffiVTableCallbackInterfaceRestClient(
        getRequest: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            headers: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RestResponse in
                guard let uniffiObj = try? FfiConverterTypeRestClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getRequest(
                     url: try FfiConverterString.lift(url),
                     headers: try FfiConverterOptionDictionaryStringString.lift(headers)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RestResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRestResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        postRequest: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            headers: RustBuffer,
            body: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RestResponse in
                guard let uniffiObj = try? FfiConverterTypeRestClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.postRequest(
                     url: try FfiConverterString.lift(url),
                     headers: try FfiConverterOptionDictionaryStringString.lift(headers),
                     body: try FfiConverterOptionString.lift(body)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RestResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRestResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteRequest: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            headers: RustBuffer,
            body: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RestResponse in
                guard let uniffiObj = try? FfiConverterTypeRestClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteRequest(
                     url: try FfiConverterString.lift(url),
                     headers: try FfiConverterOptionDictionaryStringString.lift(headers),
                     body: try FfiConverterOptionString.lift(body)
                )
            }

            let uniffiHandleSuccess = { (returnValue: RestResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRestResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeServiceConnectivityError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeRestClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RestClient: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRestClient() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_restclient(&UniffiCallbackInterfaceRestClient.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRestClient: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<RestClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RestClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RestClient {
        return RestClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RestClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RestClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RestClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> RestClient {
    return try FfiConverterTypeRestClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestClient_lower(_ value: RestClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRestClient.lower(value)
}




/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
public protocol SdkBuilderProtocol : AnyObject {
    
    /**
     * Builds the `BreezSdk` instance with the configured components.
     */
    func build() async throws  -> BreezSdk
    
    /**
     * Sets the chain service to be used by the SDK.
     * Arguments:
     * - `chain_service`: The chain service to be used.
     */
    func withChainService(chainService: BitcoinChainService) async 
    
    /**
     * Sets the root storage directory to initialize the default storage with.
     * This initializes both storage and real-time sync storage with the
     * default implementations.
     * Arguments:
     * - `storage_dir`: The data directory for storage.
     */
    func withDefaultStorage(storageDir: String) async 
    
    /**
     * Sets the fiat service to be used by the SDK.
     * Arguments:
     * - `fiat_service`: The fiat service to be used.
     */
    func withFiatService(fiatService: FiatService) async 
    
    /**
     * Sets the key set type to be used by the SDK.
     * Arguments:
     * - `config`: Key set configuration containing the key set type, address index flag, and optional account number.
     */
    func withKeySet(config: KeySetConfig) async 
    
    func withLnurlClient(lnurlClient: RestClient) async 
    
    /**
     * Sets the payment observer to be used by the SDK.
     * Arguments:
     * - `payment_observer`: The payment observer to be used.
     */
    func withPaymentObserver(paymentObserver: PaymentObserver) async 
    
    /**
     * Sets the REST chain service to be used by the SDK.
     * Arguments:
     * - `url`: The base URL of the REST API.
     * - `api_type`: The API type to be used.
     * - `credentials`: Optional credentials for basic authentication.
     */
    func withRestChainService(url: String, apiType: ChainApiType, credentials: Credentials?) async 
    
    /**
     * Sets the storage implementation to be used by the SDK.
     * Arguments:
     * - `storage`: The storage implementation to be used.
     */
    func withStorage(storage: Storage) async 
    
}

/**
 * Builder for creating `BreezSdk` instances with customizable components.
 */
open class SdkBuilder:
    SdkBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_sdkbuilder(self.pointer, $0) }
    }
    /**
     * Creates a new `SdkBuilder` with the provided configuration.
     * Arguments:
     * - `config`: The configuration to be used.
     * - `seed`: The seed for wallet generation.
     */
public convenience init(config: Config, seed: Seed) {
    let pointer =
        try! rustCall() {
    uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(
        FfiConverterTypeConfig.lower(config),
        FfiConverterTypeSeed.lower(seed),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_sdkbuilder(pointer, $0) }
    }

    

    
    /**
     * Builds the `BreezSdk` instance with the configured components.
     */
open func build()async throws  -> BreezSdk {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBreezSdk.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Sets the chain service to be used by the SDK.
     * Arguments:
     * - `chain_service`: The chain service to be used.
     */
open func withChainService(chainService: BitcoinChainService)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBitcoinChainService.lower(chainService)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the root storage directory to initialize the default storage with.
     * This initializes both storage and real-time sync storage with the
     * default implementations.
     * Arguments:
     * - `storage_dir`: The data directory for storage.
     */
open func withDefaultStorage(storageDir: String)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(storageDir)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the fiat service to be used by the SDK.
     * Arguments:
     * - `fiat_service`: The fiat service to be used.
     */
open func withFiatService(fiatService: FiatService)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFiatService.lower(fiatService)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the key set type to be used by the SDK.
     * Arguments:
     * - `config`: Key set configuration containing the key set type, address index flag, and optional account number.
     */
open func withKeySet(config: KeySetConfig)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKeySetConfig.lower(config)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func withLnurlClient(lnurlClient: RestClient)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRestClient.lower(lnurlClient)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the payment observer to be used by the SDK.
     * Arguments:
     * - `payment_observer`: The payment observer to be used.
     */
open func withPaymentObserver(paymentObserver: PaymentObserver)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(
                    self.uniffiClonePointer(),
                    FfiConverterTypePaymentObserver.lower(paymentObserver)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the REST chain service to be used by the SDK.
     * Arguments:
     * - `url`: The base URL of the REST API.
     * - `api_type`: The API type to be used.
     * - `credentials`: Optional credentials for basic authentication.
     */
open func withRestChainService(url: String, apiType: ChainApiType, credentials: Credentials?)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterTypeChainApiType.lower(apiType),FfiConverterOptionTypeCredentials.lower(credentials)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Sets the storage implementation to be used by the SDK.
     * Arguments:
     * - `storage`: The storage implementation to be used.
     */
open func withStorage(storage: Storage)async  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(
                    self.uniffiClonePointer(),
                    FfiConverterTypeStorage.lower(storage)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SdkBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SdkBuilder {
        return SdkBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SdkBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SdkBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SdkBuilder {
    return try FfiConverterTypeSdkBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkBuilder_lower(_ value: SdkBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSdkBuilder.lower(value)
}




/**
 * Trait for persistent storage
 */
public protocol Storage : AnyObject {
    
    func deleteCachedItem(key: String) async throws 
    
    func getCachedItem(key: String) async throws  -> String?
    
    func setCachedItem(key: String, value: String) async throws 
    
    /**
     * Lists payments with optional filters and pagination
     *
     * # Arguments
     *
     * * `list_payments_request` - The request to list payments
     *
     * # Returns
     *
     * A vector of payments or a `StorageError`
     */
    func listPayments(request: ListPaymentsRequest) async throws  -> [Payment]
    
    /**
     * Inserts a payment into storage
     *
     * # Arguments
     *
     * * `payment` - The payment to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func insertPayment(payment: Payment) async throws 
    
    /**
     * Inserts payment metadata into storage
     *
     * # Arguments
     *
     * * `payment_id` - The ID of the payment
     * * `metadata` - The metadata to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func insertPaymentMetadata(paymentId: String, metadata: PaymentMetadata) async throws 
    
    /**
     * Gets a payment by its ID
     * # Arguments
     *
     * * `id` - The ID of the payment to retrieve
     *
     * # Returns
     *
     * The payment if found or None if not found
     */
    func getPaymentById(id: String) async throws  -> Payment
    
    /**
     * Gets a payment by its invoice
     * # Arguments
     *
     * * `invoice` - The invoice of the payment to retrieve
     * # Returns
     *
     * The payment if found or None if not found
     */
    func getPaymentByInvoice(invoice: String) async throws  -> Payment?
    
    /**
     * Gets payments that have any of the specified parent payment IDs.
     * Used to load related payments for a set of parent payments.
     *
     * # Arguments
     *
     * * `parent_payment_ids` - The IDs of the parent payments
     *
     * # Returns
     *
     * A map of `parent_payment_id` -> Vec<Payment> or a `StorageError`
     */
    func getPaymentsByParentIds(parentPaymentIds: [String]) async throws  -> [String: [Payment]]
    
    /**
     * Add a deposit to storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `amount_sats` - The amount of the deposit in sats
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func addDeposit(txid: String, vout: UInt32, amountSats: UInt64) async throws 
    
    /**
     * Removes an unclaimed deposit from storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func deleteDeposit(txid: String, vout: UInt32) async throws 
    
    /**
     * Lists all unclaimed deposits from storage
     * # Returns
     *
     * A vector of `DepositInfo` or a `StorageError`
     */
    func listDeposits() async throws  -> [DepositInfo]
    
    /**
     * Updates or inserts unclaimed deposit details
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `payload` - The payload for the update
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
    func updateDeposit(txid: String, vout: UInt32, payload: UpdateDepositPayload) async throws 
    
    func setLnurlMetadata(metadata: [SetLnurlMetadataItem]) async throws 
    
    func addOutgoingChange(record: UnversionedRecordChange) async throws  -> UInt64
    
    func completeOutgoingSync(record: Record, localRevision: UInt64) async throws 
    
    func getPendingOutgoingChanges(limit: UInt32) async throws  -> [OutgoingChange]
    
    /**
     * Get the last committed sync revision.
     *
     * The `sync_revision` table tracks the highest revision that has been committed
     * (i.e. acknowledged by the server or received from it). It does NOT include
     * pending outgoing queue ids. This value is used by the sync protocol to
     * request changes from the server.
     */
    func getLastRevision() async throws  -> UInt64
    
    /**
     * Insert incoming records from remote sync
     */
    func insertIncomingRecords(records: [Record]) async throws 
    
    /**
     * Delete an incoming record after it has been processed
     */
    func deleteIncomingRecord(record: Record) async throws 
    
    /**
     * Get incoming records that need to be processed, up to the specified limit
     */
    func getIncomingRecords(limit: UInt32) async throws  -> [IncomingChange]
    
    /**
     * Get the latest outgoing record if any exists
     */
    func getLatestOutgoingChange() async throws  -> OutgoingChange?
    
    /**
     * Update the sync state record from an incoming record
     */
    func updateRecordFromIncoming(record: Record) async throws 
    
}

/**
 * Trait for persistent storage
 */
open class StorageImpl:
    Storage {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_storage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_storage(pointer, $0) }
    }

    

    
open func deleteCachedItem(key: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func getCachedItem(key: String)async throws  -> String? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func setCachedItem(key: String, value: String)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(key),FfiConverterString.lower(value)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Lists payments with optional filters and pagination
     *
     * # Arguments
     *
     * * `list_payments_request` - The request to list payments
     *
     * # Returns
     *
     * A vector of payments or a `StorageError`
     */
open func listPayments(request: ListPaymentsRequest)async throws  -> [Payment] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_list_payments(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListPaymentsRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Inserts a payment into storage
     *
     * # Arguments
     *
     * * `payment` - The payment to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func insertPayment(payment: Payment)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_insert_payment(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayment.lower(payment)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Inserts payment metadata into storage
     *
     * # Arguments
     *
     * * `payment_id` - The ID of the payment
     * * `metadata` - The metadata to insert
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func insertPaymentMetadata(paymentId: String, metadata: PaymentMetadata)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_insert_payment_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(paymentId),FfiConverterTypePaymentMetadata.lower(metadata)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Gets a payment by its ID
     * # Arguments
     *
     * * `id` - The ID of the payment to retrieve
     *
     * # Returns
     *
     * The payment if found or None if not found
     */
open func getPaymentById(id: String)async throws  -> Payment {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(id)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Gets a payment by its invoice
     * # Arguments
     *
     * * `invoice` - The invoice of the payment to retrieve
     * # Returns
     *
     * The payment if found or None if not found
     */
open func getPaymentByInvoice(invoice: String)async throws  -> Payment? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(invoice)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Gets payments that have any of the specified parent payment IDs.
     * Used to load related payments for a set of parent payments.
     *
     * # Arguments
     *
     * * `parent_payment_ids` - The IDs of the parent payments
     *
     * # Returns
     *
     * A map of `parent_payment_id` -> Vec<Payment> or a `StorageError`
     */
open func getPaymentsByParentIds(parentPaymentIds: [String])async throws  -> [String: [Payment]] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_payments_by_parent_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(parentPaymentIds)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringSequenceTypePayment.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Add a deposit to storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `amount_sats` - The amount of the deposit in sats
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func addDeposit(txid: String, vout: UInt32, amountSats: UInt64)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_add_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterUInt64.lower(amountSats)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Removes an unclaimed deposit from storage
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func deleteDeposit(txid: String, vout: UInt32)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Lists all unclaimed deposits from storage
     * # Returns
     *
     * A vector of `DepositInfo` or a `StorageError`
     */
open func listDeposits()async throws  -> [DepositInfo] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_list_deposits(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeDepositInfo.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Updates or inserts unclaimed deposit details
     * # Arguments
     *
     * * `txid` - The transaction ID of the deposit
     * * `vout` - The output index of the deposit
     * * `payload` - The payload for the update
     *
     * # Returns
     *
     * Success or a `StorageError`
     */
open func updateDeposit(txid: String, vout: UInt32, payload: UpdateDepositPayload)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_update_deposit(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(txid),FfiConverterUInt32.lower(vout),FfiConverterTypeUpdateDepositPayload.lower(payload)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func setLnurlMetadata(metadata: [SetLnurlMetadataItem])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_set_lnurl_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSetLnurlMetadataItem.lower(metadata)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func addOutgoingChange(record: UnversionedRecordChange)async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_add_outgoing_change(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnversionedRecordChange.lower(record)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_u64,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_u64,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func completeOutgoingSync(record: Record, localRevision: UInt64)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_complete_outgoing_sync(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRecord.lower(record),FfiConverterUInt64.lower(localRevision)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
open func getPendingOutgoingChanges(limit: UInt32)async throws  -> [OutgoingChange] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_pending_outgoing_changes(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(limit)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOutgoingChange.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Get the last committed sync revision.
     *
     * The `sync_revision` table tracks the highest revision that has been committed
     * (i.e. acknowledged by the server or received from it). It does NOT include
     * pending outgoing queue ids. This value is used by the sync protocol to
     * request changes from the server.
     */
open func getLastRevision()async throws  -> UInt64 {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_last_revision(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_u64,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_u64,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Insert incoming records from remote sync
     */
open func insertIncomingRecords(records: [Record])async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_insert_incoming_records(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeRecord.lower(records)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Delete an incoming record after it has been processed
     */
open func deleteIncomingRecord(record: Record)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_delete_incoming_record(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRecord.lower(record)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Get incoming records that need to be processed, up to the specified limit
     */
open func getIncomingRecords(limit: UInt32)async throws  -> [IncomingChange] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_incoming_records(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(limit)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeIncomingChange.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Get the latest outgoing record if any exists
     */
open func getLatestOutgoingChange()async throws  -> OutgoingChange? {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_get_latest_outgoing_change(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeOutgoingChange.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    
    /**
     * Update the sync state record from an incoming record
     */
open func updateRecordFromIncoming(record: Record)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_storage_update_record_from_incoming(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRecord.lower(record)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_void,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_void,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceStorage {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceStorage = UniffiVTableCallbackInterfaceStorage(
        deleteCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteCachedItem(
                     key: try FfiConverterString.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String? in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getCachedItem(
                     key: try FfiConverterString.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setCachedItem: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setCachedItem(
                     key: try FfiConverterString.lift(key),
                     value: try FfiConverterString.lift(value)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listPayments: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Payment] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listPayments(
                     request: try FfiConverterTypeListPaymentsRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Payment]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        insertPayment: { (
            uniffiHandle: UInt64,
            payment: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.insertPayment(
                     payment: try FfiConverterTypePayment.lift(payment)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        insertPaymentMetadata: { (
            uniffiHandle: UInt64,
            paymentId: RustBuffer,
            metadata: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.insertPaymentMetadata(
                     paymentId: try FfiConverterString.lift(paymentId),
                     metadata: try FfiConverterTypePaymentMetadata.lift(metadata)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPaymentById: { (
            uniffiHandle: UInt64,
            id: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Payment in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPaymentById(
                     id: try FfiConverterString.lift(id)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Payment) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPaymentByInvoice: { (
            uniffiHandle: UInt64,
            invoice: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Payment? in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPaymentByInvoice(
                     invoice: try FfiConverterString.lift(invoice)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Payment?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPaymentsByParentIds: { (
            uniffiHandle: UInt64,
            parentPaymentIds: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [String: [Payment]] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPaymentsByParentIds(
                     parentPaymentIds: try FfiConverterSequenceString.lift(parentPaymentIds)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [String: [Payment]]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterDictionaryStringSequenceTypePayment.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        addDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            amountSats: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.addDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout),
                     amountSats: try FfiConverterUInt64.lift(amountSats)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listDeposits: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [DepositInfo] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listDeposits(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [DepositInfo]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeDepositInfo.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        updateDeposit: { (
            uniffiHandle: UInt64,
            txid: RustBuffer,
            vout: UInt32,
            payload: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.updateDeposit(
                     txid: try FfiConverterString.lift(txid),
                     vout: try FfiConverterUInt32.lift(vout),
                     payload: try FfiConverterTypeUpdateDepositPayload.lift(payload)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setLnurlMetadata: { (
            uniffiHandle: UInt64,
            metadata: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.setLnurlMetadata(
                     metadata: try FfiConverterSequenceTypeSetLnurlMetadataItem.lift(metadata)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        addOutgoingChange: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteU64,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.addOutgoingChange(
                     record: try FfiConverterTypeUnversionedRecordChange.lift(record)
                )
            }

            let uniffiHandleSuccess = { (returnValue: UInt64) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: FfiConverterUInt64.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        completeOutgoingSync: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            localRevision: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.completeOutgoingSync(
                     record: try FfiConverterTypeRecord.lift(record),
                     localRevision: try FfiConverterUInt64.lift(localRevision)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getPendingOutgoingChanges: { (
            uniffiHandle: UInt64,
            limit: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [OutgoingChange] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getPendingOutgoingChanges(
                     limit: try FfiConverterUInt32.lift(limit)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [OutgoingChange]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeOutgoingChange.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getLastRevision: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteU64,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> UInt64 in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getLastRevision(
                )
            }

            let uniffiHandleSuccess = { (returnValue: UInt64) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: FfiConverterUInt64.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructU64(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        insertIncomingRecords: { (
            uniffiHandle: UInt64,
            records: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.insertIncomingRecords(
                     records: try FfiConverterSequenceTypeRecord.lift(records)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteIncomingRecord: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteIncomingRecord(
                     record: try FfiConverterTypeRecord.lift(record)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getIncomingRecords: { (
            uniffiHandle: UInt64,
            limit: UInt32,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [IncomingChange] in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getIncomingRecords(
                     limit: try FfiConverterUInt32.lift(limit)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [IncomingChange]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeIncomingChange.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getLatestOutgoingChange: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> OutgoingChange? in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getLatestOutgoingChange(
                )
            }

            let uniffiHandleSuccess = { (returnValue: OutgoingChange?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeOutgoingChange.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        updateRecordFromIncoming: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.updateRecordFromIncoming(
                     record: try FfiConverterTypeRecord.lift(record)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Storage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitStorage() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(&UniffiCallbackInterfaceStorage.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<Storage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Storage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Storage {
        return StorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Storage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Storage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Storage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> Storage {
    return try FfiConverterTypeStorage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorage_lower(_ value: Storage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStorage.lower(value)
}




public protocol TokenIssuerProtocol : AnyObject {
    
    /**
     * Burns supply of the issuer token
     *
     * # Arguments
     *
     * * `request`: The request containing the amount of the supply to burn
     *
     * # Returns
     *
     * Result containing either:
     * * `Payment` - The payment representing the burn transaction
     * * `SdkError` - If there was an error during the burn process
     */
    func burnIssuerToken(request: BurnIssuerTokenRequest) async throws  -> Payment
    
    /**
     * Creates a new issuer token
     *
     * # Arguments
     *
     * * `request`: The request containing the token parameters
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenMetadata` - The metadata of the created token
     * * `SdkError` - If there was an error during the token creation
     */
    func createIssuerToken(request: CreateIssuerTokenRequest) async throws  -> TokenMetadata
    
    /**
     * Freezes tokens held at the specified address
     *
     * # Arguments
     *
     * * `request`: The request containing the spark address where the tokens to be frozen are held
     *
     * # Returns
     *
     * Result containing either:
     * * `FreezeIssuerTokenResponse` - The response containing details of the freeze operation
     * * `SdkError` - If there was an error during the freeze process
     */
    func freezeIssuerToken(request: FreezeIssuerTokenRequest) async throws  -> FreezeIssuerTokenResponse
    
    /**
     * Gets the issuer token balance
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenBalance` - The balance of the issuer token
     * * `SdkError` - If there was an error during the retrieval or no issuer token exists
     */
    func getIssuerTokenBalance() async throws  -> TokenBalance
    
    /**
     * Gets the issuer token metadata
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenMetadata` - The metadata of the issuer token
     * * `SdkError` - If there was an error during the retrieval or no issuer token exists
     */
    func getIssuerTokenMetadata() async throws  -> TokenMetadata
    
    /**
     * Mints supply for the issuer token
     *
     * # Arguments
     *
     * * `request`: The request contiaining the amount of the supply to mint
     *
     * # Returns
     *
     * Result containing either:
     * * `Payment` - The payment representing the minting transaction
     * * `SdkError` - If there was an error during the minting process
     */
    func mintIssuerToken(request: MintIssuerTokenRequest) async throws  -> Payment
    
    /**
     * Unfreezes tokens held at the specified address
     *
     * # Arguments
     *
     * * `request`: The request containing the spark address where the tokens to be unfrozen are held
     *
     * # Returns
     *
     * Result containing either:
     * * `UnfreezeIssuerTokenResponse` - The response containing details of the unfreeze operation
     * * `SdkError` - If there was an error during the unfreeze process
     */
    func unfreezeIssuerToken(request: UnfreezeIssuerTokenRequest) async throws  -> UnfreezeIssuerTokenResponse
    
}

open class TokenIssuer:
    TokenIssuerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_breez_sdk_spark_fn_clone_tokenissuer(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_breez_sdk_spark_fn_free_tokenissuer(pointer, $0) }
    }

    

    
    /**
     * Burns supply of the issuer token
     *
     * # Arguments
     *
     * * `request`: The request containing the amount of the supply to burn
     *
     * # Returns
     *
     * Result containing either:
     * * `Payment` - The payment representing the burn transaction
     * * `SdkError` - If there was an error during the burn process
     */
open func burnIssuerToken(request: BurnIssuerTokenRequest)async throws  -> Payment {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_burn_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBurnIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayment.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Creates a new issuer token
     *
     * # Arguments
     *
     * * `request`: The request containing the token parameters
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenMetadata` - The metadata of the created token
     * * `SdkError` - If there was an error during the token creation
     */
open func createIssuerToken(request: CreateIssuerTokenRequest)async throws  -> TokenMetadata {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_create_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTokenMetadata.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Freezes tokens held at the specified address
     *
     * # Arguments
     *
     * * `request`: The request containing the spark address where the tokens to be frozen are held
     *
     * # Returns
     *
     * Result containing either:
     * * `FreezeIssuerTokenResponse` - The response containing details of the freeze operation
     * * `SdkError` - If there was an error during the freeze process
     */
open func freezeIssuerToken(request: FreezeIssuerTokenRequest)async throws  -> FreezeIssuerTokenResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_freeze_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFreezeIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFreezeIssuerTokenResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Gets the issuer token balance
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenBalance` - The balance of the issuer token
     * * `SdkError` - If there was an error during the retrieval or no issuer token exists
     */
open func getIssuerTokenBalance()async throws  -> TokenBalance {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_balance(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTokenBalance.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Gets the issuer token metadata
     *
     * # Returns
     *
     * Result containing either:
     * * `TokenMetadata` - The metadata of the issuer token
     * * `SdkError` - If there was an error during the retrieval or no issuer token exists
     */
open func getIssuerTokenMetadata()async throws  -> TokenMetadata {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_get_issuer_token_metadata(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTokenMetadata.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Mints supply for the issuer token
     *
     * # Arguments
     *
     * * `request`: The request contiaining the amount of the supply to mint
     *
     * # Returns
     *
     * Result containing either:
     * * `Payment` - The payment representing the minting transaction
     * * `SdkError` - If there was an error during the minting process
     */
open func mintIssuerToken(request: MintIssuerTokenRequest)async throws  -> Payment {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_mint_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMintIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayment.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    
    /**
     * Unfreezes tokens held at the specified address
     *
     * # Arguments
     *
     * * `request`: The request containing the spark address where the tokens to be unfrozen are held
     *
     * # Returns
     *
     * Result containing either:
     * * `UnfreezeIssuerTokenResponse` - The response containing details of the unfreeze operation
     * * `SdkError` - If there was an error during the unfreeze process
     */
open func unfreezeIssuerToken(request: UnfreezeIssuerTokenRequest)async throws  -> UnfreezeIssuerTokenResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_method_tokenissuer_unfreeze_issuer_token(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnfreezeIssuerTokenRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUnfreezeIssuerTokenResponse.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenIssuer: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TokenIssuer

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenIssuer {
        return TokenIssuer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TokenIssuer) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenIssuer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TokenIssuer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenIssuer_lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenIssuer {
    return try FfiConverterTypeTokenIssuer.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenIssuer_lower(_ value: TokenIssuer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTokenIssuer.lower(value)
}


/**
 * Payload of the AES success action, as received from the LNURL endpoint
 *
 * See [`AesSuccessActionDataDecrypted`] for a similar wrapper containing the decrypted payload
 */
public struct AesSuccessActionData {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
     */
    public var ciphertext: String
    /**
     * Base64, initialization vector, exactly 24 characters
     */
    public var iv: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
         */ciphertext: String, 
        /**
         * Base64, initialization vector, exactly 24 characters
         */iv: String) {
        self.description = description
        self.ciphertext = ciphertext
        self.iv = iv
    }
}



extension AesSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: AesSuccessActionData, rhs: AesSuccessActionData) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.ciphertext != rhs.ciphertext {
            return false
        }
        if lhs.iv != rhs.iv {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(ciphertext)
        hasher.combine(iv)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionData {
        return
            try AesSuccessActionData(
                description: FfiConverterString.read(from: &buf), 
                ciphertext: FfiConverterString.read(from: &buf), 
                iv: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.ciphertext, into: &buf)
        FfiConverterString.write(value.iv, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionData_lift(_ buf: RustBuffer) throws -> AesSuccessActionData {
    return try FfiConverterTypeAesSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionData_lower(_ value: AesSuccessActionData) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionData.lower(value)
}


/**
 * Wrapper for the decrypted [`AesSuccessActionData`] payload
 */
public struct AesSuccessActionDataDecrypted {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * Decrypted content
     */
    public var plaintext: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * Decrypted content
         */plaintext: String) {
        self.description = description
        self.plaintext = plaintext
    }
}



extension AesSuccessActionDataDecrypted: Equatable, Hashable {
    public static func ==(lhs: AesSuccessActionDataDecrypted, rhs: AesSuccessActionDataDecrypted) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.plaintext != rhs.plaintext {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(plaintext)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionDataDecrypted: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataDecrypted {
        return
            try AesSuccessActionDataDecrypted(
                description: FfiConverterString.read(from: &buf), 
                plaintext: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionDataDecrypted, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.plaintext, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataDecrypted_lift(_ buf: RustBuffer) throws -> AesSuccessActionDataDecrypted {
    return try FfiConverterTypeAesSuccessActionDataDecrypted.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataDecrypted_lower(_ value: AesSuccessActionDataDecrypted) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionDataDecrypted.lower(value)
}


public struct Bip21Details {
    public var amountSat: UInt64?
    public var assetId: String?
    public var uri: String
    public var extras: [Bip21Extra]
    public var label: String?
    public var message: String?
    public var paymentMethods: [InputType]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSat: UInt64?, assetId: String?, uri: String, extras: [Bip21Extra], label: String?, message: String?, paymentMethods: [InputType]) {
        self.amountSat = amountSat
        self.assetId = assetId
        self.uri = uri
        self.extras = extras
        self.label = label
        self.message = message
        self.paymentMethods = paymentMethods
    }
}



extension Bip21Details: Equatable, Hashable {
    public static func ==(lhs: Bip21Details, rhs: Bip21Details) -> Bool {
        if lhs.amountSat != rhs.amountSat {
            return false
        }
        if lhs.assetId != rhs.assetId {
            return false
        }
        if lhs.uri != rhs.uri {
            return false
        }
        if lhs.extras != rhs.extras {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.paymentMethods != rhs.paymentMethods {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSat)
        hasher.combine(assetId)
        hasher.combine(uri)
        hasher.combine(extras)
        hasher.combine(label)
        hasher.combine(message)
        hasher.combine(paymentMethods)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip21Details: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip21Details {
        return
            try Bip21Details(
                amountSat: FfiConverterOptionUInt64.read(from: &buf), 
                assetId: FfiConverterOptionString.read(from: &buf), 
                uri: FfiConverterString.read(from: &buf), 
                extras: FfiConverterSequenceTypeBip21Extra.read(from: &buf), 
                label: FfiConverterOptionString.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf), 
                paymentMethods: FfiConverterSequenceTypeInputType.read(from: &buf)
        )
    }

    public static func write(_ value: Bip21Details, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.amountSat, into: &buf)
        FfiConverterOptionString.write(value.assetId, into: &buf)
        FfiConverterString.write(value.uri, into: &buf)
        FfiConverterSequenceTypeBip21Extra.write(value.extras, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterSequenceTypeInputType.write(value.paymentMethods, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Details_lift(_ buf: RustBuffer) throws -> Bip21Details {
    return try FfiConverterTypeBip21Details.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Details_lower(_ value: Bip21Details) -> RustBuffer {
    return FfiConverterTypeBip21Details.lower(value)
}


public struct Bip21Extra {
    public var key: String
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}



extension Bip21Extra: Equatable, Hashable {
    public static func ==(lhs: Bip21Extra, rhs: Bip21Extra) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip21Extra: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip21Extra {
        return
            try Bip21Extra(
                key: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Bip21Extra, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Extra_lift(_ buf: RustBuffer) throws -> Bip21Extra {
    return try FfiConverterTypeBip21Extra.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip21Extra_lower(_ value: Bip21Extra) -> RustBuffer {
    return FfiConverterTypeBip21Extra.lower(value)
}


public struct BitcoinAddressDetails {
    public var address: String
    public var network: BitcoinNetwork
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, network: BitcoinNetwork, source: PaymentRequestSource) {
        self.address = address
        self.network = network
        self.source = source
    }
}



extension BitcoinAddressDetails: Equatable, Hashable {
    public static func ==(lhs: BitcoinAddressDetails, rhs: BitcoinAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(network)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinAddressDetails {
        return
            try BitcoinAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: BitcoinAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinAddressDetails_lift(_ buf: RustBuffer) throws -> BitcoinAddressDetails {
    return try FfiConverterTypeBitcoinAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinAddressDetails_lower(_ value: BitcoinAddressDetails) -> RustBuffer {
    return FfiConverterTypeBitcoinAddressDetails.lower(value)
}


public struct Bolt11Invoice {
    public var bolt11: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bolt11: String, source: PaymentRequestSource) {
        self.bolt11 = bolt11
        self.source = source
    }
}



extension Bolt11Invoice: Equatable, Hashable {
    public static func ==(lhs: Bolt11Invoice, rhs: Bolt11Invoice) -> Bool {
        if lhs.bolt11 != rhs.bolt11 {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bolt11)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11Invoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Invoice {
        return
            try Bolt11Invoice(
                bolt11: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11Invoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bolt11, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Invoice_lift(_ buf: RustBuffer) throws -> Bolt11Invoice {
    return try FfiConverterTypeBolt11Invoice.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Invoice_lower(_ value: Bolt11Invoice) -> RustBuffer {
    return FfiConverterTypeBolt11Invoice.lower(value)
}


public struct Bolt11InvoiceDetails {
    public var amountMsat: UInt64?
    public var description: String?
    public var descriptionHash: String?
    public var expiry: UInt64
    public var invoice: Bolt11Invoice
    public var minFinalCltvExpiryDelta: UInt64
    public var network: BitcoinNetwork
    public var payeePubkey: String
    public var paymentHash: String
    public var paymentSecret: String
    public var routingHints: [Bolt11RouteHint]
    public var timestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountMsat: UInt64?, description: String?, descriptionHash: String?, expiry: UInt64, invoice: Bolt11Invoice, minFinalCltvExpiryDelta: UInt64, network: BitcoinNetwork, payeePubkey: String, paymentHash: String, paymentSecret: String, routingHints: [Bolt11RouteHint], timestamp: UInt64) {
        self.amountMsat = amountMsat
        self.description = description
        self.descriptionHash = descriptionHash
        self.expiry = expiry
        self.invoice = invoice
        self.minFinalCltvExpiryDelta = minFinalCltvExpiryDelta
        self.network = network
        self.payeePubkey = payeePubkey
        self.paymentHash = paymentHash
        self.paymentSecret = paymentSecret
        self.routingHints = routingHints
        self.timestamp = timestamp
    }
}



extension Bolt11InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt11InvoiceDetails, rhs: Bolt11InvoiceDetails) -> Bool {
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.minFinalCltvExpiryDelta != rhs.minFinalCltvExpiryDelta {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.payeePubkey != rhs.payeePubkey {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.paymentSecret != rhs.paymentSecret {
            return false
        }
        if lhs.routingHints != rhs.routingHints {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountMsat)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(expiry)
        hasher.combine(invoice)
        hasher.combine(minFinalCltvExpiryDelta)
        hasher.combine(network)
        hasher.combine(payeePubkey)
        hasher.combine(paymentHash)
        hasher.combine(paymentSecret)
        hasher.combine(routingHints)
        hasher.combine(timestamp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11InvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11InvoiceDetails {
        return
            try Bolt11InvoiceDetails(
                amountMsat: FfiConverterOptionUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterUInt64.read(from: &buf), 
                invoice: FfiConverterTypeBolt11Invoice.read(from: &buf), 
                minFinalCltvExpiryDelta: FfiConverterUInt64.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                payeePubkey: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                paymentSecret: FfiConverterString.read(from: &buf), 
                routingHints: FfiConverterSequenceTypeBolt11RouteHint.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterUInt64.write(value.expiry, into: &buf)
        FfiConverterTypeBolt11Invoice.write(value.invoice, into: &buf)
        FfiConverterUInt64.write(value.minFinalCltvExpiryDelta, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterString.write(value.payeePubkey, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterString.write(value.paymentSecret, into: &buf)
        FfiConverterSequenceTypeBolt11RouteHint.write(value.routingHints, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11InvoiceDetails_lift(_ buf: RustBuffer) throws -> Bolt11InvoiceDetails {
    return try FfiConverterTypeBolt11InvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11InvoiceDetails_lower(_ value: Bolt11InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeBolt11InvoiceDetails.lower(value)
}


public struct Bolt11RouteHint {
    public var hops: [Bolt11RouteHintHop]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hops: [Bolt11RouteHintHop]) {
        self.hops = hops
    }
}



extension Bolt11RouteHint: Equatable, Hashable {
    public static func ==(lhs: Bolt11RouteHint, rhs: Bolt11RouteHint) -> Bool {
        if lhs.hops != rhs.hops {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hops)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11RouteHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11RouteHint {
        return
            try Bolt11RouteHint(
                hops: FfiConverterSequenceTypeBolt11RouteHintHop.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11RouteHint, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBolt11RouteHintHop.write(value.hops, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHint_lift(_ buf: RustBuffer) throws -> Bolt11RouteHint {
    return try FfiConverterTypeBolt11RouteHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHint_lower(_ value: Bolt11RouteHint) -> RustBuffer {
    return FfiConverterTypeBolt11RouteHint.lower(value)
}


public struct Bolt11RouteHintHop {
    /**
     * The `node_id` of the non-target end of the route
     */
    public var srcNodeId: String
    /**
     * The `short_channel_id` of this channel
     */
    public var shortChannelId: String
    /**
     * The fees which must be paid to use this channel
     */
    public var feesBaseMsat: UInt32
    public var feesProportionalMillionths: UInt32
    /**
     * The difference in CLTV values between this node and the next node.
     */
    public var cltvExpiryDelta: UInt16
    /**
     * The minimum value, in msat, which must be relayed to the next hop.
     */
    public var htlcMinimumMsat: UInt64?
    /**
     * The maximum value in msat available for routing with a single HTLC.
     */
    public var htlcMaximumMsat: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The `node_id` of the non-target end of the route
         */srcNodeId: String, 
        /**
         * The `short_channel_id` of this channel
         */shortChannelId: String, 
        /**
         * The fees which must be paid to use this channel
         */feesBaseMsat: UInt32, feesProportionalMillionths: UInt32, 
        /**
         * The difference in CLTV values between this node and the next node.
         */cltvExpiryDelta: UInt16, 
        /**
         * The minimum value, in msat, which must be relayed to the next hop.
         */htlcMinimumMsat: UInt64?, 
        /**
         * The maximum value in msat available for routing with a single HTLC.
         */htlcMaximumMsat: UInt64?) {
        self.srcNodeId = srcNodeId
        self.shortChannelId = shortChannelId
        self.feesBaseMsat = feesBaseMsat
        self.feesProportionalMillionths = feesProportionalMillionths
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
    }
}



extension Bolt11RouteHintHop: Equatable, Hashable {
    public static func ==(lhs: Bolt11RouteHintHop, rhs: Bolt11RouteHintHop) -> Bool {
        if lhs.srcNodeId != rhs.srcNodeId {
            return false
        }
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.feesBaseMsat != rhs.feesBaseMsat {
            return false
        }
        if lhs.feesProportionalMillionths != rhs.feesProportionalMillionths {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(srcNodeId)
        hasher.combine(shortChannelId)
        hasher.combine(feesBaseMsat)
        hasher.combine(feesProportionalMillionths)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11RouteHintHop: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11RouteHintHop {
        return
            try Bolt11RouteHintHop(
                srcNodeId: FfiConverterString.read(from: &buf), 
                shortChannelId: FfiConverterString.read(from: &buf), 
                feesBaseMsat: FfiConverterUInt32.read(from: &buf), 
                feesProportionalMillionths: FfiConverterUInt32.read(from: &buf), 
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf), 
                htlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                htlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11RouteHintHop, into buf: inout [UInt8]) {
        FfiConverterString.write(value.srcNodeId, into: &buf)
        FfiConverterString.write(value.shortChannelId, into: &buf)
        FfiConverterUInt32.write(value.feesBaseMsat, into: &buf)
        FfiConverterUInt32.write(value.feesProportionalMillionths, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMaximumMsat, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHintHop_lift(_ buf: RustBuffer) throws -> Bolt11RouteHintHop {
    return try FfiConverterTypeBolt11RouteHintHop.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11RouteHintHop_lower(_ value: Bolt11RouteHintHop) -> RustBuffer {
    return FfiConverterTypeBolt11RouteHintHop.lower(value)
}


public struct Bolt12Invoice {
    public var invoice: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(invoice: String, source: PaymentRequestSource) {
        self.invoice = invoice
        self.source = source
    }
}



extension Bolt12Invoice: Equatable, Hashable {
    public static func ==(lhs: Bolt12Invoice, rhs: Bolt12Invoice) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12Invoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Invoice {
        return
            try Bolt12Invoice(
                invoice: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12Invoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Invoice_lift(_ buf: RustBuffer) throws -> Bolt12Invoice {
    return try FfiConverterTypeBolt12Invoice.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Invoice_lower(_ value: Bolt12Invoice) -> RustBuffer {
    return FfiConverterTypeBolt12Invoice.lower(value)
}


public struct Bolt12InvoiceDetails {
    public var amountMsat: UInt64
    public var invoice: Bolt12Invoice

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountMsat: UInt64, invoice: Bolt12Invoice) {
        self.amountMsat = amountMsat
        self.invoice = invoice
    }
}



extension Bolt12InvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12InvoiceDetails, rhs: Bolt12InvoiceDetails) -> Bool {
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountMsat)
        hasher.combine(invoice)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12InvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12InvoiceDetails {
        return
            try Bolt12InvoiceDetails(
                amountMsat: FfiConverterUInt64.read(from: &buf), 
                invoice: FfiConverterTypeBolt12Invoice.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12InvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountMsat, into: &buf)
        FfiConverterTypeBolt12Invoice.write(value.invoice, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceDetails_lift(_ buf: RustBuffer) throws -> Bolt12InvoiceDetails {
    return try FfiConverterTypeBolt12InvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceDetails_lower(_ value: Bolt12InvoiceDetails) -> RustBuffer {
    return FfiConverterTypeBolt12InvoiceDetails.lower(value)
}


public struct Bolt12InvoiceRequestDetails {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension Bolt12InvoiceRequestDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12InvoiceRequestDetails, rhs: Bolt12InvoiceRequestDetails) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12InvoiceRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12InvoiceRequestDetails {
        return
            Bolt12InvoiceRequestDetails()
    }

    public static func write(_ value: Bolt12InvoiceRequestDetails, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceRequestDetails_lift(_ buf: RustBuffer) throws -> Bolt12InvoiceRequestDetails {
    return try FfiConverterTypeBolt12InvoiceRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12InvoiceRequestDetails_lower(_ value: Bolt12InvoiceRequestDetails) -> RustBuffer {
    return FfiConverterTypeBolt12InvoiceRequestDetails.lower(value)
}


public struct Bolt12Offer {
    public var offer: String
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(offer: String, source: PaymentRequestSource) {
        self.offer = offer
        self.source = source
    }
}



extension Bolt12Offer: Equatable, Hashable {
    public static func ==(lhs: Bolt12Offer, rhs: Bolt12Offer) -> Bool {
        if lhs.offer != rhs.offer {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(offer)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12Offer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Offer {
        return
            try Bolt12Offer(
                offer: FfiConverterString.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12Offer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.offer, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Offer_lift(_ buf: RustBuffer) throws -> Bolt12Offer {
    return try FfiConverterTypeBolt12Offer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Offer_lower(_ value: Bolt12Offer) -> RustBuffer {
    return FfiConverterTypeBolt12Offer.lower(value)
}


public struct Bolt12OfferBlindedPath {
    public var blindedHops: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blindedHops: [String]) {
        self.blindedHops = blindedHops
    }
}



extension Bolt12OfferBlindedPath: Equatable, Hashable {
    public static func ==(lhs: Bolt12OfferBlindedPath, rhs: Bolt12OfferBlindedPath) -> Bool {
        if lhs.blindedHops != rhs.blindedHops {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blindedHops)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12OfferBlindedPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12OfferBlindedPath {
        return
            try Bolt12OfferBlindedPath(
                blindedHops: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12OfferBlindedPath, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.blindedHops, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferBlindedPath_lift(_ buf: RustBuffer) throws -> Bolt12OfferBlindedPath {
    return try FfiConverterTypeBolt12OfferBlindedPath.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferBlindedPath_lower(_ value: Bolt12OfferBlindedPath) -> RustBuffer {
    return FfiConverterTypeBolt12OfferBlindedPath.lower(value)
}


public struct Bolt12OfferDetails {
    public var absoluteExpiry: UInt64?
    public var chains: [String]
    public var description: String?
    public var issuer: String?
    public var minAmount: Amount?
    public var offer: Bolt12Offer
    public var paths: [Bolt12OfferBlindedPath]
    public var signingPubkey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(absoluteExpiry: UInt64?, chains: [String], description: String?, issuer: String?, minAmount: Amount?, offer: Bolt12Offer, paths: [Bolt12OfferBlindedPath], signingPubkey: String?) {
        self.absoluteExpiry = absoluteExpiry
        self.chains = chains
        self.description = description
        self.issuer = issuer
        self.minAmount = minAmount
        self.offer = offer
        self.paths = paths
        self.signingPubkey = signingPubkey
    }
}



extension Bolt12OfferDetails: Equatable, Hashable {
    public static func ==(lhs: Bolt12OfferDetails, rhs: Bolt12OfferDetails) -> Bool {
        if lhs.absoluteExpiry != rhs.absoluteExpiry {
            return false
        }
        if lhs.chains != rhs.chains {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.issuer != rhs.issuer {
            return false
        }
        if lhs.minAmount != rhs.minAmount {
            return false
        }
        if lhs.offer != rhs.offer {
            return false
        }
        if lhs.paths != rhs.paths {
            return false
        }
        if lhs.signingPubkey != rhs.signingPubkey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(absoluteExpiry)
        hasher.combine(chains)
        hasher.combine(description)
        hasher.combine(issuer)
        hasher.combine(minAmount)
        hasher.combine(offer)
        hasher.combine(paths)
        hasher.combine(signingPubkey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12OfferDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12OfferDetails {
        return
            try Bolt12OfferDetails(
                absoluteExpiry: FfiConverterOptionUInt64.read(from: &buf), 
                chains: FfiConverterSequenceString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                issuer: FfiConverterOptionString.read(from: &buf), 
                minAmount: FfiConverterOptionTypeAmount.read(from: &buf), 
                offer: FfiConverterTypeBolt12Offer.read(from: &buf), 
                paths: FfiConverterSequenceTypeBolt12OfferBlindedPath.read(from: &buf), 
                signingPubkey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt12OfferDetails, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.absoluteExpiry, into: &buf)
        FfiConverterSequenceString.write(value.chains, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.issuer, into: &buf)
        FfiConverterOptionTypeAmount.write(value.minAmount, into: &buf)
        FfiConverterTypeBolt12Offer.write(value.offer, into: &buf)
        FfiConverterSequenceTypeBolt12OfferBlindedPath.write(value.paths, into: &buf)
        FfiConverterOptionString.write(value.signingPubkey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferDetails_lift(_ buf: RustBuffer) throws -> Bolt12OfferDetails {
    return try FfiConverterTypeBolt12OfferDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12OfferDetails_lower(_ value: Bolt12OfferDetails) -> RustBuffer {
    return FfiConverterTypeBolt12OfferDetails.lower(value)
}


public struct BurnIssuerTokenRequest {
    public var amount: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: U128) {
        self.amount = amount
    }
}



extension BurnIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: BurnIssuerTokenRequest, rhs: BurnIssuerTokenRequest) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBurnIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BurnIssuerTokenRequest {
        return
            try BurnIssuerTokenRequest(
                amount: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: BurnIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterTypeu128.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBurnIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> BurnIssuerTokenRequest {
    return try FfiConverterTypeBurnIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBurnIssuerTokenRequest_lower(_ value: BurnIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeBurnIssuerTokenRequest.lower(value)
}


/**
 * Request to buy Bitcoin using an external provider (`MoonPay`)
 */
public struct BuyBitcoinRequest {
    /**
     * Optional: Lock the purchase to a specific amount in satoshis.
     * When provided, the user cannot change the amount in the purchase flow.
     */
    public var lockedAmountSat: UInt64?
    /**
     * Optional: Custom redirect URL after purchase completion
     */
    public var redirectUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional: Lock the purchase to a specific amount in satoshis.
         * When provided, the user cannot change the amount in the purchase flow.
         */lockedAmountSat: UInt64? = nil, 
        /**
         * Optional: Custom redirect URL after purchase completion
         */redirectUrl: String? = nil) {
        self.lockedAmountSat = lockedAmountSat
        self.redirectUrl = redirectUrl
    }
}



extension BuyBitcoinRequest: Equatable, Hashable {
    public static func ==(lhs: BuyBitcoinRequest, rhs: BuyBitcoinRequest) -> Bool {
        if lhs.lockedAmountSat != rhs.lockedAmountSat {
            return false
        }
        if lhs.redirectUrl != rhs.redirectUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lockedAmountSat)
        hasher.combine(redirectUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBuyBitcoinRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuyBitcoinRequest {
        return
            try BuyBitcoinRequest(
                lockedAmountSat: FfiConverterOptionUInt64.read(from: &buf), 
                redirectUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: BuyBitcoinRequest, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.lockedAmountSat, into: &buf)
        FfiConverterOptionString.write(value.redirectUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBuyBitcoinRequest_lift(_ buf: RustBuffer) throws -> BuyBitcoinRequest {
    return try FfiConverterTypeBuyBitcoinRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBuyBitcoinRequest_lower(_ value: BuyBitcoinRequest) -> RustBuffer {
    return FfiConverterTypeBuyBitcoinRequest.lower(value)
}


/**
 * Response containing a URL to complete the Bitcoin purchase
 */
public struct BuyBitcoinResponse {
    /**
     * The URL to open in a browser to complete the purchase
     */
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The URL to open in a browser to complete the purchase
         */url: String) {
        self.url = url
    }
}



extension BuyBitcoinResponse: Equatable, Hashable {
    public static func ==(lhs: BuyBitcoinResponse, rhs: BuyBitcoinResponse) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBuyBitcoinResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuyBitcoinResponse {
        return
            try BuyBitcoinResponse(
                url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BuyBitcoinResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBuyBitcoinResponse_lift(_ buf: RustBuffer) throws -> BuyBitcoinResponse {
    return try FfiConverterTypeBuyBitcoinResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBuyBitcoinResponse_lower(_ value: BuyBitcoinResponse) -> RustBuffer {
    return FfiConverterTypeBuyBitcoinResponse.lower(value)
}


public struct CheckLightningAddressRequest {
    public var username: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String) {
        self.username = username
    }
}



extension CheckLightningAddressRequest: Equatable, Hashable {
    public static func ==(lhs: CheckLightningAddressRequest, rhs: CheckLightningAddressRequest) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckLightningAddressRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckLightningAddressRequest {
        return
            try CheckLightningAddressRequest(
                username: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CheckLightningAddressRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckLightningAddressRequest_lift(_ buf: RustBuffer) throws -> CheckLightningAddressRequest {
    return try FfiConverterTypeCheckLightningAddressRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckLightningAddressRequest_lower(_ value: CheckLightningAddressRequest) -> RustBuffer {
    return FfiConverterTypeCheckLightningAddressRequest.lower(value)
}


public struct CheckMessageRequest {
    /**
     * The message that was signed
     */
    public var message: String
    /**
     * The public key that signed the message
     */
    public var pubkey: String
    /**
     * The DER or compact hex encoded signature
     */
    public var signature: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The message that was signed
         */message: String, 
        /**
         * The public key that signed the message
         */pubkey: String, 
        /**
         * The DER or compact hex encoded signature
         */signature: String) {
        self.message = message
        self.pubkey = pubkey
        self.signature = signature
    }
}



extension CheckMessageRequest: Equatable, Hashable {
    public static func ==(lhs: CheckMessageRequest, rhs: CheckMessageRequest) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(pubkey)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckMessageRequest {
        return
            try CheckMessageRequest(
                message: FfiConverterString.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CheckMessageRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageRequest_lift(_ buf: RustBuffer) throws -> CheckMessageRequest {
    return try FfiConverterTypeCheckMessageRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageRequest_lower(_ value: CheckMessageRequest) -> RustBuffer {
    return FfiConverterTypeCheckMessageRequest.lower(value)
}


public struct CheckMessageResponse {
    public var isValid: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isValid: Bool) {
        self.isValid = isValid
    }
}



extension CheckMessageResponse: Equatable, Hashable {
    public static func ==(lhs: CheckMessageResponse, rhs: CheckMessageResponse) -> Bool {
        if lhs.isValid != rhs.isValid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isValid)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckMessageResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckMessageResponse {
        return
            try CheckMessageResponse(
                isValid: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CheckMessageResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isValid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageResponse_lift(_ buf: RustBuffer) throws -> CheckMessageResponse {
    return try FfiConverterTypeCheckMessageResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckMessageResponse_lower(_ value: CheckMessageResponse) -> RustBuffer {
    return FfiConverterTypeCheckMessageResponse.lower(value)
}


public struct ClaimDepositRequest {
    public var txid: String
    public var vout: UInt32
    public var maxFee: MaxFee?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, maxFee: MaxFee? = nil) {
        self.txid = txid
        self.vout = vout
        self.maxFee = maxFee
    }
}



extension ClaimDepositRequest: Equatable, Hashable {
    public static func ==(lhs: ClaimDepositRequest, rhs: ClaimDepositRequest) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.maxFee != rhs.maxFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(maxFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimDepositRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimDepositRequest {
        return
            try ClaimDepositRequest(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                maxFee: FfiConverterOptionTypeMaxFee.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimDepositRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterOptionTypeMaxFee.write(value.maxFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositRequest_lift(_ buf: RustBuffer) throws -> ClaimDepositRequest {
    return try FfiConverterTypeClaimDepositRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositRequest_lower(_ value: ClaimDepositRequest) -> RustBuffer {
    return FfiConverterTypeClaimDepositRequest.lower(value)
}


public struct ClaimDepositResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension ClaimDepositResponse: Equatable, Hashable {
    public static func ==(lhs: ClaimDepositResponse, rhs: ClaimDepositResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimDepositResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimDepositResponse {
        return
            try ClaimDepositResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimDepositResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositResponse_lift(_ buf: RustBuffer) throws -> ClaimDepositResponse {
    return try FfiConverterTypeClaimDepositResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimDepositResponse_lower(_ value: ClaimDepositResponse) -> RustBuffer {
    return FfiConverterTypeClaimDepositResponse.lower(value)
}


public struct ClaimHtlcPaymentRequest {
    public var preimage: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(preimage: String) {
        self.preimage = preimage
    }
}



extension ClaimHtlcPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: ClaimHtlcPaymentRequest, rhs: ClaimHtlcPaymentRequest) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimHtlcPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimHtlcPaymentRequest {
        return
            try ClaimHtlcPaymentRequest(
                preimage: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimHtlcPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimHtlcPaymentRequest_lift(_ buf: RustBuffer) throws -> ClaimHtlcPaymentRequest {
    return try FfiConverterTypeClaimHtlcPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimHtlcPaymentRequest_lower(_ value: ClaimHtlcPaymentRequest) -> RustBuffer {
    return FfiConverterTypeClaimHtlcPaymentRequest.lower(value)
}


public struct ClaimHtlcPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension ClaimHtlcPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: ClaimHtlcPaymentResponse, rhs: ClaimHtlcPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimHtlcPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimHtlcPaymentResponse {
        return
            try ClaimHtlcPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ClaimHtlcPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimHtlcPaymentResponse_lift(_ buf: RustBuffer) throws -> ClaimHtlcPaymentResponse {
    return try FfiConverterTypeClaimHtlcPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimHtlcPaymentResponse_lower(_ value: ClaimHtlcPaymentResponse) -> RustBuffer {
    return FfiConverterTypeClaimHtlcPaymentResponse.lower(value)
}


public struct Config {
    public var apiKey: String?
    public var network: Network
    public var syncIntervalSecs: UInt32
    public var maxDepositClaimFee: MaxFee?
    /**
     * The domain used for receiving through lnurl-pay and lightning address.
     */
    public var lnurlDomain: String?
    /**
     * When this is set to `true` we will prefer to use spark payments over
     * lightning when sending and receiving. This has the benefit of lower fees
     * but is at the cost of privacy.
     */
    public var preferSparkOverLightning: Bool
    /**
     * A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
     * is not recognized. See [`ExternalInputParser`] for more details on how to configure
     * external parsing.
     */
    public var externalInputParsers: [ExternalInputParser]?
    /**
     * The SDK includes some default external input parsers
     * ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
     * Set this to false in order to prevent their use.
     */
    public var useDefaultExternalInputParsers: Bool
    /**
     * Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
     */
    public var realTimeSyncServerUrl: String?
    /**
     * Whether the Spark private mode is enabled by default.
     *
     * If set to true, the Spark private mode will be enabled on the first initialization of the SDK.
     * If set to false, no changes will be made to the Spark private mode.
     */
    public var privateEnabledDefault: Bool
    /**
     * Configuration for leaf optimization.
     *
     * Leaf optimization controls the denominations of leaves that are held in the wallet.
     * Fewer, bigger leaves allow for more funds to be exited unilaterally.
     * More leaves allow payments to be made without needing a swap, reducing payment latency.
     */
    public var optimizationConfig: OptimizationConfig
    /**
     * Configuration for automatic conversion of Bitcoin to stable tokens.
     *
     * When set, received sats will be automatically converted to the specified token
     * once the balance exceeds the threshold.
     */
    public var stableBalanceConfig: StableBalanceConfig?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(apiKey: String?, network: Network, syncIntervalSecs: UInt32, maxDepositClaimFee: MaxFee?, 
        /**
         * The domain used for receiving through lnurl-pay and lightning address.
         */lnurlDomain: String?, 
        /**
         * When this is set to `true` we will prefer to use spark payments over
         * lightning when sending and receiving. This has the benefit of lower fees
         * but is at the cost of privacy.
         */preferSparkOverLightning: Bool, 
        /**
         * A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
         * is not recognized. See [`ExternalInputParser`] for more details on how to configure
         * external parsing.
         */externalInputParsers: [ExternalInputParser]?, 
        /**
         * The SDK includes some default external input parsers
         * ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
         * Set this to false in order to prevent their use.
         */useDefaultExternalInputParsers: Bool, 
        /**
         * Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
         */realTimeSyncServerUrl: String?, 
        /**
         * Whether the Spark private mode is enabled by default.
         *
         * If set to true, the Spark private mode will be enabled on the first initialization of the SDK.
         * If set to false, no changes will be made to the Spark private mode.
         */privateEnabledDefault: Bool, 
        /**
         * Configuration for leaf optimization.
         *
         * Leaf optimization controls the denominations of leaves that are held in the wallet.
         * Fewer, bigger leaves allow for more funds to be exited unilaterally.
         * More leaves allow payments to be made without needing a swap, reducing payment latency.
         */optimizationConfig: OptimizationConfig, 
        /**
         * Configuration for automatic conversion of Bitcoin to stable tokens.
         *
         * When set, received sats will be automatically converted to the specified token
         * once the balance exceeds the threshold.
         */stableBalanceConfig: StableBalanceConfig?) {
        self.apiKey = apiKey
        self.network = network
        self.syncIntervalSecs = syncIntervalSecs
        self.maxDepositClaimFee = maxDepositClaimFee
        self.lnurlDomain = lnurlDomain
        self.preferSparkOverLightning = preferSparkOverLightning
        self.externalInputParsers = externalInputParsers
        self.useDefaultExternalInputParsers = useDefaultExternalInputParsers
        self.realTimeSyncServerUrl = realTimeSyncServerUrl
        self.privateEnabledDefault = privateEnabledDefault
        self.optimizationConfig = optimizationConfig
        self.stableBalanceConfig = stableBalanceConfig
    }
}



extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.apiKey != rhs.apiKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.syncIntervalSecs != rhs.syncIntervalSecs {
            return false
        }
        if lhs.maxDepositClaimFee != rhs.maxDepositClaimFee {
            return false
        }
        if lhs.lnurlDomain != rhs.lnurlDomain {
            return false
        }
        if lhs.preferSparkOverLightning != rhs.preferSparkOverLightning {
            return false
        }
        if lhs.externalInputParsers != rhs.externalInputParsers {
            return false
        }
        if lhs.useDefaultExternalInputParsers != rhs.useDefaultExternalInputParsers {
            return false
        }
        if lhs.realTimeSyncServerUrl != rhs.realTimeSyncServerUrl {
            return false
        }
        if lhs.privateEnabledDefault != rhs.privateEnabledDefault {
            return false
        }
        if lhs.optimizationConfig != rhs.optimizationConfig {
            return false
        }
        if lhs.stableBalanceConfig != rhs.stableBalanceConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(apiKey)
        hasher.combine(network)
        hasher.combine(syncIntervalSecs)
        hasher.combine(maxDepositClaimFee)
        hasher.combine(lnurlDomain)
        hasher.combine(preferSparkOverLightning)
        hasher.combine(externalInputParsers)
        hasher.combine(useDefaultExternalInputParsers)
        hasher.combine(realTimeSyncServerUrl)
        hasher.combine(privateEnabledDefault)
        hasher.combine(optimizationConfig)
        hasher.combine(stableBalanceConfig)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                apiKey: FfiConverterOptionString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                syncIntervalSecs: FfiConverterUInt32.read(from: &buf), 
                maxDepositClaimFee: FfiConverterOptionTypeMaxFee.read(from: &buf), 
                lnurlDomain: FfiConverterOptionString.read(from: &buf), 
                preferSparkOverLightning: FfiConverterBool.read(from: &buf), 
                externalInputParsers: FfiConverterOptionSequenceTypeExternalInputParser.read(from: &buf), 
                useDefaultExternalInputParsers: FfiConverterBool.read(from: &buf), 
                realTimeSyncServerUrl: FfiConverterOptionString.read(from: &buf), 
                privateEnabledDefault: FfiConverterBool.read(from: &buf), 
                optimizationConfig: FfiConverterTypeOptimizationConfig.read(from: &buf), 
                stableBalanceConfig: FfiConverterOptionTypeStableBalanceConfig.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.apiKey, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterUInt32.write(value.syncIntervalSecs, into: &buf)
        FfiConverterOptionTypeMaxFee.write(value.maxDepositClaimFee, into: &buf)
        FfiConverterOptionString.write(value.lnurlDomain, into: &buf)
        FfiConverterBool.write(value.preferSparkOverLightning, into: &buf)
        FfiConverterOptionSequenceTypeExternalInputParser.write(value.externalInputParsers, into: &buf)
        FfiConverterBool.write(value.useDefaultExternalInputParsers, into: &buf)
        FfiConverterOptionString.write(value.realTimeSyncServerUrl, into: &buf)
        FfiConverterBool.write(value.privateEnabledDefault, into: &buf)
        FfiConverterTypeOptimizationConfig.write(value.optimizationConfig, into: &buf)
        FfiConverterOptionTypeStableBalanceConfig.write(value.stableBalanceConfig, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct ConnectRequest {
    public var config: Config
    public var seed: Seed
    public var storageDir: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(config: Config, seed: Seed, storageDir: String) {
        self.config = config
        self.seed = seed
        self.storageDir = storageDir
    }
}



extension ConnectRequest: Equatable, Hashable {
    public static func ==(lhs: ConnectRequest, rhs: ConnectRequest) -> Bool {
        if lhs.config != rhs.config {
            return false
        }
        if lhs.seed != rhs.seed {
            return false
        }
        if lhs.storageDir != rhs.storageDir {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(config)
        hasher.combine(seed)
        hasher.combine(storageDir)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectRequest {
        return
            try ConnectRequest(
                config: FfiConverterTypeConfig.read(from: &buf), 
                seed: FfiConverterTypeSeed.read(from: &buf), 
                storageDir: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ConnectRequest, into buf: inout [UInt8]) {
        FfiConverterTypeConfig.write(value.config, into: &buf)
        FfiConverterTypeSeed.write(value.seed, into: &buf)
        FfiConverterString.write(value.storageDir, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectRequest_lift(_ buf: RustBuffer) throws -> ConnectRequest {
    return try FfiConverterTypeConnectRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectRequest_lower(_ value: ConnectRequest) -> RustBuffer {
    return FfiConverterTypeConnectRequest.lower(value)
}


/**
 * Request object for connecting to the Spark network using an external signer.
 *
 * This allows using a custom signer implementation instead of providing a seed directly.
 */
public struct ConnectWithSignerRequest {
    public var config: Config
    public var signer: ExternalSigner
    public var storageDir: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(config: Config, signer: ExternalSigner, storageDir: String) {
        self.config = config
        self.signer = signer
        self.storageDir = storageDir
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectWithSignerRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectWithSignerRequest {
        return
            try ConnectWithSignerRequest(
                config: FfiConverterTypeConfig.read(from: &buf), 
                signer: FfiConverterTypeExternalSigner.read(from: &buf), 
                storageDir: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ConnectWithSignerRequest, into buf: inout [UInt8]) {
        FfiConverterTypeConfig.write(value.config, into: &buf)
        FfiConverterTypeExternalSigner.write(value.signer, into: &buf)
        FfiConverterString.write(value.storageDir, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectWithSignerRequest_lift(_ buf: RustBuffer) throws -> ConnectWithSignerRequest {
    return try FfiConverterTypeConnectWithSignerRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectWithSignerRequest_lower(_ value: ConnectWithSignerRequest) -> RustBuffer {
    return FfiConverterTypeConnectWithSignerRequest.lower(value)
}


/**
 * Outlines the steps involved in a conversion
 */
public struct ConversionDetails {
    /**
     * First step is converting from the available asset
     */
    public var from: ConversionStep
    /**
     * Second step is converting to the requested asset
     */
    public var to: ConversionStep

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * First step is converting from the available asset
         */from: ConversionStep, 
        /**
         * Second step is converting to the requested asset
         */to: ConversionStep) {
        self.from = from
        self.to = to
    }
}



extension ConversionDetails: Equatable, Hashable {
    public static func ==(lhs: ConversionDetails, rhs: ConversionDetails) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.to != rhs.to {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(from)
        hasher.combine(to)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversionDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversionDetails {
        return
            try ConversionDetails(
                from: FfiConverterTypeConversionStep.read(from: &buf), 
                to: FfiConverterTypeConversionStep.read(from: &buf)
        )
    }

    public static func write(_ value: ConversionDetails, into buf: inout [UInt8]) {
        FfiConverterTypeConversionStep.write(value.from, into: &buf)
        FfiConverterTypeConversionStep.write(value.to, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionDetails_lift(_ buf: RustBuffer) throws -> ConversionDetails {
    return try FfiConverterTypeConversionDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionDetails_lower(_ value: ConversionDetails) -> RustBuffer {
    return FfiConverterTypeConversionDetails.lower(value)
}


/**
 * Response from estimating a conversion, used when preparing a payment that requires conversion
 */
public struct ConversionEstimate {
    /**
     * The conversion options used for the estimate
     */
    public var options: ConversionOptions
    /**
     * The estimated amount to be received from the conversion
     * Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
     */
    public var amount: U128
    /**
     * The fee estimated for the conversion
     * Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
     */
    public var fee: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The conversion options used for the estimate
         */options: ConversionOptions, 
        /**
         * The estimated amount to be received from the conversion
         * Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
         */amount: U128, 
        /**
         * The fee estimated for the conversion
         * Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
         */fee: U128) {
        self.options = options
        self.amount = amount
        self.fee = fee
    }
}



extension ConversionEstimate: Equatable, Hashable {
    public static func ==(lhs: ConversionEstimate, rhs: ConversionEstimate) -> Bool {
        if lhs.options != rhs.options {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(options)
        hasher.combine(amount)
        hasher.combine(fee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversionEstimate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversionEstimate {
        return
            try ConversionEstimate(
                options: FfiConverterTypeConversionOptions.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                fee: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: ConversionEstimate, into buf: inout [UInt8]) {
        FfiConverterTypeConversionOptions.write(value.options, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterTypeu128.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionEstimate_lift(_ buf: RustBuffer) throws -> ConversionEstimate {
    return try FfiConverterTypeConversionEstimate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionEstimate_lower(_ value: ConversionEstimate) -> RustBuffer {
    return FfiConverterTypeConversionEstimate.lower(value)
}


public struct ConversionInfo {
    /**
     * The pool id associated with the conversion
     */
    public var poolId: String
    /**
     * The conversion id shared by both sides of the conversion
     */
    public var conversionId: String
    /**
     * The status of the conversion
     */
    public var status: ConversionStatus
    /**
     * The fee paid for the conversion
     * Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
     */
    public var fee: U128?
    /**
     * The purpose of the conversion
     */
    public var purpose: ConversionPurpose?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The pool id associated with the conversion
         */poolId: String, 
        /**
         * The conversion id shared by both sides of the conversion
         */conversionId: String, 
        /**
         * The status of the conversion
         */status: ConversionStatus, 
        /**
         * The fee paid for the conversion
         * Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
         */fee: U128?, 
        /**
         * The purpose of the conversion
         */purpose: ConversionPurpose?) {
        self.poolId = poolId
        self.conversionId = conversionId
        self.status = status
        self.fee = fee
        self.purpose = purpose
    }
}



extension ConversionInfo: Equatable, Hashable {
    public static func ==(lhs: ConversionInfo, rhs: ConversionInfo) -> Bool {
        if lhs.poolId != rhs.poolId {
            return false
        }
        if lhs.conversionId != rhs.conversionId {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        if lhs.purpose != rhs.purpose {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolId)
        hasher.combine(conversionId)
        hasher.combine(status)
        hasher.combine(fee)
        hasher.combine(purpose)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversionInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversionInfo {
        return
            try ConversionInfo(
                poolId: FfiConverterString.read(from: &buf), 
                conversionId: FfiConverterString.read(from: &buf), 
                status: FfiConverterTypeConversionStatus.read(from: &buf), 
                fee: FfiConverterOptionTypeu128.read(from: &buf), 
                purpose: FfiConverterOptionTypeConversionPurpose.read(from: &buf)
        )
    }

    public static func write(_ value: ConversionInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.poolId, into: &buf)
        FfiConverterString.write(value.conversionId, into: &buf)
        FfiConverterTypeConversionStatus.write(value.status, into: &buf)
        FfiConverterOptionTypeu128.write(value.fee, into: &buf)
        FfiConverterOptionTypeConversionPurpose.write(value.purpose, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionInfo_lift(_ buf: RustBuffer) throws -> ConversionInfo {
    return try FfiConverterTypeConversionInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionInfo_lower(_ value: ConversionInfo) -> RustBuffer {
    return FfiConverterTypeConversionInfo.lower(value)
}


/**
 * Options for conversion when fulfilling a payment. When set, the SDK will
 * perform a conversion before fulfilling the payment. If not set, the payment
 * will only be fulfilled if the wallet has sufficient balance of the required asset.
 */
public struct ConversionOptions {
    /**
     * The type of conversion to perform when fulfilling the payment
     */
    public var conversionType: ConversionType
    /**
     * The optional maximum slippage in basis points (1/100 of a percent) allowed when
     * a conversion is needed to fulfill the payment. Defaults to 10 bps (0.1%) if not set.
     * The conversion will fail if the actual amount received is less than
     * `estimated_amount * (1 - max_slippage_bps / 10_000)`.
     */
    public var maxSlippageBps: UInt32?
    /**
     * The optional timeout in seconds to wait for the conversion to complete
     * when fulfilling the payment. This timeout only concerns waiting for the received
     * payment of the conversion. If the timeout is reached before the conversion
     * is complete, the payment will fail. Defaults to 30 seconds if not set.
     */
    public var completionTimeoutSecs: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The type of conversion to perform when fulfilling the payment
         */conversionType: ConversionType, 
        /**
         * The optional maximum slippage in basis points (1/100 of a percent) allowed when
         * a conversion is needed to fulfill the payment. Defaults to 10 bps (0.1%) if not set.
         * The conversion will fail if the actual amount received is less than
         * `estimated_amount * (1 - max_slippage_bps / 10_000)`.
         */maxSlippageBps: UInt32? = nil, 
        /**
         * The optional timeout in seconds to wait for the conversion to complete
         * when fulfilling the payment. This timeout only concerns waiting for the received
         * payment of the conversion. If the timeout is reached before the conversion
         * is complete, the payment will fail. Defaults to 30 seconds if not set.
         */completionTimeoutSecs: UInt32? = nil) {
        self.conversionType = conversionType
        self.maxSlippageBps = maxSlippageBps
        self.completionTimeoutSecs = completionTimeoutSecs
    }
}



extension ConversionOptions: Equatable, Hashable {
    public static func ==(lhs: ConversionOptions, rhs: ConversionOptions) -> Bool {
        if lhs.conversionType != rhs.conversionType {
            return false
        }
        if lhs.maxSlippageBps != rhs.maxSlippageBps {
            return false
        }
        if lhs.completionTimeoutSecs != rhs.completionTimeoutSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(conversionType)
        hasher.combine(maxSlippageBps)
        hasher.combine(completionTimeoutSecs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversionOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversionOptions {
        return
            try ConversionOptions(
                conversionType: FfiConverterTypeConversionType.read(from: &buf), 
                maxSlippageBps: FfiConverterOptionUInt32.read(from: &buf), 
                completionTimeoutSecs: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ConversionOptions, into buf: inout [UInt8]) {
        FfiConverterTypeConversionType.write(value.conversionType, into: &buf)
        FfiConverterOptionUInt32.write(value.maxSlippageBps, into: &buf)
        FfiConverterOptionUInt32.write(value.completionTimeoutSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionOptions_lift(_ buf: RustBuffer) throws -> ConversionOptions {
    return try FfiConverterTypeConversionOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionOptions_lower(_ value: ConversionOptions) -> RustBuffer {
    return FfiConverterTypeConversionOptions.lower(value)
}


/**
 * A single step in a conversion
 */
public struct ConversionStep {
    /**
     * The underlying payment id of the conversion step
     */
    public var paymentId: String
    /**
     * Payment amount in satoshis or token base units
     */
    public var amount: U128
    /**
     * Fee paid in satoshis or token base units
     * This represents the payment fee + the conversion fee
     */
    public var fee: U128
    /**
     * Method of payment
     */
    public var method: PaymentMethod
    /**
     * Token metadata if a token is used for payment
     */
    public var tokenMetadata: TokenMetadata?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The underlying payment id of the conversion step
         */paymentId: String, 
        /**
         * Payment amount in satoshis or token base units
         */amount: U128, 
        /**
         * Fee paid in satoshis or token base units
         * This represents the payment fee + the conversion fee
         */fee: U128, 
        /**
         * Method of payment
         */method: PaymentMethod, 
        /**
         * Token metadata if a token is used for payment
         */tokenMetadata: TokenMetadata?) {
        self.paymentId = paymentId
        self.amount = amount
        self.fee = fee
        self.method = method
        self.tokenMetadata = tokenMetadata
    }
}



extension ConversionStep: Equatable, Hashable {
    public static func ==(lhs: ConversionStep, rhs: ConversionStep) -> Bool {
        if lhs.paymentId != rhs.paymentId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.tokenMetadata != rhs.tokenMetadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentId)
        hasher.combine(amount)
        hasher.combine(fee)
        hasher.combine(method)
        hasher.combine(tokenMetadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversionStep: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversionStep {
        return
            try ConversionStep(
                paymentId: FfiConverterString.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                fee: FfiConverterTypeu128.read(from: &buf), 
                method: FfiConverterTypePaymentMethod.read(from: &buf), 
                tokenMetadata: FfiConverterOptionTypeTokenMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: ConversionStep, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentId, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterTypeu128.write(value.fee, into: &buf)
        FfiConverterTypePaymentMethod.write(value.method, into: &buf)
        FfiConverterOptionTypeTokenMetadata.write(value.tokenMetadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionStep_lift(_ buf: RustBuffer) throws -> ConversionStep {
    return try FfiConverterTypeConversionStep.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionStep_lower(_ value: ConversionStep) -> RustBuffer {
    return FfiConverterTypeConversionStep.lower(value)
}


public struct CreateIssuerTokenRequest {
    public var name: String
    public var ticker: String
    public var decimals: UInt32
    public var isFreezable: Bool
    public var maxSupply: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, ticker: String, decimals: UInt32, isFreezable: Bool, maxSupply: U128) {
        self.name = name
        self.ticker = ticker
        self.decimals = decimals
        self.isFreezable = isFreezable
        self.maxSupply = maxSupply
    }
}



extension CreateIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: CreateIssuerTokenRequest, rhs: CreateIssuerTokenRequest) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.isFreezable != rhs.isFreezable {
            return false
        }
        if lhs.maxSupply != rhs.maxSupply {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(ticker)
        hasher.combine(decimals)
        hasher.combine(isFreezable)
        hasher.combine(maxSupply)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateIssuerTokenRequest {
        return
            try CreateIssuerTokenRequest(
                name: FfiConverterString.read(from: &buf), 
                ticker: FfiConverterString.read(from: &buf), 
                decimals: FfiConverterUInt32.read(from: &buf), 
                isFreezable: FfiConverterBool.read(from: &buf), 
                maxSupply: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: CreateIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.ticker, into: &buf)
        FfiConverterUInt32.write(value.decimals, into: &buf)
        FfiConverterBool.write(value.isFreezable, into: &buf)
        FfiConverterTypeu128.write(value.maxSupply, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> CreateIssuerTokenRequest {
    return try FfiConverterTypeCreateIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateIssuerTokenRequest_lower(_ value: CreateIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeCreateIssuerTokenRequest.lower(value)
}


public struct Credentials {
    public var username: String
    public var password: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String, password: String) {
        self.username = username
        self.password = password
    }
}



extension Credentials: Equatable, Hashable {
    public static func ==(lhs: Credentials, rhs: Credentials) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentials: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Credentials {
        return
            try Credentials(
                username: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Credentials, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentials_lift(_ buf: RustBuffer) throws -> Credentials {
    return try FfiConverterTypeCredentials.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentials_lower(_ value: Credentials) -> RustBuffer {
    return FfiConverterTypeCredentials.lower(value)
}


/**
 * Details about a supported currency in the fiat rate feed
 */
public struct CurrencyInfo {
    public var name: String
    public var fractionSize: UInt32
    public var spacing: UInt32?
    public var symbol: Symbol?
    public var uniqSymbol: Symbol?
    public var localizedName: [LocalizedName]
    public var localeOverrides: [LocaleOverrides]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, fractionSize: UInt32, spacing: UInt32?, symbol: Symbol?, uniqSymbol: Symbol?, localizedName: [LocalizedName], localeOverrides: [LocaleOverrides]) {
        self.name = name
        self.fractionSize = fractionSize
        self.spacing = spacing
        self.symbol = symbol
        self.uniqSymbol = uniqSymbol
        self.localizedName = localizedName
        self.localeOverrides = localeOverrides
    }
}



extension CurrencyInfo: Equatable, Hashable {
    public static func ==(lhs: CurrencyInfo, rhs: CurrencyInfo) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.fractionSize != rhs.fractionSize {
            return false
        }
        if lhs.spacing != rhs.spacing {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.uniqSymbol != rhs.uniqSymbol {
            return false
        }
        if lhs.localizedName != rhs.localizedName {
            return false
        }
        if lhs.localeOverrides != rhs.localeOverrides {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(fractionSize)
        hasher.combine(spacing)
        hasher.combine(symbol)
        hasher.combine(uniqSymbol)
        hasher.combine(localizedName)
        hasher.combine(localeOverrides)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCurrencyInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurrencyInfo {
        return
            try CurrencyInfo(
                name: FfiConverterString.read(from: &buf), 
                fractionSize: FfiConverterUInt32.read(from: &buf), 
                spacing: FfiConverterOptionUInt32.read(from: &buf), 
                symbol: FfiConverterOptionTypeSymbol.read(from: &buf), 
                uniqSymbol: FfiConverterOptionTypeSymbol.read(from: &buf), 
                localizedName: FfiConverterSequenceTypeLocalizedName.read(from: &buf), 
                localeOverrides: FfiConverterSequenceTypeLocaleOverrides.read(from: &buf)
        )
    }

    public static func write(_ value: CurrencyInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt32.write(value.fractionSize, into: &buf)
        FfiConverterOptionUInt32.write(value.spacing, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.symbol, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.uniqSymbol, into: &buf)
        FfiConverterSequenceTypeLocalizedName.write(value.localizedName, into: &buf)
        FfiConverterSequenceTypeLocaleOverrides.write(value.localeOverrides, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrencyInfo_lift(_ buf: RustBuffer) throws -> CurrencyInfo {
    return try FfiConverterTypeCurrencyInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrencyInfo_lower(_ value: CurrencyInfo) -> RustBuffer {
    return FfiConverterTypeCurrencyInfo.lower(value)
}


public struct DepositInfo {
    public var txid: String
    public var vout: UInt32
    public var amountSats: UInt64
    public var refundTx: String?
    public var refundTxId: String?
    public var claimError: DepositClaimError?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, amountSats: UInt64, refundTx: String?, refundTxId: String?, claimError: DepositClaimError?) {
        self.txid = txid
        self.vout = vout
        self.amountSats = amountSats
        self.refundTx = refundTx
        self.refundTxId = refundTxId
        self.claimError = claimError
    }
}



extension DepositInfo: Equatable, Hashable {
    public static func ==(lhs: DepositInfo, rhs: DepositInfo) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.refundTx != rhs.refundTx {
            return false
        }
        if lhs.refundTxId != rhs.refundTxId {
            return false
        }
        if lhs.claimError != rhs.claimError {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(amountSats)
        hasher.combine(refundTx)
        hasher.combine(refundTxId)
        hasher.combine(claimError)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositInfo {
        return
            try DepositInfo(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                amountSats: FfiConverterUInt64.read(from: &buf), 
                refundTx: FfiConverterOptionString.read(from: &buf), 
                refundTxId: FfiConverterOptionString.read(from: &buf), 
                claimError: FfiConverterOptionTypeDepositClaimError.read(from: &buf)
        )
    }

    public static func write(_ value: DepositInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.refundTx, into: &buf)
        FfiConverterOptionString.write(value.refundTxId, into: &buf)
        FfiConverterOptionTypeDepositClaimError.write(value.claimError, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositInfo_lift(_ buf: RustBuffer) throws -> DepositInfo {
    return try FfiConverterTypeDepositInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositInfo_lower(_ value: DepositInfo) -> RustBuffer {
    return FfiConverterTypeDepositInfo.lower(value)
}


/**
 * FFI-safe representation of an ECDSA signature (64 bytes)
 */
public struct EcdsaSignatureBytes {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}



extension EcdsaSignatureBytes: Equatable, Hashable {
    public static func ==(lhs: EcdsaSignatureBytes, rhs: EcdsaSignatureBytes) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEcdsaSignatureBytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EcdsaSignatureBytes {
        return
            try EcdsaSignatureBytes(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: EcdsaSignatureBytes, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEcdsaSignatureBytes_lift(_ buf: RustBuffer) throws -> EcdsaSignatureBytes {
    return try FfiConverterTypeEcdsaSignatureBytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEcdsaSignatureBytes_lower(_ value: EcdsaSignatureBytes) -> RustBuffer {
    return FfiConverterTypeEcdsaSignatureBytes.lower(value)
}


/**
 * FFI-safe representation of `spark_wallet::AggregateFrostRequest`
 */
public struct ExternalAggregateFrostRequest {
    /**
     * The message that was signed
     */
    public var message: Data
    /**
     * Statechain signatures as a list of identifier-signature pairs
     */
    public var statechainSignatures: [IdentifierSignaturePair]
    /**
     * Statechain public keys as a list of identifier-publickey pairs
     */
    public var statechainPublicKeys: [IdentifierPublicKeyPair]
    /**
     * The verifying key (33 bytes compressed)
     */
    public var verifyingKey: Data
    /**
     * Statechain commitments as a list of identifier-commitment pairs
     */
    public var statechainCommitments: [IdentifierCommitmentPair]
    /**
     * The self commitment
     */
    public var selfCommitment: ExternalSigningCommitments
    /**
     * The public key (33 bytes compressed)
     */
    public var publicKey: Data
    /**
     * The self signature share
     */
    public var selfSignature: ExternalFrostSignatureShare
    /**
     * Optional adaptor public key (33 bytes compressed)
     */
    public var adaptorPublicKey: Data?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The message that was signed
         */message: Data, 
        /**
         * Statechain signatures as a list of identifier-signature pairs
         */statechainSignatures: [IdentifierSignaturePair], 
        /**
         * Statechain public keys as a list of identifier-publickey pairs
         */statechainPublicKeys: [IdentifierPublicKeyPair], 
        /**
         * The verifying key (33 bytes compressed)
         */verifyingKey: Data, 
        /**
         * Statechain commitments as a list of identifier-commitment pairs
         */statechainCommitments: [IdentifierCommitmentPair], 
        /**
         * The self commitment
         */selfCommitment: ExternalSigningCommitments, 
        /**
         * The public key (33 bytes compressed)
         */publicKey: Data, 
        /**
         * The self signature share
         */selfSignature: ExternalFrostSignatureShare, 
        /**
         * Optional adaptor public key (33 bytes compressed)
         */adaptorPublicKey: Data?) {
        self.message = message
        self.statechainSignatures = statechainSignatures
        self.statechainPublicKeys = statechainPublicKeys
        self.verifyingKey = verifyingKey
        self.statechainCommitments = statechainCommitments
        self.selfCommitment = selfCommitment
        self.publicKey = publicKey
        self.selfSignature = selfSignature
        self.adaptorPublicKey = adaptorPublicKey
    }
}



extension ExternalAggregateFrostRequest: Equatable, Hashable {
    public static func ==(lhs: ExternalAggregateFrostRequest, rhs: ExternalAggregateFrostRequest) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.statechainSignatures != rhs.statechainSignatures {
            return false
        }
        if lhs.statechainPublicKeys != rhs.statechainPublicKeys {
            return false
        }
        if lhs.verifyingKey != rhs.verifyingKey {
            return false
        }
        if lhs.statechainCommitments != rhs.statechainCommitments {
            return false
        }
        if lhs.selfCommitment != rhs.selfCommitment {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.selfSignature != rhs.selfSignature {
            return false
        }
        if lhs.adaptorPublicKey != rhs.adaptorPublicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(statechainSignatures)
        hasher.combine(statechainPublicKeys)
        hasher.combine(verifyingKey)
        hasher.combine(statechainCommitments)
        hasher.combine(selfCommitment)
        hasher.combine(publicKey)
        hasher.combine(selfSignature)
        hasher.combine(adaptorPublicKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalAggregateFrostRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalAggregateFrostRequest {
        return
            try ExternalAggregateFrostRequest(
                message: FfiConverterData.read(from: &buf), 
                statechainSignatures: FfiConverterSequenceTypeIdentifierSignaturePair.read(from: &buf), 
                statechainPublicKeys: FfiConverterSequenceTypeIdentifierPublicKeyPair.read(from: &buf), 
                verifyingKey: FfiConverterData.read(from: &buf), 
                statechainCommitments: FfiConverterSequenceTypeIdentifierCommitmentPair.read(from: &buf), 
                selfCommitment: FfiConverterTypeExternalSigningCommitments.read(from: &buf), 
                publicKey: FfiConverterData.read(from: &buf), 
                selfSignature: FfiConverterTypeExternalFrostSignatureShare.read(from: &buf), 
                adaptorPublicKey: FfiConverterOptionData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalAggregateFrostRequest, into buf: inout [UInt8]) {
        FfiConverterData.write(value.message, into: &buf)
        FfiConverterSequenceTypeIdentifierSignaturePair.write(value.statechainSignatures, into: &buf)
        FfiConverterSequenceTypeIdentifierPublicKeyPair.write(value.statechainPublicKeys, into: &buf)
        FfiConverterData.write(value.verifyingKey, into: &buf)
        FfiConverterSequenceTypeIdentifierCommitmentPair.write(value.statechainCommitments, into: &buf)
        FfiConverterTypeExternalSigningCommitments.write(value.selfCommitment, into: &buf)
        FfiConverterData.write(value.publicKey, into: &buf)
        FfiConverterTypeExternalFrostSignatureShare.write(value.selfSignature, into: &buf)
        FfiConverterOptionData.write(value.adaptorPublicKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalAggregateFrostRequest_lift(_ buf: RustBuffer) throws -> ExternalAggregateFrostRequest {
    return try FfiConverterTypeExternalAggregateFrostRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalAggregateFrostRequest_lower(_ value: ExternalAggregateFrostRequest) -> RustBuffer {
    return FfiConverterTypeExternalAggregateFrostRequest.lower(value)
}


/**
 * FFI-safe representation of `spark_wallet::EncryptedSecret`
 */
public struct ExternalEncryptedSecret {
    /**
     * The encrypted ciphertext
     */
    public var ciphertext: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The encrypted ciphertext
         */ciphertext: Data) {
        self.ciphertext = ciphertext
    }
}



extension ExternalEncryptedSecret: Equatable, Hashable {
    public static func ==(lhs: ExternalEncryptedSecret, rhs: ExternalEncryptedSecret) -> Bool {
        if lhs.ciphertext != rhs.ciphertext {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ciphertext)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalEncryptedSecret: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalEncryptedSecret {
        return
            try ExternalEncryptedSecret(
                ciphertext: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalEncryptedSecret, into buf: inout [UInt8]) {
        FfiConverterData.write(value.ciphertext, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalEncryptedSecret_lift(_ buf: RustBuffer) throws -> ExternalEncryptedSecret {
    return try FfiConverterTypeExternalEncryptedSecret.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalEncryptedSecret_lower(_ value: ExternalEncryptedSecret) -> RustBuffer {
    return FfiConverterTypeExternalEncryptedSecret.lower(value)
}


/**
 * FFI-safe representation of `spark_wallet::FrostSigningCommitmentsWithNonces`
 */
public struct ExternalFrostCommitments {
    /**
     * Serialized hiding nonce commitment (variable length, typically 33 bytes compressed point)
     */
    public var hidingCommitment: Data
    /**
     * Serialized binding nonce commitment (variable length, typically 33 bytes compressed point)
     */
    public var bindingCommitment: Data
    /**
     * Encrypted nonces ciphertext
     */
    public var noncesCiphertext: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Serialized hiding nonce commitment (variable length, typically 33 bytes compressed point)
         */hidingCommitment: Data, 
        /**
         * Serialized binding nonce commitment (variable length, typically 33 bytes compressed point)
         */bindingCommitment: Data, 
        /**
         * Encrypted nonces ciphertext
         */noncesCiphertext: Data) {
        self.hidingCommitment = hidingCommitment
        self.bindingCommitment = bindingCommitment
        self.noncesCiphertext = noncesCiphertext
    }
}



extension ExternalFrostCommitments: Equatable, Hashable {
    public static func ==(lhs: ExternalFrostCommitments, rhs: ExternalFrostCommitments) -> Bool {
        if lhs.hidingCommitment != rhs.hidingCommitment {
            return false
        }
        if lhs.bindingCommitment != rhs.bindingCommitment {
            return false
        }
        if lhs.noncesCiphertext != rhs.noncesCiphertext {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hidingCommitment)
        hasher.combine(bindingCommitment)
        hasher.combine(noncesCiphertext)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalFrostCommitments: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalFrostCommitments {
        return
            try ExternalFrostCommitments(
                hidingCommitment: FfiConverterData.read(from: &buf), 
                bindingCommitment: FfiConverterData.read(from: &buf), 
                noncesCiphertext: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalFrostCommitments, into buf: inout [UInt8]) {
        FfiConverterData.write(value.hidingCommitment, into: &buf)
        FfiConverterData.write(value.bindingCommitment, into: &buf)
        FfiConverterData.write(value.noncesCiphertext, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalFrostCommitments_lift(_ buf: RustBuffer) throws -> ExternalFrostCommitments {
    return try FfiConverterTypeExternalFrostCommitments.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalFrostCommitments_lower(_ value: ExternalFrostCommitments) -> RustBuffer {
    return FfiConverterTypeExternalFrostCommitments.lower(value)
}


/**
 * FFI-safe representation of `frost_secp256k1_tr::Signature`
 */
public struct ExternalFrostSignature {
    /**
     * Serialized Frost signature bytes (64 bytes)
     */
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Serialized Frost signature bytes (64 bytes)
         */bytes: Data) {
        self.bytes = bytes
    }
}



extension ExternalFrostSignature: Equatable, Hashable {
    public static func ==(lhs: ExternalFrostSignature, rhs: ExternalFrostSignature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalFrostSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalFrostSignature {
        return
            try ExternalFrostSignature(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalFrostSignature, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalFrostSignature_lift(_ buf: RustBuffer) throws -> ExternalFrostSignature {
    return try FfiConverterTypeExternalFrostSignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalFrostSignature_lower(_ value: ExternalFrostSignature) -> RustBuffer {
    return FfiConverterTypeExternalFrostSignature.lower(value)
}


/**
 * FFI-safe representation of `frost_secp256k1_tr::round2::SignatureShare`
 */
public struct ExternalFrostSignatureShare {
    /**
     * Serialized signature share bytes (variable length, typically 32 bytes)
     */
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Serialized signature share bytes (variable length, typically 32 bytes)
         */bytes: Data) {
        self.bytes = bytes
    }
}



extension ExternalFrostSignatureShare: Equatable, Hashable {
    public static func ==(lhs: ExternalFrostSignatureShare, rhs: ExternalFrostSignatureShare) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalFrostSignatureShare: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalFrostSignatureShare {
        return
            try ExternalFrostSignatureShare(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalFrostSignatureShare, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalFrostSignatureShare_lift(_ buf: RustBuffer) throws -> ExternalFrostSignatureShare {
    return try FfiConverterTypeExternalFrostSignatureShare.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalFrostSignatureShare_lower(_ value: ExternalFrostSignatureShare) -> RustBuffer {
    return FfiConverterTypeExternalFrostSignatureShare.lower(value)
}


/**
 * FFI-safe representation of `frost_secp256k1_tr::Identifier`
 */
public struct ExternalIdentifier {
    /**
     * Serialized identifier bytes
     */
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Serialized identifier bytes
         */bytes: Data) {
        self.bytes = bytes
    }
}



extension ExternalIdentifier: Equatable, Hashable {
    public static func ==(lhs: ExternalIdentifier, rhs: ExternalIdentifier) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalIdentifier {
        return
            try ExternalIdentifier(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalIdentifier, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalIdentifier_lift(_ buf: RustBuffer) throws -> ExternalIdentifier {
    return try FfiConverterTypeExternalIdentifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalIdentifier_lower(_ value: ExternalIdentifier) -> RustBuffer {
    return FfiConverterTypeExternalIdentifier.lower(value)
}


/**
 * Configuration for an external input parser
 */
public struct ExternalInputParser {
    /**
     * An arbitrary parser provider id
     */
    public var providerId: String
    /**
     * The external parser will be used when an input conforms to this regex
     */
    public var inputRegex: String
    /**
     * The URL of the parser containing a placeholder `<input>` that will be replaced with the
     * input to be parsed. The input is sanitized using percent encoding.
     */
    public var parserUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * An arbitrary parser provider id
         */providerId: String, 
        /**
         * The external parser will be used when an input conforms to this regex
         */inputRegex: String, 
        /**
         * The URL of the parser containing a placeholder `<input>` that will be replaced with the
         * input to be parsed. The input is sanitized using percent encoding.
         */parserUrl: String) {
        self.providerId = providerId
        self.inputRegex = inputRegex
        self.parserUrl = parserUrl
    }
}



extension ExternalInputParser: Equatable, Hashable {
    public static func ==(lhs: ExternalInputParser, rhs: ExternalInputParser) -> Bool {
        if lhs.providerId != rhs.providerId {
            return false
        }
        if lhs.inputRegex != rhs.inputRegex {
            return false
        }
        if lhs.parserUrl != rhs.parserUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(providerId)
        hasher.combine(inputRegex)
        hasher.combine(parserUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalInputParser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalInputParser {
        return
            try ExternalInputParser(
                providerId: FfiConverterString.read(from: &buf), 
                inputRegex: FfiConverterString.read(from: &buf), 
                parserUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalInputParser, into buf: inout [UInt8]) {
        FfiConverterString.write(value.providerId, into: &buf)
        FfiConverterString.write(value.inputRegex, into: &buf)
        FfiConverterString.write(value.parserUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalInputParser_lift(_ buf: RustBuffer) throws -> ExternalInputParser {
    return try FfiConverterTypeExternalInputParser.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalInputParser_lower(_ value: ExternalInputParser) -> RustBuffer {
    return FfiConverterTypeExternalInputParser.lower(value)
}


/**
 * FFI-safe representation of `k256::Scalar` (32 bytes)
 */
public struct ExternalScalar {
    /**
     * The 32-byte scalar value
     */
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The 32-byte scalar value
         */bytes: Data) {
        self.bytes = bytes
    }
}



extension ExternalScalar: Equatable, Hashable {
    public static func ==(lhs: ExternalScalar, rhs: ExternalScalar) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalScalar: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalScalar {
        return
            try ExternalScalar(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalScalar, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalScalar_lift(_ buf: RustBuffer) throws -> ExternalScalar {
    return try FfiConverterTypeExternalScalar.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalScalar_lower(_ value: ExternalScalar) -> RustBuffer {
    return FfiConverterTypeExternalScalar.lower(value)
}


/**
 * FFI-safe representation of `spark_wallet::SecretShare`
 */
public struct ExternalSecretShare {
    /**
     * Number of shares required to recover the secret
     */
    public var threshold: UInt32
    /**
     * Index (x-coordinate) of the share as 32 bytes
     */
    public var index: ExternalScalar
    /**
     * Share value (y-coordinate) as 32 bytes
     */
    public var share: ExternalScalar

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Number of shares required to recover the secret
         */threshold: UInt32, 
        /**
         * Index (x-coordinate) of the share as 32 bytes
         */index: ExternalScalar, 
        /**
         * Share value (y-coordinate) as 32 bytes
         */share: ExternalScalar) {
        self.threshold = threshold
        self.index = index
        self.share = share
    }
}



extension ExternalSecretShare: Equatable, Hashable {
    public static func ==(lhs: ExternalSecretShare, rhs: ExternalSecretShare) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.share != rhs.share {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(index)
        hasher.combine(share)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalSecretShare: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalSecretShare {
        return
            try ExternalSecretShare(
                threshold: FfiConverterUInt32.read(from: &buf), 
                index: FfiConverterTypeExternalScalar.read(from: &buf), 
                share: FfiConverterTypeExternalScalar.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalSecretShare, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.threshold, into: &buf)
        FfiConverterTypeExternalScalar.write(value.index, into: &buf)
        FfiConverterTypeExternalScalar.write(value.share, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSecretShare_lift(_ buf: RustBuffer) throws -> ExternalSecretShare {
    return try FfiConverterTypeExternalSecretShare.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSecretShare_lower(_ value: ExternalSecretShare) -> RustBuffer {
    return FfiConverterTypeExternalSecretShare.lower(value)
}


/**
 * FFI-safe representation of `spark_wallet::SignFrostRequest`
 */
public struct ExternalSignFrostRequest {
    /**
     * The message to sign
     */
    public var message: Data
    /**
     * The public key (33 bytes compressed)
     */
    public var publicKey: Data
    /**
     * The private key source
     */
    public var secret: ExternalSecretSource
    /**
     * The verifying key (33 bytes compressed)
     */
    public var verifyingKey: Data
    /**
     * The self nonce commitment
     */
    public var selfNonceCommitment: ExternalFrostCommitments
    /**
     * Statechain commitments as a list of identifier-commitment pairs
     */
    public var statechainCommitments: [IdentifierCommitmentPair]
    /**
     * Optional adaptor public key (33 bytes compressed)
     */
    public var adaptorPublicKey: Data?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The message to sign
         */message: Data, 
        /**
         * The public key (33 bytes compressed)
         */publicKey: Data, 
        /**
         * The private key source
         */secret: ExternalSecretSource, 
        /**
         * The verifying key (33 bytes compressed)
         */verifyingKey: Data, 
        /**
         * The self nonce commitment
         */selfNonceCommitment: ExternalFrostCommitments, 
        /**
         * Statechain commitments as a list of identifier-commitment pairs
         */statechainCommitments: [IdentifierCommitmentPair], 
        /**
         * Optional adaptor public key (33 bytes compressed)
         */adaptorPublicKey: Data?) {
        self.message = message
        self.publicKey = publicKey
        self.secret = secret
        self.verifyingKey = verifyingKey
        self.selfNonceCommitment = selfNonceCommitment
        self.statechainCommitments = statechainCommitments
        self.adaptorPublicKey = adaptorPublicKey
    }
}



extension ExternalSignFrostRequest: Equatable, Hashable {
    public static func ==(lhs: ExternalSignFrostRequest, rhs: ExternalSignFrostRequest) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.verifyingKey != rhs.verifyingKey {
            return false
        }
        if lhs.selfNonceCommitment != rhs.selfNonceCommitment {
            return false
        }
        if lhs.statechainCommitments != rhs.statechainCommitments {
            return false
        }
        if lhs.adaptorPublicKey != rhs.adaptorPublicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(publicKey)
        hasher.combine(secret)
        hasher.combine(verifyingKey)
        hasher.combine(selfNonceCommitment)
        hasher.combine(statechainCommitments)
        hasher.combine(adaptorPublicKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalSignFrostRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalSignFrostRequest {
        return
            try ExternalSignFrostRequest(
                message: FfiConverterData.read(from: &buf), 
                publicKey: FfiConverterData.read(from: &buf), 
                secret: FfiConverterTypeExternalSecretSource.read(from: &buf), 
                verifyingKey: FfiConverterData.read(from: &buf), 
                selfNonceCommitment: FfiConverterTypeExternalFrostCommitments.read(from: &buf), 
                statechainCommitments: FfiConverterSequenceTypeIdentifierCommitmentPair.read(from: &buf), 
                adaptorPublicKey: FfiConverterOptionData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalSignFrostRequest, into buf: inout [UInt8]) {
        FfiConverterData.write(value.message, into: &buf)
        FfiConverterData.write(value.publicKey, into: &buf)
        FfiConverterTypeExternalSecretSource.write(value.secret, into: &buf)
        FfiConverterData.write(value.verifyingKey, into: &buf)
        FfiConverterTypeExternalFrostCommitments.write(value.selfNonceCommitment, into: &buf)
        FfiConverterSequenceTypeIdentifierCommitmentPair.write(value.statechainCommitments, into: &buf)
        FfiConverterOptionData.write(value.adaptorPublicKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSignFrostRequest_lift(_ buf: RustBuffer) throws -> ExternalSignFrostRequest {
    return try FfiConverterTypeExternalSignFrostRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSignFrostRequest_lower(_ value: ExternalSignFrostRequest) -> RustBuffer {
    return FfiConverterTypeExternalSignFrostRequest.lower(value)
}


/**
 * FFI-safe representation of `frost_secp256k1_tr::round1::SigningCommitments`
 */
public struct ExternalSigningCommitments {
    /**
     * Serialized hiding nonce commitment
     */
    public var hiding: Data
    /**
     * Serialized binding nonce commitment
     */
    public var binding: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Serialized hiding nonce commitment
         */hiding: Data, 
        /**
         * Serialized binding nonce commitment
         */binding: Data) {
        self.hiding = hiding
        self.binding = binding
    }
}



extension ExternalSigningCommitments: Equatable, Hashable {
    public static func ==(lhs: ExternalSigningCommitments, rhs: ExternalSigningCommitments) -> Bool {
        if lhs.hiding != rhs.hiding {
            return false
        }
        if lhs.binding != rhs.binding {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hiding)
        hasher.combine(binding)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalSigningCommitments: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalSigningCommitments {
        return
            try ExternalSigningCommitments(
                hiding: FfiConverterData.read(from: &buf), 
                binding: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalSigningCommitments, into buf: inout [UInt8]) {
        FfiConverterData.write(value.hiding, into: &buf)
        FfiConverterData.write(value.binding, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSigningCommitments_lift(_ buf: RustBuffer) throws -> ExternalSigningCommitments {
    return try FfiConverterTypeExternalSigningCommitments.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSigningCommitments_lower(_ value: ExternalSigningCommitments) -> RustBuffer {
    return FfiConverterTypeExternalSigningCommitments.lower(value)
}


/**
 * FFI-safe representation of `spark_wallet::TreeNodeId`
 */
public struct ExternalTreeNodeId {
    /**
     * The tree node identifier as a string
     */
    public var id: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The tree node identifier as a string
         */id: String) {
        self.id = id
    }
}



extension ExternalTreeNodeId: Equatable, Hashable {
    public static func ==(lhs: ExternalTreeNodeId, rhs: ExternalTreeNodeId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalTreeNodeId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalTreeNodeId {
        return
            try ExternalTreeNodeId(
                id: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalTreeNodeId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalTreeNodeId_lift(_ buf: RustBuffer) throws -> ExternalTreeNodeId {
    return try FfiConverterTypeExternalTreeNodeId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalTreeNodeId_lower(_ value: ExternalTreeNodeId) -> RustBuffer {
    return FfiConverterTypeExternalTreeNodeId.lower(value)
}


/**
 * FFI-safe representation of `spark_wallet::VerifiableSecretShare`
 */
public struct ExternalVerifiableSecretShare {
    /**
     * Base secret share containing threshold, index, and share value
     */
    public var secretShare: ExternalSecretShare
    /**
     * Cryptographic proofs for share verification (each proof is 33 bytes compressed public key)
     */
    public var proofs: [Data]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Base secret share containing threshold, index, and share value
         */secretShare: ExternalSecretShare, 
        /**
         * Cryptographic proofs for share verification (each proof is 33 bytes compressed public key)
         */proofs: [Data]) {
        self.secretShare = secretShare
        self.proofs = proofs
    }
}



extension ExternalVerifiableSecretShare: Equatable, Hashable {
    public static func ==(lhs: ExternalVerifiableSecretShare, rhs: ExternalVerifiableSecretShare) -> Bool {
        if lhs.secretShare != rhs.secretShare {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretShare)
        hasher.combine(proofs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalVerifiableSecretShare: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalVerifiableSecretShare {
        return
            try ExternalVerifiableSecretShare(
                secretShare: FfiConverterTypeExternalSecretShare.read(from: &buf), 
                proofs: FfiConverterSequenceData.read(from: &buf)
        )
    }

    public static func write(_ value: ExternalVerifiableSecretShare, into buf: inout [UInt8]) {
        FfiConverterTypeExternalSecretShare.write(value.secretShare, into: &buf)
        FfiConverterSequenceData.write(value.proofs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalVerifiableSecretShare_lift(_ buf: RustBuffer) throws -> ExternalVerifiableSecretShare {
    return try FfiConverterTypeExternalVerifiableSecretShare.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalVerifiableSecretShare_lower(_ value: ExternalVerifiableSecretShare) -> RustBuffer {
    return FfiConverterTypeExternalVerifiableSecretShare.lower(value)
}


public struct FetchConversionLimitsRequest {
    /**
     * The type of conversion, either from or to Bitcoin.
     */
    public var conversionType: ConversionType
    /**
     * The token identifier when converting to a token.
     */
    public var tokenIdentifier: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The type of conversion, either from or to Bitcoin.
         */conversionType: ConversionType, 
        /**
         * The token identifier when converting to a token.
         */tokenIdentifier: String? = nil) {
        self.conversionType = conversionType
        self.tokenIdentifier = tokenIdentifier
    }
}



extension FetchConversionLimitsRequest: Equatable, Hashable {
    public static func ==(lhs: FetchConversionLimitsRequest, rhs: FetchConversionLimitsRequest) -> Bool {
        if lhs.conversionType != rhs.conversionType {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(conversionType)
        hasher.combine(tokenIdentifier)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFetchConversionLimitsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FetchConversionLimitsRequest {
        return
            try FetchConversionLimitsRequest(
                conversionType: FfiConverterTypeConversionType.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FetchConversionLimitsRequest, into buf: inout [UInt8]) {
        FfiConverterTypeConversionType.write(value.conversionType, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFetchConversionLimitsRequest_lift(_ buf: RustBuffer) throws -> FetchConversionLimitsRequest {
    return try FfiConverterTypeFetchConversionLimitsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFetchConversionLimitsRequest_lower(_ value: FetchConversionLimitsRequest) -> RustBuffer {
    return FfiConverterTypeFetchConversionLimitsRequest.lower(value)
}


public struct FetchConversionLimitsResponse {
    /**
     * The minimum amount to be converted.
     * Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
     */
    public var minFromAmount: U128?
    /**
     * The minimum amount to be received from the conversion.
     * Denominated in satoshis if converting to Bitcoin, otherwise in the token base units.
     */
    public var minToAmount: U128?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The minimum amount to be converted.
         * Denominated in satoshis if converting from Bitcoin, otherwise in the token base units.
         */minFromAmount: U128?, 
        /**
         * The minimum amount to be received from the conversion.
         * Denominated in satoshis if converting to Bitcoin, otherwise in the token base units.
         */minToAmount: U128?) {
        self.minFromAmount = minFromAmount
        self.minToAmount = minToAmount
    }
}



extension FetchConversionLimitsResponse: Equatable, Hashable {
    public static func ==(lhs: FetchConversionLimitsResponse, rhs: FetchConversionLimitsResponse) -> Bool {
        if lhs.minFromAmount != rhs.minFromAmount {
            return false
        }
        if lhs.minToAmount != rhs.minToAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minFromAmount)
        hasher.combine(minToAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFetchConversionLimitsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FetchConversionLimitsResponse {
        return
            try FetchConversionLimitsResponse(
                minFromAmount: FfiConverterOptionTypeu128.read(from: &buf), 
                minToAmount: FfiConverterOptionTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: FetchConversionLimitsResponse, into buf: inout [UInt8]) {
        FfiConverterOptionTypeu128.write(value.minFromAmount, into: &buf)
        FfiConverterOptionTypeu128.write(value.minToAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFetchConversionLimitsResponse_lift(_ buf: RustBuffer) throws -> FetchConversionLimitsResponse {
    return try FfiConverterTypeFetchConversionLimitsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFetchConversionLimitsResponse_lower(_ value: FetchConversionLimitsResponse) -> RustBuffer {
    return FfiConverterTypeFetchConversionLimitsResponse.lower(value)
}


/**
 * Wrapper around the [`CurrencyInfo`] of a fiat currency
 */
public struct FiatCurrency {
    public var id: String
    public var info: CurrencyInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, info: CurrencyInfo) {
        self.id = id
        self.info = info
    }
}



extension FiatCurrency: Equatable, Hashable {
    public static func ==(lhs: FiatCurrency, rhs: FiatCurrency) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.info != rhs.info {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(info)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        return
            try FiatCurrency(
                id: FfiConverterString.read(from: &buf), 
                info: FfiConverterTypeCurrencyInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeCurrencyInfo.write(value.info, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}


public struct FreezeIssuerTokenRequest {
    public var address: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String) {
        self.address = address
    }
}



extension FreezeIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: FreezeIssuerTokenRequest, rhs: FreezeIssuerTokenRequest) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFreezeIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FreezeIssuerTokenRequest {
        return
            try FreezeIssuerTokenRequest(
                address: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FreezeIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFreezeIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> FreezeIssuerTokenRequest {
    return try FfiConverterTypeFreezeIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFreezeIssuerTokenRequest_lower(_ value: FreezeIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeFreezeIssuerTokenRequest.lower(value)
}


public struct FreezeIssuerTokenResponse {
    public var impactedOutputIds: [String]
    public var impactedTokenAmount: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(impactedOutputIds: [String], impactedTokenAmount: U128) {
        self.impactedOutputIds = impactedOutputIds
        self.impactedTokenAmount = impactedTokenAmount
    }
}



extension FreezeIssuerTokenResponse: Equatable, Hashable {
    public static func ==(lhs: FreezeIssuerTokenResponse, rhs: FreezeIssuerTokenResponse) -> Bool {
        if lhs.impactedOutputIds != rhs.impactedOutputIds {
            return false
        }
        if lhs.impactedTokenAmount != rhs.impactedTokenAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(impactedOutputIds)
        hasher.combine(impactedTokenAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFreezeIssuerTokenResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FreezeIssuerTokenResponse {
        return
            try FreezeIssuerTokenResponse(
                impactedOutputIds: FfiConverterSequenceString.read(from: &buf), 
                impactedTokenAmount: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: FreezeIssuerTokenResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.impactedOutputIds, into: &buf)
        FfiConverterTypeu128.write(value.impactedTokenAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFreezeIssuerTokenResponse_lift(_ buf: RustBuffer) throws -> FreezeIssuerTokenResponse {
    return try FfiConverterTypeFreezeIssuerTokenResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFreezeIssuerTokenResponse_lower(_ value: FreezeIssuerTokenResponse) -> RustBuffer {
    return FfiConverterTypeFreezeIssuerTokenResponse.lower(value)
}


/**
 * Request to get the balance of the wallet
 */
public struct GetInfoRequest {
    public var ensureSynced: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ensureSynced: Bool?) {
        self.ensureSynced = ensureSynced
    }
}



extension GetInfoRequest: Equatable, Hashable {
    public static func ==(lhs: GetInfoRequest, rhs: GetInfoRequest) -> Bool {
        if lhs.ensureSynced != rhs.ensureSynced {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ensureSynced)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoRequest {
        return
            try GetInfoRequest(
                ensureSynced: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoRequest, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.ensureSynced, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoRequest_lift(_ buf: RustBuffer) throws -> GetInfoRequest {
    return try FfiConverterTypeGetInfoRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoRequest_lower(_ value: GetInfoRequest) -> RustBuffer {
    return FfiConverterTypeGetInfoRequest.lower(value)
}


/**
 * Response containing the balance of the wallet
 */
public struct GetInfoResponse {
    /**
     * The identity public key of the wallet as a hex string
     */
    public var identityPubkey: String
    /**
     * The balance in satoshis
     */
    public var balanceSats: UInt64
    /**
     * The balances of the tokens in the wallet keyed by the token identifier
     */
    public var tokenBalances: [String: TokenBalance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The identity public key of the wallet as a hex string
         */identityPubkey: String, 
        /**
         * The balance in satoshis
         */balanceSats: UInt64, 
        /**
         * The balances of the tokens in the wallet keyed by the token identifier
         */tokenBalances: [String: TokenBalance]) {
        self.identityPubkey = identityPubkey
        self.balanceSats = balanceSats
        self.tokenBalances = tokenBalances
    }
}



extension GetInfoResponse: Equatable, Hashable {
    public static func ==(lhs: GetInfoResponse, rhs: GetInfoResponse) -> Bool {
        if lhs.identityPubkey != rhs.identityPubkey {
            return false
        }
        if lhs.balanceSats != rhs.balanceSats {
            return false
        }
        if lhs.tokenBalances != rhs.tokenBalances {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityPubkey)
        hasher.combine(balanceSats)
        hasher.combine(tokenBalances)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetInfoResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetInfoResponse {
        return
            try GetInfoResponse(
                identityPubkey: FfiConverterString.read(from: &buf), 
                balanceSats: FfiConverterUInt64.read(from: &buf), 
                tokenBalances: FfiConverterDictionaryStringTypeTokenBalance.read(from: &buf)
        )
    }

    public static func write(_ value: GetInfoResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identityPubkey, into: &buf)
        FfiConverterUInt64.write(value.balanceSats, into: &buf)
        FfiConverterDictionaryStringTypeTokenBalance.write(value.tokenBalances, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lift(_ buf: RustBuffer) throws -> GetInfoResponse {
    return try FfiConverterTypeGetInfoResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetInfoResponse_lower(_ value: GetInfoResponse) -> RustBuffer {
    return FfiConverterTypeGetInfoResponse.lower(value)
}


public struct GetPaymentRequest {
    public var paymentId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentId: String) {
        self.paymentId = paymentId
    }
}



extension GetPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: GetPaymentRequest, rhs: GetPaymentRequest) -> Bool {
        if lhs.paymentId != rhs.paymentId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPaymentRequest {
        return
            try GetPaymentRequest(
                paymentId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GetPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentRequest_lift(_ buf: RustBuffer) throws -> GetPaymentRequest {
    return try FfiConverterTypeGetPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentRequest_lower(_ value: GetPaymentRequest) -> RustBuffer {
    return FfiConverterTypeGetPaymentRequest.lower(value)
}


public struct GetPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension GetPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: GetPaymentResponse, rhs: GetPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetPaymentResponse {
        return
            try GetPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: GetPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentResponse_lift(_ buf: RustBuffer) throws -> GetPaymentResponse {
    return try FfiConverterTypeGetPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetPaymentResponse_lower(_ value: GetPaymentResponse) -> RustBuffer {
    return FfiConverterTypeGetPaymentResponse.lower(value)
}


public struct GetTokensMetadataRequest {
    public var tokenIdentifiers: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokenIdentifiers: [String]) {
        self.tokenIdentifiers = tokenIdentifiers
    }
}



extension GetTokensMetadataRequest: Equatable, Hashable {
    public static func ==(lhs: GetTokensMetadataRequest, rhs: GetTokensMetadataRequest) -> Bool {
        if lhs.tokenIdentifiers != rhs.tokenIdentifiers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokenIdentifiers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetTokensMetadataRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetTokensMetadataRequest {
        return
            try GetTokensMetadataRequest(
                tokenIdentifiers: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GetTokensMetadataRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.tokenIdentifiers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataRequest_lift(_ buf: RustBuffer) throws -> GetTokensMetadataRequest {
    return try FfiConverterTypeGetTokensMetadataRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataRequest_lower(_ value: GetTokensMetadataRequest) -> RustBuffer {
    return FfiConverterTypeGetTokensMetadataRequest.lower(value)
}


public struct GetTokensMetadataResponse {
    public var tokensMetadata: [TokenMetadata]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tokensMetadata: [TokenMetadata]) {
        self.tokensMetadata = tokensMetadata
    }
}



extension GetTokensMetadataResponse: Equatable, Hashable {
    public static func ==(lhs: GetTokensMetadataResponse, rhs: GetTokensMetadataResponse) -> Bool {
        if lhs.tokensMetadata != rhs.tokensMetadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokensMetadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGetTokensMetadataResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetTokensMetadataResponse {
        return
            try GetTokensMetadataResponse(
                tokensMetadata: FfiConverterSequenceTypeTokenMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: GetTokensMetadataResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeTokenMetadata.write(value.tokensMetadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataResponse_lift(_ buf: RustBuffer) throws -> GetTokensMetadataResponse {
    return try FfiConverterTypeGetTokensMetadataResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGetTokensMetadataResponse_lower(_ value: GetTokensMetadataResponse) -> RustBuffer {
    return FfiConverterTypeGetTokensMetadataResponse.lower(value)
}


public struct HashedMessageBytes {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}



extension HashedMessageBytes: Equatable, Hashable {
    public static func ==(lhs: HashedMessageBytes, rhs: HashedMessageBytes) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHashedMessageBytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HashedMessageBytes {
        return
            try HashedMessageBytes(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: HashedMessageBytes, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHashedMessageBytes_lift(_ buf: RustBuffer) throws -> HashedMessageBytes {
    return try FfiConverterTypeHashedMessageBytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHashedMessageBytes_lower(_ value: HashedMessageBytes) -> RustBuffer {
    return FfiConverterTypeHashedMessageBytes.lower(value)
}


/**
 * FFI-safe wrapper for (Identifier, `SigningCommitments`) pair
 */
public struct IdentifierCommitmentPair {
    public var identifier: ExternalIdentifier
    public var commitment: ExternalSigningCommitments

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ExternalIdentifier, commitment: ExternalSigningCommitments) {
        self.identifier = identifier
        self.commitment = commitment
    }
}



extension IdentifierCommitmentPair: Equatable, Hashable {
    public static func ==(lhs: IdentifierCommitmentPair, rhs: IdentifierCommitmentPair) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.commitment != rhs.commitment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(commitment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentifierCommitmentPair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentifierCommitmentPair {
        return
            try IdentifierCommitmentPair(
                identifier: FfiConverterTypeExternalIdentifier.read(from: &buf), 
                commitment: FfiConverterTypeExternalSigningCommitments.read(from: &buf)
        )
    }

    public static func write(_ value: IdentifierCommitmentPair, into buf: inout [UInt8]) {
        FfiConverterTypeExternalIdentifier.write(value.identifier, into: &buf)
        FfiConverterTypeExternalSigningCommitments.write(value.commitment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierCommitmentPair_lift(_ buf: RustBuffer) throws -> IdentifierCommitmentPair {
    return try FfiConverterTypeIdentifierCommitmentPair.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierCommitmentPair_lower(_ value: IdentifierCommitmentPair) -> RustBuffer {
    return FfiConverterTypeIdentifierCommitmentPair.lower(value)
}


/**
 * FFI-safe wrapper for (Identifier, `PublicKey`) pair
 */
public struct IdentifierPublicKeyPair {
    public var identifier: ExternalIdentifier
    public var publicKey: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ExternalIdentifier, publicKey: Data) {
        self.identifier = identifier
        self.publicKey = publicKey
    }
}



extension IdentifierPublicKeyPair: Equatable, Hashable {
    public static func ==(lhs: IdentifierPublicKeyPair, rhs: IdentifierPublicKeyPair) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(publicKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentifierPublicKeyPair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentifierPublicKeyPair {
        return
            try IdentifierPublicKeyPair(
                identifier: FfiConverterTypeExternalIdentifier.read(from: &buf), 
                publicKey: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: IdentifierPublicKeyPair, into buf: inout [UInt8]) {
        FfiConverterTypeExternalIdentifier.write(value.identifier, into: &buf)
        FfiConverterData.write(value.publicKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierPublicKeyPair_lift(_ buf: RustBuffer) throws -> IdentifierPublicKeyPair {
    return try FfiConverterTypeIdentifierPublicKeyPair.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierPublicKeyPair_lower(_ value: IdentifierPublicKeyPair) -> RustBuffer {
    return FfiConverterTypeIdentifierPublicKeyPair.lower(value)
}


/**
 * FFI-safe wrapper for (Identifier, `SignatureShare`) pair
 */
public struct IdentifierSignaturePair {
    public var identifier: ExternalIdentifier
    public var signature: ExternalFrostSignatureShare

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ExternalIdentifier, signature: ExternalFrostSignatureShare) {
        self.identifier = identifier
        self.signature = signature
    }
}



extension IdentifierSignaturePair: Equatable, Hashable {
    public static func ==(lhs: IdentifierSignaturePair, rhs: IdentifierSignaturePair) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentifierSignaturePair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentifierSignaturePair {
        return
            try IdentifierSignaturePair(
                identifier: FfiConverterTypeExternalIdentifier.read(from: &buf), 
                signature: FfiConverterTypeExternalFrostSignatureShare.read(from: &buf)
        )
    }

    public static func write(_ value: IdentifierSignaturePair, into buf: inout [UInt8]) {
        FfiConverterTypeExternalIdentifier.write(value.identifier, into: &buf)
        FfiConverterTypeExternalFrostSignatureShare.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierSignaturePair_lift(_ buf: RustBuffer) throws -> IdentifierSignaturePair {
    return try FfiConverterTypeIdentifierSignaturePair.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentifierSignaturePair_lower(_ value: IdentifierSignaturePair) -> RustBuffer {
    return FfiConverterTypeIdentifierSignaturePair.lower(value)
}


public struct IncomingChange {
    public var newState: Record
    public var oldState: Record?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(newState: Record, oldState: Record?) {
        self.newState = newState
        self.oldState = oldState
    }
}



extension IncomingChange: Equatable, Hashable {
    public static func ==(lhs: IncomingChange, rhs: IncomingChange) -> Bool {
        if lhs.newState != rhs.newState {
            return false
        }
        if lhs.oldState != rhs.oldState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(newState)
        hasher.combine(oldState)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIncomingChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IncomingChange {
        return
            try IncomingChange(
                newState: FfiConverterTypeRecord.read(from: &buf), 
                oldState: FfiConverterOptionTypeRecord.read(from: &buf)
        )
    }

    public static func write(_ value: IncomingChange, into buf: inout [UInt8]) {
        FfiConverterTypeRecord.write(value.newState, into: &buf)
        FfiConverterOptionTypeRecord.write(value.oldState, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIncomingChange_lift(_ buf: RustBuffer) throws -> IncomingChange {
    return try FfiConverterTypeIncomingChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIncomingChange_lower(_ value: IncomingChange) -> RustBuffer {
    return FfiConverterTypeIncomingChange.lower(value)
}


/**
 * Configuration for key set derivation.
 *
 * This struct encapsulates the parameters needed for BIP32 key derivation.
 */
public struct KeySetConfig {
    /**
     * The key set type which determines the derivation path
     */
    public var keySetType: KeySetType
    /**
     * Controls the structure of the BIP derivation path
     */
    public var useAddressIndex: Bool
    /**
     * Optional account number for key derivation
     */
    public var accountNumber: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The key set type which determines the derivation path
         */keySetType: KeySetType, 
        /**
         * Controls the structure of the BIP derivation path
         */useAddressIndex: Bool, 
        /**
         * Optional account number for key derivation
         */accountNumber: UInt32?) {
        self.keySetType = keySetType
        self.useAddressIndex = useAddressIndex
        self.accountNumber = accountNumber
    }
}



extension KeySetConfig: Equatable, Hashable {
    public static func ==(lhs: KeySetConfig, rhs: KeySetConfig) -> Bool {
        if lhs.keySetType != rhs.keySetType {
            return false
        }
        if lhs.useAddressIndex != rhs.useAddressIndex {
            return false
        }
        if lhs.accountNumber != rhs.accountNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keySetType)
        hasher.combine(useAddressIndex)
        hasher.combine(accountNumber)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeySetConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySetConfig {
        return
            try KeySetConfig(
                keySetType: FfiConverterTypeKeySetType.read(from: &buf), 
                useAddressIndex: FfiConverterBool.read(from: &buf), 
                accountNumber: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: KeySetConfig, into buf: inout [UInt8]) {
        FfiConverterTypeKeySetType.write(value.keySetType, into: &buf)
        FfiConverterBool.write(value.useAddressIndex, into: &buf)
        FfiConverterOptionUInt32.write(value.accountNumber, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySetConfig_lift(_ buf: RustBuffer) throws -> KeySetConfig {
    return try FfiConverterTypeKeySetConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySetConfig_lower(_ value: KeySetConfig) -> RustBuffer {
    return FfiConverterTypeKeySetConfig.lower(value)
}


public struct LightningAddressDetails {
    public var address: String
    public var payRequest: LnurlPayRequestDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, payRequest: LnurlPayRequestDetails) {
        self.address = address
        self.payRequest = payRequest
    }
}



extension LightningAddressDetails: Equatable, Hashable {
    public static func ==(lhs: LightningAddressDetails, rhs: LightningAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(payRequest)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningAddressDetails {
        return
            try LightningAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf)
        )
    }

    public static func write(_ value: LightningAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressDetails_lift(_ buf: RustBuffer) throws -> LightningAddressDetails {
    return try FfiConverterTypeLightningAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressDetails_lower(_ value: LightningAddressDetails) -> RustBuffer {
    return FfiConverterTypeLightningAddressDetails.lower(value)
}


public struct LightningAddressInfo {
    public var description: String
    public var lightningAddress: String
    public var lnurl: LnurlInfo
    public var username: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String, lightningAddress: String, lnurl: LnurlInfo, username: String) {
        self.description = description
        self.lightningAddress = lightningAddress
        self.lnurl = lnurl
        self.username = username
    }
}



extension LightningAddressInfo: Equatable, Hashable {
    public static func ==(lhs: LightningAddressInfo, rhs: LightningAddressInfo) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.lightningAddress != rhs.lightningAddress {
            return false
        }
        if lhs.lnurl != rhs.lnurl {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(lightningAddress)
        hasher.combine(lnurl)
        hasher.combine(username)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningAddressInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningAddressInfo {
        return
            try LightningAddressInfo(
                description: FfiConverterString.read(from: &buf), 
                lightningAddress: FfiConverterString.read(from: &buf), 
                lnurl: FfiConverterTypeLnurlInfo.read(from: &buf), 
                username: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LightningAddressInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.lightningAddress, into: &buf)
        FfiConverterTypeLnurlInfo.write(value.lnurl, into: &buf)
        FfiConverterString.write(value.username, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressInfo_lift(_ buf: RustBuffer) throws -> LightningAddressInfo {
    return try FfiConverterTypeLightningAddressInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningAddressInfo_lower(_ value: LightningAddressInfo) -> RustBuffer {
    return FfiConverterTypeLightningAddressInfo.lower(value)
}


/**
 * Response from listing fiat currencies
 */
public struct ListFiatCurrenciesResponse {
    /**
     * The list of fiat currencies
     */
    public var currencies: [FiatCurrency]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of fiat currencies
         */currencies: [FiatCurrency]) {
        self.currencies = currencies
    }
}



extension ListFiatCurrenciesResponse: Equatable, Hashable {
    public static func ==(lhs: ListFiatCurrenciesResponse, rhs: ListFiatCurrenciesResponse) -> Bool {
        if lhs.currencies != rhs.currencies {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currencies)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListFiatCurrenciesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListFiatCurrenciesResponse {
        return
            try ListFiatCurrenciesResponse(
                currencies: FfiConverterSequenceTypeFiatCurrency.read(from: &buf)
        )
    }

    public static func write(_ value: ListFiatCurrenciesResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFiatCurrency.write(value.currencies, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatCurrenciesResponse_lift(_ buf: RustBuffer) throws -> ListFiatCurrenciesResponse {
    return try FfiConverterTypeListFiatCurrenciesResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatCurrenciesResponse_lower(_ value: ListFiatCurrenciesResponse) -> RustBuffer {
    return FfiConverterTypeListFiatCurrenciesResponse.lower(value)
}


/**
 * Response from listing fiat rates
 */
public struct ListFiatRatesResponse {
    /**
     * The list of fiat rates
     */
    public var rates: [Rate]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of fiat rates
         */rates: [Rate]) {
        self.rates = rates
    }
}



extension ListFiatRatesResponse: Equatable, Hashable {
    public static func ==(lhs: ListFiatRatesResponse, rhs: ListFiatRatesResponse) -> Bool {
        if lhs.rates != rhs.rates {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rates)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListFiatRatesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListFiatRatesResponse {
        return
            try ListFiatRatesResponse(
                rates: FfiConverterSequenceTypeRate.read(from: &buf)
        )
    }

    public static func write(_ value: ListFiatRatesResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRate.write(value.rates, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatRatesResponse_lift(_ buf: RustBuffer) throws -> ListFiatRatesResponse {
    return try FfiConverterTypeListFiatRatesResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListFiatRatesResponse_lower(_ value: ListFiatRatesResponse) -> RustBuffer {
    return FfiConverterTypeListFiatRatesResponse.lower(value)
}


/**
 * Request to list payments with optional filters and pagination
 */
public struct ListPaymentsRequest {
    public var typeFilter: [PaymentType]?
    public var statusFilter: [PaymentStatus]?
    public var assetFilter: AssetFilter?
    /**
     * Only include payments matching at least one of these payment details filters
     */
    public var paymentDetailsFilter: [PaymentDetailsFilter]?
    /**
     * Only include payments created after this timestamp (inclusive)
     */
    public var fromTimestamp: UInt64?
    /**
     * Only include payments created before this timestamp (exclusive)
     */
    public var toTimestamp: UInt64?
    /**
     * Number of records to skip
     */
    public var offset: UInt32?
    /**
     * Maximum number of records to return
     */
    public var limit: UInt32?
    public var sortAscending: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typeFilter: [PaymentType]? = nil, statusFilter: [PaymentStatus]? = nil, assetFilter: AssetFilter? = nil, 
        /**
         * Only include payments matching at least one of these payment details filters
         */paymentDetailsFilter: [PaymentDetailsFilter]? = nil, 
        /**
         * Only include payments created after this timestamp (inclusive)
         */fromTimestamp: UInt64? = nil, 
        /**
         * Only include payments created before this timestamp (exclusive)
         */toTimestamp: UInt64? = nil, 
        /**
         * Number of records to skip
         */offset: UInt32? = nil, 
        /**
         * Maximum number of records to return
         */limit: UInt32? = nil, sortAscending: Bool? = nil) {
        self.typeFilter = typeFilter
        self.statusFilter = statusFilter
        self.assetFilter = assetFilter
        self.paymentDetailsFilter = paymentDetailsFilter
        self.fromTimestamp = fromTimestamp
        self.toTimestamp = toTimestamp
        self.offset = offset
        self.limit = limit
        self.sortAscending = sortAscending
    }
}



extension ListPaymentsRequest: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsRequest, rhs: ListPaymentsRequest) -> Bool {
        if lhs.typeFilter != rhs.typeFilter {
            return false
        }
        if lhs.statusFilter != rhs.statusFilter {
            return false
        }
        if lhs.assetFilter != rhs.assetFilter {
            return false
        }
        if lhs.paymentDetailsFilter != rhs.paymentDetailsFilter {
            return false
        }
        if lhs.fromTimestamp != rhs.fromTimestamp {
            return false
        }
        if lhs.toTimestamp != rhs.toTimestamp {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.sortAscending != rhs.sortAscending {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typeFilter)
        hasher.combine(statusFilter)
        hasher.combine(assetFilter)
        hasher.combine(paymentDetailsFilter)
        hasher.combine(fromTimestamp)
        hasher.combine(toTimestamp)
        hasher.combine(offset)
        hasher.combine(limit)
        hasher.combine(sortAscending)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListPaymentsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsRequest {
        return
            try ListPaymentsRequest(
                typeFilter: FfiConverterOptionSequenceTypePaymentType.read(from: &buf), 
                statusFilter: FfiConverterOptionSequenceTypePaymentStatus.read(from: &buf), 
                assetFilter: FfiConverterOptionTypeAssetFilter.read(from: &buf), 
                paymentDetailsFilter: FfiConverterOptionSequenceTypePaymentDetailsFilter.read(from: &buf), 
                fromTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                toTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                offset: FfiConverterOptionUInt32.read(from: &buf), 
                limit: FfiConverterOptionUInt32.read(from: &buf), 
                sortAscending: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsRequest, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypePaymentType.write(value.typeFilter, into: &buf)
        FfiConverterOptionSequenceTypePaymentStatus.write(value.statusFilter, into: &buf)
        FfiConverterOptionTypeAssetFilter.write(value.assetFilter, into: &buf)
        FfiConverterOptionSequenceTypePaymentDetailsFilter.write(value.paymentDetailsFilter, into: &buf)
        FfiConverterOptionUInt64.write(value.fromTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.toTimestamp, into: &buf)
        FfiConverterOptionUInt32.write(value.offset, into: &buf)
        FfiConverterOptionUInt32.write(value.limit, into: &buf)
        FfiConverterOptionBool.write(value.sortAscending, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsRequest_lift(_ buf: RustBuffer) throws -> ListPaymentsRequest {
    return try FfiConverterTypeListPaymentsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsRequest_lower(_ value: ListPaymentsRequest) -> RustBuffer {
    return FfiConverterTypeListPaymentsRequest.lower(value)
}


/**
 * Response from listing payments
 */
public struct ListPaymentsResponse {
    /**
     * The list of payments
     */
    public var payments: [Payment]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The list of payments
         */payments: [Payment]) {
        self.payments = payments
    }
}



extension ListPaymentsResponse: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsResponse, rhs: ListPaymentsResponse) -> Bool {
        if lhs.payments != rhs.payments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payments)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListPaymentsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsResponse {
        return
            try ListPaymentsResponse(
                payments: FfiConverterSequenceTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePayment.write(value.payments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsResponse_lift(_ buf: RustBuffer) throws -> ListPaymentsResponse {
    return try FfiConverterTypeListPaymentsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListPaymentsResponse_lower(_ value: ListPaymentsResponse) -> RustBuffer {
    return FfiConverterTypeListPaymentsResponse.lower(value)
}


public struct ListUnclaimedDepositsRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension ListUnclaimedDepositsRequest: Equatable, Hashable {
    public static func ==(lhs: ListUnclaimedDepositsRequest, rhs: ListUnclaimedDepositsRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUnclaimedDepositsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUnclaimedDepositsRequest {
        return
            ListUnclaimedDepositsRequest()
    }

    public static func write(_ value: ListUnclaimedDepositsRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsRequest_lift(_ buf: RustBuffer) throws -> ListUnclaimedDepositsRequest {
    return try FfiConverterTypeListUnclaimedDepositsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsRequest_lower(_ value: ListUnclaimedDepositsRequest) -> RustBuffer {
    return FfiConverterTypeListUnclaimedDepositsRequest.lower(value)
}


public struct ListUnclaimedDepositsResponse {
    public var deposits: [DepositInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deposits: [DepositInfo]) {
        self.deposits = deposits
    }
}



extension ListUnclaimedDepositsResponse: Equatable, Hashable {
    public static func ==(lhs: ListUnclaimedDepositsResponse, rhs: ListUnclaimedDepositsResponse) -> Bool {
        if lhs.deposits != rhs.deposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deposits)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListUnclaimedDepositsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUnclaimedDepositsResponse {
        return
            try ListUnclaimedDepositsResponse(
                deposits: FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ListUnclaimedDepositsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeDepositInfo.write(value.deposits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsResponse_lift(_ buf: RustBuffer) throws -> ListUnclaimedDepositsResponse {
    return try FfiConverterTypeListUnclaimedDepositsResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListUnclaimedDepositsResponse_lower(_ value: ListUnclaimedDepositsResponse) -> RustBuffer {
    return FfiConverterTypeListUnclaimedDepositsResponse.lower(value)
}


/**
 * Wrapped in a [`InputType::LnurlAuth`], this is the result of [`parse`](breez_sdk_common::input::parse) when given a LNURL-auth endpoint.
 *
 * It represents the endpoint's parameters for the LNURL workflow.
 *
 * See <https://github.com/lnurl/luds/blob/luds/04.md>
 */
public struct LnurlAuthRequestDetails {
    /**
     * Hex encoded 32 bytes of challenge
     */
    public var k1: String
    /**
     * When available, one of: register, login, link, auth
     */
    public var action: String?
    /**
     * Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
     * auth confirmation, as per LUD-04 spec.
     */
    public var domain: String
    /**
     * Indicates the URL of the LNURL-auth service, including the query arguments. This will be
     * extended with the signed challenge and the linking key, then called in the second step of the workflow.
     */
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex encoded 32 bytes of challenge
         */k1: String, 
        /**
         * When available, one of: register, login, link, auth
         */action: String?, 
        /**
         * Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
         * auth confirmation, as per LUD-04 spec.
         */domain: String, 
        /**
         * Indicates the URL of the LNURL-auth service, including the query arguments. This will be
         * extended with the signed challenge and the linking key, then called in the second step of the workflow.
         */url: String) {
        self.k1 = k1
        self.action = action
        self.domain = domain
        self.url = url
    }
}



extension LnurlAuthRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlAuthRequestDetails, rhs: LnurlAuthRequestDetails) -> Bool {
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(k1)
        hasher.combine(action)
        hasher.combine(domain)
        hasher.combine(url)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlAuthRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlAuthRequestDetails {
        return
            try LnurlAuthRequestDetails(
                k1: FfiConverterString.read(from: &buf), 
                action: FfiConverterOptionString.read(from: &buf), 
                domain: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlAuthRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterOptionString.write(value.action, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlAuthRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlAuthRequestDetails {
    return try FfiConverterTypeLnurlAuthRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlAuthRequestDetails_lower(_ value: LnurlAuthRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlAuthRequestDetails.lower(value)
}


/**
 * LNURL error details
 */
public struct LnurlErrorDetails {
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(reason: String) {
        self.reason = reason
    }
}



extension LnurlErrorDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlErrorDetails, rhs: LnurlErrorDetails) -> Bool {
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reason)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlErrorDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlErrorDetails {
        return
            try LnurlErrorDetails(
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlErrorDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlErrorDetails_lift(_ buf: RustBuffer) throws -> LnurlErrorDetails {
    return try FfiConverterTypeLnurlErrorDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlErrorDetails_lower(_ value: LnurlErrorDetails) -> RustBuffer {
    return FfiConverterTypeLnurlErrorDetails.lower(value)
}


public struct LnurlInfo {
    public var url: String
    public var bech32: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, bech32: String) {
        self.url = url
        self.bech32 = bech32
    }
}



extension LnurlInfo: Equatable, Hashable {
    public static func ==(lhs: LnurlInfo, rhs: LnurlInfo) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.bech32 != rhs.bech32 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(bech32)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlInfo {
        return
            try LnurlInfo(
                url: FfiConverterString.read(from: &buf), 
                bech32: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.bech32, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlInfo_lift(_ buf: RustBuffer) throws -> LnurlInfo {
    return try FfiConverterTypeLnurlInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlInfo_lower(_ value: LnurlInfo) -> RustBuffer {
    return FfiConverterTypeLnurlInfo.lower(value)
}


/**
 * Represents the payment LNURL info
 */
public struct LnurlPayInfo {
    public var lnAddress: String?
    public var comment: String?
    public var domain: String?
    public var metadata: String?
    public var processedSuccessAction: SuccessActionProcessed?
    public var rawSuccessAction: SuccessAction?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lnAddress: String?, comment: String?, domain: String?, metadata: String?, processedSuccessAction: SuccessActionProcessed?, rawSuccessAction: SuccessAction?) {
        self.lnAddress = lnAddress
        self.comment = comment
        self.domain = domain
        self.metadata = metadata
        self.processedSuccessAction = processedSuccessAction
        self.rawSuccessAction = rawSuccessAction
    }
}



extension LnurlPayInfo: Equatable, Hashable {
    public static func ==(lhs: LnurlPayInfo, rhs: LnurlPayInfo) -> Bool {
        if lhs.lnAddress != rhs.lnAddress {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.processedSuccessAction != rhs.processedSuccessAction {
            return false
        }
        if lhs.rawSuccessAction != rhs.rawSuccessAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lnAddress)
        hasher.combine(comment)
        hasher.combine(domain)
        hasher.combine(metadata)
        hasher.combine(processedSuccessAction)
        hasher.combine(rawSuccessAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayInfo {
        return
            try LnurlPayInfo(
                lnAddress: FfiConverterOptionString.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                domain: FfiConverterOptionString.read(from: &buf), 
                metadata: FfiConverterOptionString.read(from: &buf), 
                processedSuccessAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf), 
                rawSuccessAction: FfiConverterOptionTypeSuccessAction.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.lnAddress, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterOptionString.write(value.domain, into: &buf)
        FfiConverterOptionString.write(value.metadata, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.processedSuccessAction, into: &buf)
        FfiConverterOptionTypeSuccessAction.write(value.rawSuccessAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayInfo_lift(_ buf: RustBuffer) throws -> LnurlPayInfo {
    return try FfiConverterTypeLnurlPayInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayInfo_lower(_ value: LnurlPayInfo) -> RustBuffer {
    return FfiConverterTypeLnurlPayInfo.lower(value)
}


public struct LnurlPayRequest {
    public var prepareResponse: PrepareLnurlPayResponse
    /**
     * If set, providing the same idempotency key for multiple requests will ensure that only one
     * payment is made. If an idempotency key is re-used, the same payment will be returned.
     * The idempotency key must be a valid UUID.
     */
    public var idempotencyKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prepareResponse: PrepareLnurlPayResponse, 
        /**
         * If set, providing the same idempotency key for multiple requests will ensure that only one
         * payment is made. If an idempotency key is re-used, the same payment will be returned.
         * The idempotency key must be a valid UUID.
         */idempotencyKey: String? = nil) {
        self.prepareResponse = prepareResponse
        self.idempotencyKey = idempotencyKey
    }
}



extension LnurlPayRequest: Equatable, Hashable {
    public static func ==(lhs: LnurlPayRequest, rhs: LnurlPayRequest) -> Bool {
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        if lhs.idempotencyKey != rhs.idempotencyKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prepareResponse)
        hasher.combine(idempotencyKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayRequest {
        return
            try LnurlPayRequest(
                prepareResponse: FfiConverterTypePrepareLnurlPayResponse.read(from: &buf), 
                idempotencyKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayRequest, into buf: inout [UInt8]) {
        FfiConverterTypePrepareLnurlPayResponse.write(value.prepareResponse, into: &buf)
        FfiConverterOptionString.write(value.idempotencyKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequest_lift(_ buf: RustBuffer) throws -> LnurlPayRequest {
    return try FfiConverterTypeLnurlPayRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequest_lower(_ value: LnurlPayRequest) -> RustBuffer {
    return FfiConverterTypeLnurlPayRequest.lower(value)
}


public struct LnurlPayRequestDetails {
    public var callback: String
    /**
     * The minimum amount, in millisats, that this LNURL-pay endpoint accepts
     */
    public var minSendable: UInt64
    /**
     * The maximum amount, in millisats, that this LNURL-pay endpoint accepts
     */
    public var maxSendable: UInt64
    /**
     * As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
     * Use `metadata_vec()` to get the parsed items.
     */
    public var metadataStr: String
    /**
     * The comment length accepted by this endpoint
     *
     * See <https://github.com/lnurl/luds/blob/luds/12.md>
     */
    public var commentAllowed: UInt16
    /**
     * Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
     * payment input, as per LUD-06 spec.
     *
     * Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
     */
    public var domain: String
    public var url: String
    /**
     * Optional lightning address if that was used to resolve the lnurl.
     */
    public var address: String?
    /**
     * Value indicating whether the recipient supports Nostr Zaps through NIP-57.
     *
     * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
     */
    public var allowsNostr: Bool?
    /**
     * Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
     * valid BIP 340 public key in hex.
     *
     * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
     * See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
     */
    public var nostrPubkey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, 
        /**
         * The minimum amount, in millisats, that this LNURL-pay endpoint accepts
         */minSendable: UInt64, 
        /**
         * The maximum amount, in millisats, that this LNURL-pay endpoint accepts
         */maxSendable: UInt64, 
        /**
         * As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
         * Use `metadata_vec()` to get the parsed items.
         */metadataStr: String, 
        /**
         * The comment length accepted by this endpoint
         *
         * See <https://github.com/lnurl/luds/blob/luds/12.md>
         */commentAllowed: UInt16, 
        /**
         * Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
         * payment input, as per LUD-06 spec.
         *
         * Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
         */domain: String, url: String, 
        /**
         * Optional lightning address if that was used to resolve the lnurl.
         */address: String?, 
        /**
         * Value indicating whether the recipient supports Nostr Zaps through NIP-57.
         *
         * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
         */allowsNostr: Bool?, 
        /**
         * Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
         * valid BIP 340 public key in hex.
         *
         * See <https://github.com/nostr-protocol/nips/blob/master/57.md>
         * See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
         */nostrPubkey: String?) {
        self.callback = callback
        self.minSendable = minSendable
        self.maxSendable = maxSendable
        self.metadataStr = metadataStr
        self.commentAllowed = commentAllowed
        self.domain = domain
        self.url = url
        self.address = address
        self.allowsNostr = allowsNostr
        self.nostrPubkey = nostrPubkey
    }
}



extension LnurlPayRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlPayRequestDetails, rhs: LnurlPayRequestDetails) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.minSendable != rhs.minSendable {
            return false
        }
        if lhs.maxSendable != rhs.maxSendable {
            return false
        }
        if lhs.metadataStr != rhs.metadataStr {
            return false
        }
        if lhs.commentAllowed != rhs.commentAllowed {
            return false
        }
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.allowsNostr != rhs.allowsNostr {
            return false
        }
        if lhs.nostrPubkey != rhs.nostrPubkey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(minSendable)
        hasher.combine(maxSendable)
        hasher.combine(metadataStr)
        hasher.combine(commentAllowed)
        hasher.combine(domain)
        hasher.combine(url)
        hasher.combine(address)
        hasher.combine(allowsNostr)
        hasher.combine(nostrPubkey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayRequestDetails {
        return
            try LnurlPayRequestDetails(
                callback: FfiConverterString.read(from: &buf), 
                minSendable: FfiConverterUInt64.read(from: &buf), 
                maxSendable: FfiConverterUInt64.read(from: &buf), 
                metadataStr: FfiConverterString.read(from: &buf), 
                commentAllowed: FfiConverterUInt16.read(from: &buf), 
                domain: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                address: FfiConverterOptionString.read(from: &buf), 
                allowsNostr: FfiConverterOptionBool.read(from: &buf), 
                nostrPubkey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterUInt64.write(value.minSendable, into: &buf)
        FfiConverterUInt64.write(value.maxSendable, into: &buf)
        FfiConverterString.write(value.metadataStr, into: &buf)
        FfiConverterUInt16.write(value.commentAllowed, into: &buf)
        FfiConverterString.write(value.domain, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.address, into: &buf)
        FfiConverterOptionBool.write(value.allowsNostr, into: &buf)
        FfiConverterOptionString.write(value.nostrPubkey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlPayRequestDetails {
    return try FfiConverterTypeLnurlPayRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayRequestDetails_lower(_ value: LnurlPayRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlPayRequestDetails.lower(value)
}


public struct LnurlPayResponse {
    public var payment: Payment
    public var successAction: SuccessActionProcessed?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment, successAction: SuccessActionProcessed?) {
        self.payment = payment
        self.successAction = successAction
    }
}



extension LnurlPayResponse: Equatable, Hashable {
    public static func ==(lhs: LnurlPayResponse, rhs: LnurlPayResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        if lhs.successAction != rhs.successAction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
        hasher.combine(successAction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlPayResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlPayResponse {
        return
            try LnurlPayResponse(
                payment: FfiConverterTypePayment.read(from: &buf), 
                successAction: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlPayResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.successAction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayResponse_lift(_ buf: RustBuffer) throws -> LnurlPayResponse {
    return try FfiConverterTypeLnurlPayResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlPayResponse_lower(_ value: LnurlPayResponse) -> RustBuffer {
    return FfiConverterTypeLnurlPayResponse.lower(value)
}


public struct LnurlReceiveMetadata {
    public var nostrZapRequest: String?
    public var nostrZapReceipt: String?
    public var senderComment: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nostrZapRequest: String?, nostrZapReceipt: String?, senderComment: String?) {
        self.nostrZapRequest = nostrZapRequest
        self.nostrZapReceipt = nostrZapReceipt
        self.senderComment = senderComment
    }
}



extension LnurlReceiveMetadata: Equatable, Hashable {
    public static func ==(lhs: LnurlReceiveMetadata, rhs: LnurlReceiveMetadata) -> Bool {
        if lhs.nostrZapRequest != rhs.nostrZapRequest {
            return false
        }
        if lhs.nostrZapReceipt != rhs.nostrZapReceipt {
            return false
        }
        if lhs.senderComment != rhs.senderComment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nostrZapRequest)
        hasher.combine(nostrZapReceipt)
        hasher.combine(senderComment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlReceiveMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlReceiveMetadata {
        return
            try LnurlReceiveMetadata(
                nostrZapRequest: FfiConverterOptionString.read(from: &buf), 
                nostrZapReceipt: FfiConverterOptionString.read(from: &buf), 
                senderComment: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlReceiveMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.nostrZapRequest, into: &buf)
        FfiConverterOptionString.write(value.nostrZapReceipt, into: &buf)
        FfiConverterOptionString.write(value.senderComment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlReceiveMetadata_lift(_ buf: RustBuffer) throws -> LnurlReceiveMetadata {
    return try FfiConverterTypeLnurlReceiveMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlReceiveMetadata_lower(_ value: LnurlReceiveMetadata) -> RustBuffer {
    return FfiConverterTypeLnurlReceiveMetadata.lower(value)
}


/**
 * Represents the withdraw LNURL info
 */
public struct LnurlWithdrawInfo {
    public var withdrawUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(withdrawUrl: String) {
        self.withdrawUrl = withdrawUrl
    }
}



extension LnurlWithdrawInfo: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawInfo, rhs: LnurlWithdrawInfo) -> Bool {
        if lhs.withdrawUrl != rhs.withdrawUrl {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(withdrawUrl)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawInfo {
        return
            try LnurlWithdrawInfo(
                withdrawUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.withdrawUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawInfo_lift(_ buf: RustBuffer) throws -> LnurlWithdrawInfo {
    return try FfiConverterTypeLnurlWithdrawInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawInfo_lower(_ value: LnurlWithdrawInfo) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawInfo.lower(value)
}


public struct LnurlWithdrawRequest {
    /**
     * The amount to withdraw in satoshis
     * Must be within the min and max withdrawable limits
     */
    public var amountSats: UInt64
    public var withdrawRequest: LnurlWithdrawRequestDetails
    /**
     * If set, the function will return the payment if it is still pending after this
     * number of seconds. If unset, the function will return immediately after
     * initiating the LNURL withdraw.
     */
    public var completionTimeoutSecs: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The amount to withdraw in satoshis
         * Must be within the min and max withdrawable limits
         */amountSats: UInt64, withdrawRequest: LnurlWithdrawRequestDetails, 
        /**
         * If set, the function will return the payment if it is still pending after this
         * number of seconds. If unset, the function will return immediately after
         * initiating the LNURL withdraw.
         */completionTimeoutSecs: UInt32? = nil) {
        self.amountSats = amountSats
        self.withdrawRequest = withdrawRequest
        self.completionTimeoutSecs = completionTimeoutSecs
    }
}



extension LnurlWithdrawRequest: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawRequest, rhs: LnurlWithdrawRequest) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.withdrawRequest != rhs.withdrawRequest {
            return false
        }
        if lhs.completionTimeoutSecs != rhs.completionTimeoutSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(withdrawRequest)
        hasher.combine(completionTimeoutSecs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawRequest {
        return
            try LnurlWithdrawRequest(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                withdrawRequest: FfiConverterTypeLnurlWithdrawRequestDetails.read(from: &buf), 
                completionTimeoutSecs: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterTypeLnurlWithdrawRequestDetails.write(value.withdrawRequest, into: &buf)
        FfiConverterOptionUInt32.write(value.completionTimeoutSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequest_lift(_ buf: RustBuffer) throws -> LnurlWithdrawRequest {
    return try FfiConverterTypeLnurlWithdrawRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequest_lower(_ value: LnurlWithdrawRequest) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawRequest.lower(value)
}


public struct LnurlWithdrawRequestDetails {
    public var callback: String
    public var k1: String
    public var defaultDescription: String
    /**
     * The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
     */
    public var minWithdrawable: UInt64
    /**
     * The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
     */
    public var maxWithdrawable: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(callback: String, k1: String, defaultDescription: String, 
        /**
         * The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
         */minWithdrawable: UInt64, 
        /**
         * The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
         */maxWithdrawable: UInt64) {
        self.callback = callback
        self.k1 = k1
        self.defaultDescription = defaultDescription
        self.minWithdrawable = minWithdrawable
        self.maxWithdrawable = maxWithdrawable
    }
}



extension LnurlWithdrawRequestDetails: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawRequestDetails, rhs: LnurlWithdrawRequestDetails) -> Bool {
        if lhs.callback != rhs.callback {
            return false
        }
        if lhs.k1 != rhs.k1 {
            return false
        }
        if lhs.defaultDescription != rhs.defaultDescription {
            return false
        }
        if lhs.minWithdrawable != rhs.minWithdrawable {
            return false
        }
        if lhs.maxWithdrawable != rhs.maxWithdrawable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callback)
        hasher.combine(k1)
        hasher.combine(defaultDescription)
        hasher.combine(minWithdrawable)
        hasher.combine(maxWithdrawable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawRequestDetails {
        return
            try LnurlWithdrawRequestDetails(
                callback: FfiConverterString.read(from: &buf), 
                k1: FfiConverterString.read(from: &buf), 
                defaultDescription: FfiConverterString.read(from: &buf), 
                minWithdrawable: FfiConverterUInt64.read(from: &buf), 
                maxWithdrawable: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawRequestDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.callback, into: &buf)
        FfiConverterString.write(value.k1, into: &buf)
        FfiConverterString.write(value.defaultDescription, into: &buf)
        FfiConverterUInt64.write(value.minWithdrawable, into: &buf)
        FfiConverterUInt64.write(value.maxWithdrawable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequestDetails_lift(_ buf: RustBuffer) throws -> LnurlWithdrawRequestDetails {
    return try FfiConverterTypeLnurlWithdrawRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawRequestDetails_lower(_ value: LnurlWithdrawRequestDetails) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawRequestDetails.lower(value)
}


public struct LnurlWithdrawResponse {
    /**
     * The Lightning invoice generated for the LNURL withdraw
     */
    public var paymentRequest: String
    public var payment: Payment?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The Lightning invoice generated for the LNURL withdraw
         */paymentRequest: String, payment: Payment?) {
        self.paymentRequest = paymentRequest
        self.payment = payment
    }
}



extension LnurlWithdrawResponse: Equatable, Hashable {
    public static func ==(lhs: LnurlWithdrawResponse, rhs: LnurlWithdrawResponse) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlWithdrawResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlWithdrawResponse {
        return
            try LnurlWithdrawResponse(
                paymentRequest: FfiConverterString.read(from: &buf), 
                payment: FfiConverterOptionTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: LnurlWithdrawResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterOptionTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawResponse_lift(_ buf: RustBuffer) throws -> LnurlWithdrawResponse {
    return try FfiConverterTypeLnurlWithdrawResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlWithdrawResponse_lower(_ value: LnurlWithdrawResponse) -> RustBuffer {
    return FfiConverterTypeLnurlWithdrawResponse.lower(value)
}


/**
 * Locale-specific settings for the representation of a currency
 */
public struct LocaleOverrides {
    public var locale: String
    public var spacing: UInt32?
    public var symbol: Symbol

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locale: String, spacing: UInt32?, symbol: Symbol) {
        self.locale = locale
        self.spacing = spacing
        self.symbol = symbol
    }
}



extension LocaleOverrides: Equatable, Hashable {
    public static func ==(lhs: LocaleOverrides, rhs: LocaleOverrides) -> Bool {
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.spacing != rhs.spacing {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locale)
        hasher.combine(spacing)
        hasher.combine(symbol)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocaleOverrides: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleOverrides {
        return
            try LocaleOverrides(
                locale: FfiConverterString.read(from: &buf), 
                spacing: FfiConverterOptionUInt32.read(from: &buf), 
                symbol: FfiConverterTypeSymbol.read(from: &buf)
        )
    }

    public static func write(_ value: LocaleOverrides, into buf: inout [UInt8]) {
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterOptionUInt32.write(value.spacing, into: &buf)
        FfiConverterTypeSymbol.write(value.symbol, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocaleOverrides_lift(_ buf: RustBuffer) throws -> LocaleOverrides {
    return try FfiConverterTypeLocaleOverrides.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocaleOverrides_lower(_ value: LocaleOverrides) -> RustBuffer {
    return FfiConverterTypeLocaleOverrides.lower(value)
}


/**
 * Localized name of a currency
 */
public struct LocalizedName {
    public var locale: String
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(locale: String, name: String) {
        self.locale = locale
        self.name = name
    }
}



extension LocalizedName: Equatable, Hashable {
    public static func ==(lhs: LocalizedName, rhs: LocalizedName) -> Bool {
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locale)
        hasher.combine(name)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocalizedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalizedName {
        return
            try LocalizedName(
                locale: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LocalizedName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalizedName_lift(_ buf: RustBuffer) throws -> LocalizedName {
    return try FfiConverterTypeLocalizedName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocalizedName_lower(_ value: LocalizedName) -> RustBuffer {
    return FfiConverterTypeLocalizedName.lower(value)
}


public struct LogEntry {
    public var line: String
    public var level: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(line: String, level: String) {
        self.line = line
        self.level = level
    }
}



extension LogEntry: Equatable, Hashable {
    public static func ==(lhs: LogEntry, rhs: LogEntry) -> Bool {
        if lhs.line != rhs.line {
            return false
        }
        if lhs.level != rhs.level {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(line)
        hasher.combine(level)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogEntry {
        return
            try LogEntry(
                line: FfiConverterString.read(from: &buf), 
                level: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LogEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.line, into: &buf)
        FfiConverterString.write(value.level, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogEntry_lift(_ buf: RustBuffer) throws -> LogEntry {
    return try FfiConverterTypeLogEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogEntry_lower(_ value: LogEntry) -> RustBuffer {
    return FfiConverterTypeLogEntry.lower(value)
}


/**
 * FFI-safe representation of a 32-byte message digest for ECDSA signing
 */
public struct MessageBytes {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}



extension MessageBytes: Equatable, Hashable {
    public static func ==(lhs: MessageBytes, rhs: MessageBytes) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageBytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageBytes {
        return
            try MessageBytes(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: MessageBytes, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageBytes_lift(_ buf: RustBuffer) throws -> MessageBytes {
    return try FfiConverterTypeMessageBytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageBytes_lower(_ value: MessageBytes) -> RustBuffer {
    return FfiConverterTypeMessageBytes.lower(value)
}


public struct MessageSuccessActionData {
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String) {
        self.message = message
    }
}



extension MessageSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: MessageSuccessActionData, rhs: MessageSuccessActionData) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageSuccessActionData {
        return
            try MessageSuccessActionData(
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageSuccessActionData_lift(_ buf: RustBuffer) throws -> MessageSuccessActionData {
    return try FfiConverterTypeMessageSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageSuccessActionData_lower(_ value: MessageSuccessActionData) -> RustBuffer {
    return FfiConverterTypeMessageSuccessActionData.lower(value)
}


public struct MintIssuerTokenRequest {
    public var amount: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: U128) {
        self.amount = amount
    }
}



extension MintIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: MintIssuerTokenRequest, rhs: MintIssuerTokenRequest) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMintIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MintIssuerTokenRequest {
        return
            try MintIssuerTokenRequest(
                amount: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: MintIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterTypeu128.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMintIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> MintIssuerTokenRequest {
    return try FfiConverterTypeMintIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMintIssuerTokenRequest_lower(_ value: MintIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeMintIssuerTokenRequest.lower(value)
}


public struct OptimizationConfig {
    /**
     * Whether automatic leaf optimization is enabled.
     *
     * If set to true, the SDK will automatically optimize the leaf set when it changes.
     * Otherwise, the manual optimization API must be used to optimize the leaf set.
     *
     * Default value is true.
     */
    public var autoEnabled: Bool
    /**
     * The desired multiplicity for the leaf set. Acceptable values are 0-5.
     *
     * Setting this to 0 will optimize for maximizing unilateral exit.
     * Higher values will optimize for minimizing transfer swaps, with higher values
     * being more aggressive.
     *
     * Default value is 1.
     */
    public var multiplicity: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether automatic leaf optimization is enabled.
         *
         * If set to true, the SDK will automatically optimize the leaf set when it changes.
         * Otherwise, the manual optimization API must be used to optimize the leaf set.
         *
         * Default value is true.
         */autoEnabled: Bool, 
        /**
         * The desired multiplicity for the leaf set. Acceptable values are 0-5.
         *
         * Setting this to 0 will optimize for maximizing unilateral exit.
         * Higher values will optimize for minimizing transfer swaps, with higher values
         * being more aggressive.
         *
         * Default value is 1.
         */multiplicity: UInt8) {
        self.autoEnabled = autoEnabled
        self.multiplicity = multiplicity
    }
}



extension OptimizationConfig: Equatable, Hashable {
    public static func ==(lhs: OptimizationConfig, rhs: OptimizationConfig) -> Bool {
        if lhs.autoEnabled != rhs.autoEnabled {
            return false
        }
        if lhs.multiplicity != rhs.multiplicity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(autoEnabled)
        hasher.combine(multiplicity)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOptimizationConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OptimizationConfig {
        return
            try OptimizationConfig(
                autoEnabled: FfiConverterBool.read(from: &buf), 
                multiplicity: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: OptimizationConfig, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.autoEnabled, into: &buf)
        FfiConverterUInt8.write(value.multiplicity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOptimizationConfig_lift(_ buf: RustBuffer) throws -> OptimizationConfig {
    return try FfiConverterTypeOptimizationConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOptimizationConfig_lower(_ value: OptimizationConfig) -> RustBuffer {
    return FfiConverterTypeOptimizationConfig.lower(value)
}


public struct OptimizationProgress {
    public var isRunning: Bool
    public var currentRound: UInt32
    public var totalRounds: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isRunning: Bool, currentRound: UInt32, totalRounds: UInt32) {
        self.isRunning = isRunning
        self.currentRound = currentRound
        self.totalRounds = totalRounds
    }
}



extension OptimizationProgress: Equatable, Hashable {
    public static func ==(lhs: OptimizationProgress, rhs: OptimizationProgress) -> Bool {
        if lhs.isRunning != rhs.isRunning {
            return false
        }
        if lhs.currentRound != rhs.currentRound {
            return false
        }
        if lhs.totalRounds != rhs.totalRounds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRunning)
        hasher.combine(currentRound)
        hasher.combine(totalRounds)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOptimizationProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OptimizationProgress {
        return
            try OptimizationProgress(
                isRunning: FfiConverterBool.read(from: &buf), 
                currentRound: FfiConverterUInt32.read(from: &buf), 
                totalRounds: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: OptimizationProgress, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRunning, into: &buf)
        FfiConverterUInt32.write(value.currentRound, into: &buf)
        FfiConverterUInt32.write(value.totalRounds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOptimizationProgress_lift(_ buf: RustBuffer) throws -> OptimizationProgress {
    return try FfiConverterTypeOptimizationProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOptimizationProgress_lower(_ value: OptimizationProgress) -> RustBuffer {
    return FfiConverterTypeOptimizationProgress.lower(value)
}


public struct OutgoingChange {
    public var change: RecordChange
    public var parent: Record?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(change: RecordChange, parent: Record?) {
        self.change = change
        self.parent = parent
    }
}



extension OutgoingChange: Equatable, Hashable {
    public static func ==(lhs: OutgoingChange, rhs: OutgoingChange) -> Bool {
        if lhs.change != rhs.change {
            return false
        }
        if lhs.parent != rhs.parent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(change)
        hasher.combine(parent)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutgoingChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutgoingChange {
        return
            try OutgoingChange(
                change: FfiConverterTypeRecordChange.read(from: &buf), 
                parent: FfiConverterOptionTypeRecord.read(from: &buf)
        )
    }

    public static func write(_ value: OutgoingChange, into buf: inout [UInt8]) {
        FfiConverterTypeRecordChange.write(value.change, into: &buf)
        FfiConverterOptionTypeRecord.write(value.parent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutgoingChange_lift(_ buf: RustBuffer) throws -> OutgoingChange {
    return try FfiConverterTypeOutgoingChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutgoingChange_lower(_ value: OutgoingChange) -> RustBuffer {
    return FfiConverterTypeOutgoingChange.lower(value)
}


/**
 * Represents a payment (sent or received)
 */
public struct Payment {
    /**
     * Unique identifier for the payment
     */
    public var id: String
    /**
     * Type of payment (send or receive)
     */
    public var paymentType: PaymentType
    /**
     * Status of the payment
     */
    public var status: PaymentStatus
    /**
     * Amount in satoshis or token base units
     */
    public var amount: U128
    /**
     * Fee paid in satoshis or token base units
     */
    public var fees: U128
    /**
     * Timestamp of when the payment was created
     */
    public var timestamp: UInt64
    /**
     * Method of payment. Sometimes the payment details is empty so this field
     * is used to determine the payment method.
     */
    public var method: PaymentMethod
    /**
     * Details of the payment
     */
    public var details: PaymentDetails?
    /**
     * If set, this payment involved a conversion before the payment
     */
    public var conversionDetails: ConversionDetails?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for the payment
         */id: String, 
        /**
         * Type of payment (send or receive)
         */paymentType: PaymentType, 
        /**
         * Status of the payment
         */status: PaymentStatus, 
        /**
         * Amount in satoshis or token base units
         */amount: U128, 
        /**
         * Fee paid in satoshis or token base units
         */fees: U128, 
        /**
         * Timestamp of when the payment was created
         */timestamp: UInt64, 
        /**
         * Method of payment. Sometimes the payment details is empty so this field
         * is used to determine the payment method.
         */method: PaymentMethod, 
        /**
         * Details of the payment
         */details: PaymentDetails?, 
        /**
         * If set, this payment involved a conversion before the payment
         */conversionDetails: ConversionDetails?) {
        self.id = id
        self.paymentType = paymentType
        self.status = status
        self.amount = amount
        self.fees = fees
        self.timestamp = timestamp
        self.method = method
        self.details = details
        self.conversionDetails = conversionDetails
    }
}



extension Payment: Equatable, Hashable {
    public static func ==(lhs: Payment, rhs: Payment) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.paymentType != rhs.paymentType {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        if lhs.conversionDetails != rhs.conversionDetails {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(paymentType)
        hasher.combine(status)
        hasher.combine(amount)
        hasher.combine(fees)
        hasher.combine(timestamp)
        hasher.combine(method)
        hasher.combine(details)
        hasher.combine(conversionDetails)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return
            try Payment(
                id: FfiConverterString.read(from: &buf), 
                paymentType: FfiConverterTypePaymentType.read(from: &buf), 
                status: FfiConverterTypePaymentStatus.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                fees: FfiConverterTypeu128.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                method: FfiConverterTypePaymentMethod.read(from: &buf), 
                details: FfiConverterOptionTypePaymentDetails.read(from: &buf), 
                conversionDetails: FfiConverterOptionTypeConversionDetails.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypePaymentType.write(value.paymentType, into: &buf)
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterTypeu128.write(value.fees, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterTypePaymentMethod.write(value.method, into: &buf)
        FfiConverterOptionTypePaymentDetails.write(value.details, into: &buf)
        FfiConverterOptionTypeConversionDetails.write(value.conversionDetails, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayment_lift(_ buf: RustBuffer) throws -> Payment {
    return try FfiConverterTypePayment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayment_lower(_ value: Payment) -> RustBuffer {
    return FfiConverterTypePayment.lower(value)
}


/**
 * Metadata associated with a payment that cannot be extracted from the Spark operator.
 */
public struct PaymentMetadata {
    public var parentPaymentId: String?
    public var lnurlPayInfo: LnurlPayInfo?
    public var lnurlWithdrawInfo: LnurlWithdrawInfo?
    public var lnurlDescription: String?
    public var conversionInfo: ConversionInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(parentPaymentId: String?, lnurlPayInfo: LnurlPayInfo?, lnurlWithdrawInfo: LnurlWithdrawInfo?, lnurlDescription: String?, conversionInfo: ConversionInfo?) {
        self.parentPaymentId = parentPaymentId
        self.lnurlPayInfo = lnurlPayInfo
        self.lnurlWithdrawInfo = lnurlWithdrawInfo
        self.lnurlDescription = lnurlDescription
        self.conversionInfo = conversionInfo
    }
}



extension PaymentMetadata: Equatable, Hashable {
    public static func ==(lhs: PaymentMetadata, rhs: PaymentMetadata) -> Bool {
        if lhs.parentPaymentId != rhs.parentPaymentId {
            return false
        }
        if lhs.lnurlPayInfo != rhs.lnurlPayInfo {
            return false
        }
        if lhs.lnurlWithdrawInfo != rhs.lnurlWithdrawInfo {
            return false
        }
        if lhs.lnurlDescription != rhs.lnurlDescription {
            return false
        }
        if lhs.conversionInfo != rhs.conversionInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(parentPaymentId)
        hasher.combine(lnurlPayInfo)
        hasher.combine(lnurlWithdrawInfo)
        hasher.combine(lnurlDescription)
        hasher.combine(conversionInfo)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMetadata {
        return
            try PaymentMetadata(
                parentPaymentId: FfiConverterOptionString.read(from: &buf), 
                lnurlPayInfo: FfiConverterOptionTypeLnurlPayInfo.read(from: &buf), 
                lnurlWithdrawInfo: FfiConverterOptionTypeLnurlWithdrawInfo.read(from: &buf), 
                lnurlDescription: FfiConverterOptionString.read(from: &buf), 
                conversionInfo: FfiConverterOptionTypeConversionInfo.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.parentPaymentId, into: &buf)
        FfiConverterOptionTypeLnurlPayInfo.write(value.lnurlPayInfo, into: &buf)
        FfiConverterOptionTypeLnurlWithdrawInfo.write(value.lnurlWithdrawInfo, into: &buf)
        FfiConverterOptionString.write(value.lnurlDescription, into: &buf)
        FfiConverterOptionTypeConversionInfo.write(value.conversionInfo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lift(_ buf: RustBuffer) throws -> PaymentMetadata {
    return try FfiConverterTypePaymentMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMetadata_lower(_ value: PaymentMetadata) -> RustBuffer {
    return FfiConverterTypePaymentMetadata.lower(value)
}


public struct PaymentRequestSource {
    public var bip21Uri: String?
    public var bip353Address: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bip21Uri: String?, bip353Address: String?) {
        self.bip21Uri = bip21Uri
        self.bip353Address = bip353Address
    }
}



extension PaymentRequestSource: Equatable, Hashable {
    public static func ==(lhs: PaymentRequestSource, rhs: PaymentRequestSource) -> Bool {
        if lhs.bip21Uri != rhs.bip21Uri {
            return false
        }
        if lhs.bip353Address != rhs.bip353Address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bip21Uri)
        hasher.combine(bip353Address)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentRequestSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentRequestSource {
        return
            try PaymentRequestSource(
                bip21Uri: FfiConverterOptionString.read(from: &buf), 
                bip353Address: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentRequestSource, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.bip21Uri, into: &buf)
        FfiConverterOptionString.write(value.bip353Address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentRequestSource_lift(_ buf: RustBuffer) throws -> PaymentRequestSource {
    return try FfiConverterTypePaymentRequestSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentRequestSource_lower(_ value: PaymentRequestSource) -> RustBuffer {
    return FfiConverterTypePaymentRequestSource.lower(value)
}


/**
 * Configuration for `PostgreSQL` storage connection pool.
 */
public struct PostgresStorageConfig {
    /**
     * `PostgreSQL` connection string (key-value or URI format).
     *
     * Supported formats:
     * - Key-value: `host=localhost user=postgres dbname=spark sslmode=require`
     * - URI: `postgres://user:password@host:port/dbname?sslmode=require`
     */
    public var connectionString: String
    /**
     * Maximum number of connections in the pool.
     * Default: `num_cpus * 4` (from deadpool).
     */
    public var maxPoolSize: UInt32
    /**
     * Timeout in seconds waiting for a connection from the pool.
     * `None` means wait indefinitely.
     */
    public var waitTimeoutSecs: UInt64?
    /**
     * Timeout in seconds for establishing a new connection.
     * `None` means no timeout.
     */
    public var createTimeoutSecs: UInt64?
    /**
     * Timeout in seconds before recycling an idle connection.
     * `None` means connections are not recycled based on idle time.
     */
    public var recycleTimeoutSecs: UInt64?
    /**
     * Queue mode for retrieving connections from the pool.
     * Default: FIFO.
     */
    public var queueMode: PoolQueueMode
    /**
     * Custom CA certificate(s) in PEM format for server verification.
     * If `None`, uses Mozilla's root certificate store (via webpki-roots).
     * Only used with `sslmode=verify-ca` or `sslmode=verify-full`.
     */
    public var rootCaPem: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * `PostgreSQL` connection string (key-value or URI format).
         *
         * Supported formats:
         * - Key-value: `host=localhost user=postgres dbname=spark sslmode=require`
         * - URI: `postgres://user:password@host:port/dbname?sslmode=require`
         */connectionString: String, 
        /**
         * Maximum number of connections in the pool.
         * Default: `num_cpus * 4` (from deadpool).
         */maxPoolSize: UInt32, 
        /**
         * Timeout in seconds waiting for a connection from the pool.
         * `None` means wait indefinitely.
         */waitTimeoutSecs: UInt64?, 
        /**
         * Timeout in seconds for establishing a new connection.
         * `None` means no timeout.
         */createTimeoutSecs: UInt64?, 
        /**
         * Timeout in seconds before recycling an idle connection.
         * `None` means connections are not recycled based on idle time.
         */recycleTimeoutSecs: UInt64?, 
        /**
         * Queue mode for retrieving connections from the pool.
         * Default: FIFO.
         */queueMode: PoolQueueMode, 
        /**
         * Custom CA certificate(s) in PEM format for server verification.
         * If `None`, uses Mozilla's root certificate store (via webpki-roots).
         * Only used with `sslmode=verify-ca` or `sslmode=verify-full`.
         */rootCaPem: String?) {
        self.connectionString = connectionString
        self.maxPoolSize = maxPoolSize
        self.waitTimeoutSecs = waitTimeoutSecs
        self.createTimeoutSecs = createTimeoutSecs
        self.recycleTimeoutSecs = recycleTimeoutSecs
        self.queueMode = queueMode
        self.rootCaPem = rootCaPem
    }
}



extension PostgresStorageConfig: Equatable, Hashable {
    public static func ==(lhs: PostgresStorageConfig, rhs: PostgresStorageConfig) -> Bool {
        if lhs.connectionString != rhs.connectionString {
            return false
        }
        if lhs.maxPoolSize != rhs.maxPoolSize {
            return false
        }
        if lhs.waitTimeoutSecs != rhs.waitTimeoutSecs {
            return false
        }
        if lhs.createTimeoutSecs != rhs.createTimeoutSecs {
            return false
        }
        if lhs.recycleTimeoutSecs != rhs.recycleTimeoutSecs {
            return false
        }
        if lhs.queueMode != rhs.queueMode {
            return false
        }
        if lhs.rootCaPem != rhs.rootCaPem {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(connectionString)
        hasher.combine(maxPoolSize)
        hasher.combine(waitTimeoutSecs)
        hasher.combine(createTimeoutSecs)
        hasher.combine(recycleTimeoutSecs)
        hasher.combine(queueMode)
        hasher.combine(rootCaPem)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePostgresStorageConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostgresStorageConfig {
        return
            try PostgresStorageConfig(
                connectionString: FfiConverterString.read(from: &buf), 
                maxPoolSize: FfiConverterUInt32.read(from: &buf), 
                waitTimeoutSecs: FfiConverterOptionUInt64.read(from: &buf), 
                createTimeoutSecs: FfiConverterOptionUInt64.read(from: &buf), 
                recycleTimeoutSecs: FfiConverterOptionUInt64.read(from: &buf), 
                queueMode: FfiConverterTypePoolQueueMode.read(from: &buf), 
                rootCaPem: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PostgresStorageConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.connectionString, into: &buf)
        FfiConverterUInt32.write(value.maxPoolSize, into: &buf)
        FfiConverterOptionUInt64.write(value.waitTimeoutSecs, into: &buf)
        FfiConverterOptionUInt64.write(value.createTimeoutSecs, into: &buf)
        FfiConverterOptionUInt64.write(value.recycleTimeoutSecs, into: &buf)
        FfiConverterTypePoolQueueMode.write(value.queueMode, into: &buf)
        FfiConverterOptionString.write(value.rootCaPem, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePostgresStorageConfig_lift(_ buf: RustBuffer) throws -> PostgresStorageConfig {
    return try FfiConverterTypePostgresStorageConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePostgresStorageConfig_lower(_ value: PostgresStorageConfig) -> RustBuffer {
    return FfiConverterTypePostgresStorageConfig.lower(value)
}


public struct PrepareLnurlPayRequest {
    /**
     * The amount to send in satoshis.
     */
    public var amountSats: UInt64
    public var payRequest: LnurlPayRequestDetails
    public var comment: String?
    public var validateSuccessActionUrl: Bool?
    /**
     * If provided, the payment will include a token conversion step before sending the payment
     */
    public var conversionOptions: ConversionOptions?
    /**
     * How fees should be handled. Defaults to `FeesExcluded` (fees added on top).
     */
    public var feePolicy: FeePolicy?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The amount to send in satoshis.
         */amountSats: UInt64, payRequest: LnurlPayRequestDetails, comment: String? = nil, validateSuccessActionUrl: Bool? = nil, 
        /**
         * If provided, the payment will include a token conversion step before sending the payment
         */conversionOptions: ConversionOptions? = nil, 
        /**
         * How fees should be handled. Defaults to `FeesExcluded` (fees added on top).
         */feePolicy: FeePolicy? = nil) {
        self.amountSats = amountSats
        self.payRequest = payRequest
        self.comment = comment
        self.validateSuccessActionUrl = validateSuccessActionUrl
        self.conversionOptions = conversionOptions
        self.feePolicy = feePolicy
    }
}



extension PrepareLnurlPayRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareLnurlPayRequest, rhs: PrepareLnurlPayRequest) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.validateSuccessActionUrl != rhs.validateSuccessActionUrl {
            return false
        }
        if lhs.conversionOptions != rhs.conversionOptions {
            return false
        }
        if lhs.feePolicy != rhs.feePolicy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(payRequest)
        hasher.combine(comment)
        hasher.combine(validateSuccessActionUrl)
        hasher.combine(conversionOptions)
        hasher.combine(feePolicy)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareLnurlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareLnurlPayRequest {
        return
            try PrepareLnurlPayRequest(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                validateSuccessActionUrl: FfiConverterOptionBool.read(from: &buf), 
                conversionOptions: FfiConverterOptionTypeConversionOptions.read(from: &buf), 
                feePolicy: FfiConverterOptionTypeFeePolicy.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareLnurlPayRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterOptionBool.write(value.validateSuccessActionUrl, into: &buf)
        FfiConverterOptionTypeConversionOptions.write(value.conversionOptions, into: &buf)
        FfiConverterOptionTypeFeePolicy.write(value.feePolicy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayRequest_lift(_ buf: RustBuffer) throws -> PrepareLnurlPayRequest {
    return try FfiConverterTypePrepareLnurlPayRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayRequest_lower(_ value: PrepareLnurlPayRequest) -> RustBuffer {
    return FfiConverterTypePrepareLnurlPayRequest.lower(value)
}


public struct PrepareLnurlPayResponse {
    /**
     * The amount to send in satoshis.
     */
    public var amountSats: UInt64
    public var comment: String?
    public var payRequest: LnurlPayRequestDetails
    /**
     * The fee in satoshis. For `FeesIncluded` operations, this represents the total fee
     * (including potential overpayment).
     */
    public var feeSats: UInt64
    public var invoiceDetails: Bolt11InvoiceDetails
    public var successAction: SuccessAction?
    /**
     * When set, the payment will include a token conversion step before sending the payment
     */
    public var conversionEstimate: ConversionEstimate?
    /**
     * How fees are handled for this payment.
     */
    public var feePolicy: FeePolicy

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The amount to send in satoshis.
         */amountSats: UInt64, comment: String?, payRequest: LnurlPayRequestDetails, 
        /**
         * The fee in satoshis. For `FeesIncluded` operations, this represents the total fee
         * (including potential overpayment).
         */feeSats: UInt64, invoiceDetails: Bolt11InvoiceDetails, successAction: SuccessAction?, 
        /**
         * When set, the payment will include a token conversion step before sending the payment
         */conversionEstimate: ConversionEstimate?, 
        /**
         * How fees are handled for this payment.
         */feePolicy: FeePolicy) {
        self.amountSats = amountSats
        self.comment = comment
        self.payRequest = payRequest
        self.feeSats = feeSats
        self.invoiceDetails = invoiceDetails
        self.successAction = successAction
        self.conversionEstimate = conversionEstimate
        self.feePolicy = feePolicy
    }
}



extension PrepareLnurlPayResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareLnurlPayResponse, rhs: PrepareLnurlPayResponse) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.comment != rhs.comment {
            return false
        }
        if lhs.payRequest != rhs.payRequest {
            return false
        }
        if lhs.feeSats != rhs.feeSats {
            return false
        }
        if lhs.invoiceDetails != rhs.invoiceDetails {
            return false
        }
        if lhs.successAction != rhs.successAction {
            return false
        }
        if lhs.conversionEstimate != rhs.conversionEstimate {
            return false
        }
        if lhs.feePolicy != rhs.feePolicy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(comment)
        hasher.combine(payRequest)
        hasher.combine(feeSats)
        hasher.combine(invoiceDetails)
        hasher.combine(successAction)
        hasher.combine(conversionEstimate)
        hasher.combine(feePolicy)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareLnurlPayResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareLnurlPayResponse {
        return
            try PrepareLnurlPayResponse(
                amountSats: FfiConverterUInt64.read(from: &buf), 
                comment: FfiConverterOptionString.read(from: &buf), 
                payRequest: FfiConverterTypeLnurlPayRequestDetails.read(from: &buf), 
                feeSats: FfiConverterUInt64.read(from: &buf), 
                invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.read(from: &buf), 
                successAction: FfiConverterOptionTypeSuccessAction.read(from: &buf), 
                conversionEstimate: FfiConverterOptionTypeConversionEstimate.read(from: &buf), 
                feePolicy: FfiConverterTypeFeePolicy.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareLnurlPayResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.amountSats, into: &buf)
        FfiConverterOptionString.write(value.comment, into: &buf)
        FfiConverterTypeLnurlPayRequestDetails.write(value.payRequest, into: &buf)
        FfiConverterUInt64.write(value.feeSats, into: &buf)
        FfiConverterTypeBolt11InvoiceDetails.write(value.invoiceDetails, into: &buf)
        FfiConverterOptionTypeSuccessAction.write(value.successAction, into: &buf)
        FfiConverterOptionTypeConversionEstimate.write(value.conversionEstimate, into: &buf)
        FfiConverterTypeFeePolicy.write(value.feePolicy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayResponse_lift(_ buf: RustBuffer) throws -> PrepareLnurlPayResponse {
    return try FfiConverterTypePrepareLnurlPayResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareLnurlPayResponse_lower(_ value: PrepareLnurlPayResponse) -> RustBuffer {
    return FfiConverterTypePrepareLnurlPayResponse.lower(value)
}


public struct PrepareSendPaymentRequest {
    public var paymentRequest: String
    /**
     * The amount to send.
     * Optional for payment requests with embedded amounts (e.g., Spark/Bolt11 invoices with amounts).
     * Required for Spark addresses, Bitcoin addresses, and amountless invoices.
     * Denominated in satoshis for Bitcoin payments, or token base units for token payments.
     */
    public var amount: U128?
    /**
     * Optional token identifier for token payments.
     * Absence indicates that the payment is a Bitcoin payment.
     */
    public var tokenIdentifier: String?
    /**
     * If provided, the payment will include a conversion step before sending the payment
     */
    public var conversionOptions: ConversionOptions?
    /**
     * How fees should be handled. Defaults to `FeesExcluded` (fees added on top).
     */
    public var feePolicy: FeePolicy?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentRequest: String, 
        /**
         * The amount to send.
         * Optional for payment requests with embedded amounts (e.g., Spark/Bolt11 invoices with amounts).
         * Required for Spark addresses, Bitcoin addresses, and amountless invoices.
         * Denominated in satoshis for Bitcoin payments, or token base units for token payments.
         */amount: U128? = nil, 
        /**
         * Optional token identifier for token payments.
         * Absence indicates that the payment is a Bitcoin payment.
         */tokenIdentifier: String? = nil, 
        /**
         * If provided, the payment will include a conversion step before sending the payment
         */conversionOptions: ConversionOptions? = nil, 
        /**
         * How fees should be handled. Defaults to `FeesExcluded` (fees added on top).
         */feePolicy: FeePolicy? = nil) {
        self.paymentRequest = paymentRequest
        self.amount = amount
        self.tokenIdentifier = tokenIdentifier
        self.conversionOptions = conversionOptions
        self.feePolicy = feePolicy
    }
}



extension PrepareSendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareSendPaymentRequest, rhs: PrepareSendPaymentRequest) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        if lhs.conversionOptions != rhs.conversionOptions {
            return false
        }
        if lhs.feePolicy != rhs.feePolicy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(amount)
        hasher.combine(tokenIdentifier)
        hasher.combine(conversionOptions)
        hasher.combine(feePolicy)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSendPaymentRequest {
        return
            try PrepareSendPaymentRequest(
                paymentRequest: FfiConverterString.read(from: &buf), 
                amount: FfiConverterOptionTypeu128.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf), 
                conversionOptions: FfiConverterOptionTypeConversionOptions.read(from: &buf), 
                feePolicy: FfiConverterOptionTypeFeePolicy.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterOptionTypeu128.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
        FfiConverterOptionTypeConversionOptions.write(value.conversionOptions, into: &buf)
        FfiConverterOptionTypeFeePolicy.write(value.feePolicy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentRequest_lift(_ buf: RustBuffer) throws -> PrepareSendPaymentRequest {
    return try FfiConverterTypePrepareSendPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentRequest_lower(_ value: PrepareSendPaymentRequest) -> RustBuffer {
    return FfiConverterTypePrepareSendPaymentRequest.lower(value)
}


public struct PrepareSendPaymentResponse {
    public var paymentMethod: SendPaymentMethod
    /**
     * The amount for the payment.
     * Denominated in satoshis for Bitcoin payments, or token base units for token payments.
     */
    public var amount: U128
    /**
     * Optional token identifier for token payments.
     * Absence indicates that the payment is a Bitcoin payment.
     */
    public var tokenIdentifier: String?
    /**
     * When set, the payment will include a conversion step before sending the payment
     */
    public var conversionEstimate: ConversionEstimate?
    /**
     * How fees are handled for this payment.
     */
    public var feePolicy: FeePolicy

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentMethod: SendPaymentMethod, 
        /**
         * The amount for the payment.
         * Denominated in satoshis for Bitcoin payments, or token base units for token payments.
         */amount: U128, 
        /**
         * Optional token identifier for token payments.
         * Absence indicates that the payment is a Bitcoin payment.
         */tokenIdentifier: String?, 
        /**
         * When set, the payment will include a conversion step before sending the payment
         */conversionEstimate: ConversionEstimate?, 
        /**
         * How fees are handled for this payment.
         */feePolicy: FeePolicy) {
        self.paymentMethod = paymentMethod
        self.amount = amount
        self.tokenIdentifier = tokenIdentifier
        self.conversionEstimate = conversionEstimate
        self.feePolicy = feePolicy
    }
}



extension PrepareSendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareSendPaymentResponse, rhs: PrepareSendPaymentResponse) -> Bool {
        if lhs.paymentMethod != rhs.paymentMethod {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        if lhs.conversionEstimate != rhs.conversionEstimate {
            return false
        }
        if lhs.feePolicy != rhs.feePolicy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentMethod)
        hasher.combine(amount)
        hasher.combine(tokenIdentifier)
        hasher.combine(conversionEstimate)
        hasher.combine(feePolicy)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrepareSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSendPaymentResponse {
        return
            try PrepareSendPaymentResponse(
                paymentMethod: FfiConverterTypeSendPaymentMethod.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf), 
                conversionEstimate: FfiConverterOptionTypeConversionEstimate.read(from: &buf), 
                feePolicy: FfiConverterTypeFeePolicy.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypeSendPaymentMethod.write(value.paymentMethod, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
        FfiConverterOptionTypeConversionEstimate.write(value.conversionEstimate, into: &buf)
        FfiConverterTypeFeePolicy.write(value.feePolicy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentResponse_lift(_ buf: RustBuffer) throws -> PrepareSendPaymentResponse {
    return try FfiConverterTypePrepareSendPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrepareSendPaymentResponse_lower(_ value: PrepareSendPaymentResponse) -> RustBuffer {
    return FfiConverterTypePrepareSendPaymentResponse.lower(value)
}


public struct ProvisionalPayment {
    /**
     * Unique identifier for the payment
     */
    public var paymentId: String
    /**
     * Amount in satoshis or token base units
     */
    public var amount: U128
    /**
     * Details of the payment
     */
    public var details: ProvisionalPaymentDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique identifier for the payment
         */paymentId: String, 
        /**
         * Amount in satoshis or token base units
         */amount: U128, 
        /**
         * Details of the payment
         */details: ProvisionalPaymentDetails) {
        self.paymentId = paymentId
        self.amount = amount
        self.details = details
    }
}



extension ProvisionalPayment: Equatable, Hashable {
    public static func ==(lhs: ProvisionalPayment, rhs: ProvisionalPayment) -> Bool {
        if lhs.paymentId != rhs.paymentId {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentId)
        hasher.combine(amount)
        hasher.combine(details)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProvisionalPayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProvisionalPayment {
        return
            try ProvisionalPayment(
                paymentId: FfiConverterString.read(from: &buf), 
                amount: FfiConverterTypeu128.read(from: &buf), 
                details: FfiConverterTypeProvisionalPaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: ProvisionalPayment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentId, into: &buf)
        FfiConverterTypeu128.write(value.amount, into: &buf)
        FfiConverterTypeProvisionalPaymentDetails.write(value.details, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPayment_lift(_ buf: RustBuffer) throws -> ProvisionalPayment {
    return try FfiConverterTypeProvisionalPayment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPayment_lower(_ value: ProvisionalPayment) -> RustBuffer {
    return FfiConverterTypeProvisionalPayment.lower(value)
}


/**
 * FFI-safe representation of a secp256k1 public key (33 bytes compressed)
 */
public struct PublicKeyBytes {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}



extension PublicKeyBytes: Equatable, Hashable {
    public static func ==(lhs: PublicKeyBytes, rhs: PublicKeyBytes) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicKeyBytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyBytes {
        return
            try PublicKeyBytes(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: PublicKeyBytes, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKeyBytes_lift(_ buf: RustBuffer) throws -> PublicKeyBytes {
    return try FfiConverterTypePublicKeyBytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKeyBytes_lower(_ value: PublicKeyBytes) -> RustBuffer {
    return FfiConverterTypePublicKeyBytes.lower(value)
}


/**
 * Denominator in an exchange rate
 */
public struct Rate {
    public var coin: String
    public var value: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(coin: String, value: Double) {
        self.coin = coin
        self.value = value
    }
}



extension Rate: Equatable, Hashable {
    public static func ==(lhs: Rate, rhs: Rate) -> Bool {
        if lhs.coin != rhs.coin {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(coin)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rate {
        return
            try Rate(
                coin: FfiConverterString.read(from: &buf), 
                value: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Rate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.coin, into: &buf)
        FfiConverterDouble.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRate_lift(_ buf: RustBuffer) throws -> Rate {
    return try FfiConverterTypeRate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRate_lower(_ value: Rate) -> RustBuffer {
    return FfiConverterTypeRate.lower(value)
}


public struct ReceivePaymentRequest {
    public var paymentMethod: ReceivePaymentMethod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentMethod: ReceivePaymentMethod) {
        self.paymentMethod = paymentMethod
    }
}



extension ReceivePaymentRequest: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentRequest, rhs: ReceivePaymentRequest) -> Bool {
        if lhs.paymentMethod != rhs.paymentMethod {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentMethod)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentRequest {
        return
            try ReceivePaymentRequest(
                paymentMethod: FfiConverterTypeReceivePaymentMethod.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypeReceivePaymentMethod.write(value.paymentMethod, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentRequest_lift(_ buf: RustBuffer) throws -> ReceivePaymentRequest {
    return try FfiConverterTypeReceivePaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentRequest_lower(_ value: ReceivePaymentRequest) -> RustBuffer {
    return FfiConverterTypeReceivePaymentRequest.lower(value)
}


public struct ReceivePaymentResponse {
    public var paymentRequest: String
    /**
     * Fee to pay to receive the payment
     * Denominated in sats or token base units
     */
    public var fee: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentRequest: String, 
        /**
         * Fee to pay to receive the payment
         * Denominated in sats or token base units
         */fee: U128) {
        self.paymentRequest = paymentRequest
        self.fee = fee
    }
}



extension ReceivePaymentResponse: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentResponse, rhs: ReceivePaymentResponse) -> Bool {
        if lhs.paymentRequest != rhs.paymentRequest {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentRequest)
        hasher.combine(fee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentResponse {
        return
            try ReceivePaymentResponse(
                paymentRequest: FfiConverterString.read(from: &buf), 
                fee: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentRequest, into: &buf)
        FfiConverterTypeu128.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentResponse_lift(_ buf: RustBuffer) throws -> ReceivePaymentResponse {
    return try FfiConverterTypeReceivePaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentResponse_lower(_ value: ReceivePaymentResponse) -> RustBuffer {
    return FfiConverterTypeReceivePaymentResponse.lower(value)
}


public struct RecommendedFees {
    public var fastestFee: UInt64
    public var halfHourFee: UInt64
    public var hourFee: UInt64
    public var economyFee: UInt64
    public var minimumFee: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fastestFee: UInt64, halfHourFee: UInt64, hourFee: UInt64, economyFee: UInt64, minimumFee: UInt64) {
        self.fastestFee = fastestFee
        self.halfHourFee = halfHourFee
        self.hourFee = hourFee
        self.economyFee = economyFee
        self.minimumFee = minimumFee
    }
}



extension RecommendedFees: Equatable, Hashable {
    public static func ==(lhs: RecommendedFees, rhs: RecommendedFees) -> Bool {
        if lhs.fastestFee != rhs.fastestFee {
            return false
        }
        if lhs.halfHourFee != rhs.halfHourFee {
            return false
        }
        if lhs.hourFee != rhs.hourFee {
            return false
        }
        if lhs.economyFee != rhs.economyFee {
            return false
        }
        if lhs.minimumFee != rhs.minimumFee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fastestFee)
        hasher.combine(halfHourFee)
        hasher.combine(hourFee)
        hasher.combine(economyFee)
        hasher.combine(minimumFee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecommendedFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecommendedFees {
        return
            try RecommendedFees(
                fastestFee: FfiConverterUInt64.read(from: &buf), 
                halfHourFee: FfiConverterUInt64.read(from: &buf), 
                hourFee: FfiConverterUInt64.read(from: &buf), 
                economyFee: FfiConverterUInt64.read(from: &buf), 
                minimumFee: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RecommendedFees, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.fastestFee, into: &buf)
        FfiConverterUInt64.write(value.halfHourFee, into: &buf)
        FfiConverterUInt64.write(value.hourFee, into: &buf)
        FfiConverterUInt64.write(value.economyFee, into: &buf)
        FfiConverterUInt64.write(value.minimumFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecommendedFees_lift(_ buf: RustBuffer) throws -> RecommendedFees {
    return try FfiConverterTypeRecommendedFees.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecommendedFees_lower(_ value: RecommendedFees) -> RustBuffer {
    return FfiConverterTypeRecommendedFees.lower(value)
}


public struct Record {
    public var id: RecordId
    public var revision: UInt64
    public var schemaVersion: String
    public var data: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: RecordId, revision: UInt64, schemaVersion: String, data: [String: String]) {
        self.id = id
        self.revision = revision
        self.schemaVersion = schemaVersion
        self.data = data
    }
}



extension Record: Equatable, Hashable {
    public static func ==(lhs: Record, rhs: Record) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.revision != rhs.revision {
            return false
        }
        if lhs.schemaVersion != rhs.schemaVersion {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(revision)
        hasher.combine(schemaVersion)
        hasher.combine(data)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Record {
        return
            try Record(
                id: FfiConverterTypeRecordId.read(from: &buf), 
                revision: FfiConverterUInt64.read(from: &buf), 
                schemaVersion: FfiConverterString.read(from: &buf), 
                data: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: Record, into buf: inout [UInt8]) {
        FfiConverterTypeRecordId.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.revision, into: &buf)
        FfiConverterString.write(value.schemaVersion, into: &buf)
        FfiConverterDictionaryStringString.write(value.data, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecord_lift(_ buf: RustBuffer) throws -> Record {
    return try FfiConverterTypeRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecord_lower(_ value: Record) -> RustBuffer {
    return FfiConverterTypeRecord.lower(value)
}


public struct RecordChange {
    public var id: RecordId
    public var schemaVersion: String
    public var updatedFields: [String: String]
    public var localRevision: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: RecordId, schemaVersion: String, updatedFields: [String: String], localRevision: UInt64) {
        self.id = id
        self.schemaVersion = schemaVersion
        self.updatedFields = updatedFields
        self.localRevision = localRevision
    }
}



extension RecordChange: Equatable, Hashable {
    public static func ==(lhs: RecordChange, rhs: RecordChange) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.schemaVersion != rhs.schemaVersion {
            return false
        }
        if lhs.updatedFields != rhs.updatedFields {
            return false
        }
        if lhs.localRevision != rhs.localRevision {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(schemaVersion)
        hasher.combine(updatedFields)
        hasher.combine(localRevision)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecordChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecordChange {
        return
            try RecordChange(
                id: FfiConverterTypeRecordId.read(from: &buf), 
                schemaVersion: FfiConverterString.read(from: &buf), 
                updatedFields: FfiConverterDictionaryStringString.read(from: &buf), 
                localRevision: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RecordChange, into buf: inout [UInt8]) {
        FfiConverterTypeRecordId.write(value.id, into: &buf)
        FfiConverterString.write(value.schemaVersion, into: &buf)
        FfiConverterDictionaryStringString.write(value.updatedFields, into: &buf)
        FfiConverterUInt64.write(value.localRevision, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecordChange_lift(_ buf: RustBuffer) throws -> RecordChange {
    return try FfiConverterTypeRecordChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecordChange_lower(_ value: RecordChange) -> RustBuffer {
    return FfiConverterTypeRecordChange.lower(value)
}


public struct RecordId {
    public var type: String
    public var dataId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: String, dataId: String) {
        self.type = type
        self.dataId = dataId
    }
}



extension RecordId: Equatable, Hashable {
    public static func ==(lhs: RecordId, rhs: RecordId) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.dataId != rhs.dataId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(dataId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecordId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecordId {
        return
            try RecordId(
                type: FfiConverterString.read(from: &buf), 
                dataId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RecordId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterString.write(value.dataId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecordId_lift(_ buf: RustBuffer) throws -> RecordId {
    return try FfiConverterTypeRecordId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecordId_lower(_ value: RecordId) -> RustBuffer {
    return FfiConverterTypeRecordId.lower(value)
}


/**
 * FFI-safe representation of a recoverable ECDSA signature (65 bytes: 1 recovery byte + 64 signature bytes)
 */
public struct RecoverableEcdsaSignatureBytes {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}



extension RecoverableEcdsaSignatureBytes: Equatable, Hashable {
    public static func ==(lhs: RecoverableEcdsaSignatureBytes, rhs: RecoverableEcdsaSignatureBytes) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecoverableEcdsaSignatureBytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoverableEcdsaSignatureBytes {
        return
            try RecoverableEcdsaSignatureBytes(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: RecoverableEcdsaSignatureBytes, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoverableEcdsaSignatureBytes_lift(_ buf: RustBuffer) throws -> RecoverableEcdsaSignatureBytes {
    return try FfiConverterTypeRecoverableEcdsaSignatureBytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoverableEcdsaSignatureBytes_lower(_ value: RecoverableEcdsaSignatureBytes) -> RustBuffer {
    return FfiConverterTypeRecoverableEcdsaSignatureBytes.lower(value)
}


public struct RefundDepositRequest {
    public var txid: String
    public var vout: UInt32
    public var destinationAddress: String
    public var fee: Fee

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, destinationAddress: String, fee: Fee) {
        self.txid = txid
        self.vout = vout
        self.destinationAddress = destinationAddress
        self.fee = fee
    }
}



extension RefundDepositRequest: Equatable, Hashable {
    public static func ==(lhs: RefundDepositRequest, rhs: RefundDepositRequest) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.destinationAddress != rhs.destinationAddress {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(destinationAddress)
        hasher.combine(fee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefundDepositRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundDepositRequest {
        return
            try RefundDepositRequest(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                destinationAddress: FfiConverterString.read(from: &buf), 
                fee: FfiConverterTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: RefundDepositRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterString.write(value.destinationAddress, into: &buf)
        FfiConverterTypeFee.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositRequest_lift(_ buf: RustBuffer) throws -> RefundDepositRequest {
    return try FfiConverterTypeRefundDepositRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositRequest_lower(_ value: RefundDepositRequest) -> RustBuffer {
    return FfiConverterTypeRefundDepositRequest.lower(value)
}


public struct RefundDepositResponse {
    public var txId: String
    public var txHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txId: String, txHex: String) {
        self.txId = txId
        self.txHex = txHex
    }
}



extension RefundDepositResponse: Equatable, Hashable {
    public static func ==(lhs: RefundDepositResponse, rhs: RefundDepositResponse) -> Bool {
        if lhs.txId != rhs.txId {
            return false
        }
        if lhs.txHex != rhs.txHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txId)
        hasher.combine(txHex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefundDepositResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundDepositResponse {
        return
            try RefundDepositResponse(
                txId: FfiConverterString.read(from: &buf), 
                txHex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RefundDepositResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txId, into: &buf)
        FfiConverterString.write(value.txHex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositResponse_lift(_ buf: RustBuffer) throws -> RefundDepositResponse {
    return try FfiConverterTypeRefundDepositResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRefundDepositResponse_lower(_ value: RefundDepositResponse) -> RustBuffer {
    return FfiConverterTypeRefundDepositResponse.lower(value)
}


public struct RegisterLightningAddressRequest {
    public var username: String
    public var description: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String, description: String? = nil) {
        self.username = username
        self.description = description
    }
}



extension RegisterLightningAddressRequest: Equatable, Hashable {
    public static func ==(lhs: RegisterLightningAddressRequest, rhs: RegisterLightningAddressRequest) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(description)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRegisterLightningAddressRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterLightningAddressRequest {
        return
            try RegisterLightningAddressRequest(
                username: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterLightningAddressRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRegisterLightningAddressRequest_lift(_ buf: RustBuffer) throws -> RegisterLightningAddressRequest {
    return try FfiConverterTypeRegisterLightningAddressRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRegisterLightningAddressRequest_lower(_ value: RegisterLightningAddressRequest) -> RustBuffer {
    return FfiConverterTypeRegisterLightningAddressRequest.lower(value)
}


public struct RestResponse {
    public var status: UInt16
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(status: UInt16, body: String) {
        self.status = status
        self.body = body
    }
}



extension RestResponse: Equatable, Hashable {
    public static func ==(lhs: RestResponse, rhs: RestResponse) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(body)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRestResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RestResponse {
        return
            try RestResponse(
                status: FfiConverterUInt16.read(from: &buf), 
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RestResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.status, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestResponse_lift(_ buf: RustBuffer) throws -> RestResponse {
    return try FfiConverterTypeRestResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRestResponse_lower(_ value: RestResponse) -> RustBuffer {
    return FfiConverterTypeRestResponse.lower(value)
}


/**
 * FFI-safe representation of a Schnorr signature (64 bytes)
 */
public struct SchnorrSignatureBytes {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}



extension SchnorrSignatureBytes: Equatable, Hashable {
    public static func ==(lhs: SchnorrSignatureBytes, rhs: SchnorrSignatureBytes) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSchnorrSignatureBytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SchnorrSignatureBytes {
        return
            try SchnorrSignatureBytes(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SchnorrSignatureBytes, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSchnorrSignatureBytes_lift(_ buf: RustBuffer) throws -> SchnorrSignatureBytes {
    return try FfiConverterTypeSchnorrSignatureBytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSchnorrSignatureBytes_lower(_ value: SchnorrSignatureBytes) -> RustBuffer {
    return FfiConverterTypeSchnorrSignatureBytes.lower(value)
}


/**
 * FFI-safe representation of a private key (32 bytes)
 */
public struct SecretBytes {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}



extension SecretBytes: Equatable, Hashable {
    public static func ==(lhs: SecretBytes, rhs: SecretBytes) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecretBytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretBytes {
        return
            try SecretBytes(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SecretBytes, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecretBytes_lift(_ buf: RustBuffer) throws -> SecretBytes {
    return try FfiConverterTypeSecretBytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecretBytes_lower(_ value: SecretBytes) -> RustBuffer {
    return FfiConverterTypeSecretBytes.lower(value)
}


public struct SendOnchainFeeQuote {
    public var id: String
    public var expiresAt: UInt64
    public var speedFast: SendOnchainSpeedFeeQuote
    public var speedMedium: SendOnchainSpeedFeeQuote
    public var speedSlow: SendOnchainSpeedFeeQuote

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, expiresAt: UInt64, speedFast: SendOnchainSpeedFeeQuote, speedMedium: SendOnchainSpeedFeeQuote, speedSlow: SendOnchainSpeedFeeQuote) {
        self.id = id
        self.expiresAt = expiresAt
        self.speedFast = speedFast
        self.speedMedium = speedMedium
        self.speedSlow = speedSlow
    }
}



extension SendOnchainFeeQuote: Equatable, Hashable {
    public static func ==(lhs: SendOnchainFeeQuote, rhs: SendOnchainFeeQuote) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        if lhs.speedFast != rhs.speedFast {
            return false
        }
        if lhs.speedMedium != rhs.speedMedium {
            return false
        }
        if lhs.speedSlow != rhs.speedSlow {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(expiresAt)
        hasher.combine(speedFast)
        hasher.combine(speedMedium)
        hasher.combine(speedSlow)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendOnchainFeeQuote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainFeeQuote {
        return
            try SendOnchainFeeQuote(
                id: FfiConverterString.read(from: &buf), 
                expiresAt: FfiConverterUInt64.read(from: &buf), 
                speedFast: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf), 
                speedMedium: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf), 
                speedSlow: FfiConverterTypeSendOnchainSpeedFeeQuote.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainFeeQuote, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterUInt64.write(value.expiresAt, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedFast, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedMedium, into: &buf)
        FfiConverterTypeSendOnchainSpeedFeeQuote.write(value.speedSlow, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainFeeQuote_lift(_ buf: RustBuffer) throws -> SendOnchainFeeQuote {
    return try FfiConverterTypeSendOnchainFeeQuote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainFeeQuote_lower(_ value: SendOnchainFeeQuote) -> RustBuffer {
    return FfiConverterTypeSendOnchainFeeQuote.lower(value)
}


public struct SendOnchainSpeedFeeQuote {
    public var userFeeSat: UInt64
    public var l1BroadcastFeeSat: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userFeeSat: UInt64, l1BroadcastFeeSat: UInt64) {
        self.userFeeSat = userFeeSat
        self.l1BroadcastFeeSat = l1BroadcastFeeSat
    }
}



extension SendOnchainSpeedFeeQuote: Equatable, Hashable {
    public static func ==(lhs: SendOnchainSpeedFeeQuote, rhs: SendOnchainSpeedFeeQuote) -> Bool {
        if lhs.userFeeSat != rhs.userFeeSat {
            return false
        }
        if lhs.l1BroadcastFeeSat != rhs.l1BroadcastFeeSat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userFeeSat)
        hasher.combine(l1BroadcastFeeSat)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendOnchainSpeedFeeQuote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainSpeedFeeQuote {
        return
            try SendOnchainSpeedFeeQuote(
                userFeeSat: FfiConverterUInt64.read(from: &buf), 
                l1BroadcastFeeSat: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainSpeedFeeQuote, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.userFeeSat, into: &buf)
        FfiConverterUInt64.write(value.l1BroadcastFeeSat, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainSpeedFeeQuote_lift(_ buf: RustBuffer) throws -> SendOnchainSpeedFeeQuote {
    return try FfiConverterTypeSendOnchainSpeedFeeQuote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendOnchainSpeedFeeQuote_lower(_ value: SendOnchainSpeedFeeQuote) -> RustBuffer {
    return FfiConverterTypeSendOnchainSpeedFeeQuote.lower(value)
}


public struct SendPaymentRequest {
    public var prepareResponse: PrepareSendPaymentResponse
    public var options: SendPaymentOptions?
    /**
     * The optional idempotency key for all Spark based transfers (excludes token payments).
     * If set, providing the same idempotency key for multiple requests will ensure that only one
     * payment is made. If an idempotency key is re-used, the same payment will be returned.
     * The idempotency key must be a valid UUID.
     */
    public var idempotencyKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(prepareResponse: PrepareSendPaymentResponse, options: SendPaymentOptions? = nil, 
        /**
         * The optional idempotency key for all Spark based transfers (excludes token payments).
         * If set, providing the same idempotency key for multiple requests will ensure that only one
         * payment is made. If an idempotency key is re-used, the same payment will be returned.
         * The idempotency key must be a valid UUID.
         */idempotencyKey: String? = nil) {
        self.prepareResponse = prepareResponse
        self.options = options
        self.idempotencyKey = idempotencyKey
    }
}



extension SendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: SendPaymentRequest, rhs: SendPaymentRequest) -> Bool {
        if lhs.prepareResponse != rhs.prepareResponse {
            return false
        }
        if lhs.options != rhs.options {
            return false
        }
        if lhs.idempotencyKey != rhs.idempotencyKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(prepareResponse)
        hasher.combine(options)
        hasher.combine(idempotencyKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentRequest {
        return
            try SendPaymentRequest(
                prepareResponse: FfiConverterTypePrepareSendPaymentResponse.read(from: &buf), 
                options: FfiConverterOptionTypeSendPaymentOptions.read(from: &buf), 
                idempotencyKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterTypePrepareSendPaymentResponse.write(value.prepareResponse, into: &buf)
        FfiConverterOptionTypeSendPaymentOptions.write(value.options, into: &buf)
        FfiConverterOptionString.write(value.idempotencyKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentRequest_lift(_ buf: RustBuffer) throws -> SendPaymentRequest {
    return try FfiConverterTypeSendPaymentRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentRequest_lower(_ value: SendPaymentRequest) -> RustBuffer {
    return FfiConverterTypeSendPaymentRequest.lower(value)
}


public struct SendPaymentResponse {
    public var payment: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payment: Payment) {
        self.payment = payment
    }
}



extension SendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: SendPaymentResponse, rhs: SendPaymentResponse) -> Bool {
        if lhs.payment != rhs.payment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payment)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentResponse {
        return
            try SendPaymentResponse(
                payment: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.payment, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentResponse_lift(_ buf: RustBuffer) throws -> SendPaymentResponse {
    return try FfiConverterTypeSendPaymentResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentResponse_lower(_ value: SendPaymentResponse) -> RustBuffer {
    return FfiConverterTypeSendPaymentResponse.lower(value)
}


public struct SetLnurlMetadataItem {
    public var paymentHash: String
    public var senderComment: String?
    public var nostrZapRequest: String?
    public var nostrZapReceipt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentHash: String, senderComment: String?, nostrZapRequest: String?, nostrZapReceipt: String?) {
        self.paymentHash = paymentHash
        self.senderComment = senderComment
        self.nostrZapRequest = nostrZapRequest
        self.nostrZapReceipt = nostrZapReceipt
    }
}



extension SetLnurlMetadataItem: Equatable, Hashable {
    public static func ==(lhs: SetLnurlMetadataItem, rhs: SetLnurlMetadataItem) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.senderComment != rhs.senderComment {
            return false
        }
        if lhs.nostrZapRequest != rhs.nostrZapRequest {
            return false
        }
        if lhs.nostrZapReceipt != rhs.nostrZapReceipt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(senderComment)
        hasher.combine(nostrZapRequest)
        hasher.combine(nostrZapReceipt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSetLnurlMetadataItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetLnurlMetadataItem {
        return
            try SetLnurlMetadataItem(
                paymentHash: FfiConverterString.read(from: &buf), 
                senderComment: FfiConverterOptionString.read(from: &buf), 
                nostrZapRequest: FfiConverterOptionString.read(from: &buf), 
                nostrZapReceipt: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SetLnurlMetadataItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.senderComment, into: &buf)
        FfiConverterOptionString.write(value.nostrZapRequest, into: &buf)
        FfiConverterOptionString.write(value.nostrZapReceipt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetLnurlMetadataItem_lift(_ buf: RustBuffer) throws -> SetLnurlMetadataItem {
    return try FfiConverterTypeSetLnurlMetadataItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetLnurlMetadataItem_lower(_ value: SetLnurlMetadataItem) -> RustBuffer {
    return FfiConverterTypeSetLnurlMetadataItem.lower(value)
}


public struct SignMessageRequest {
    public var message: String
    /**
     * If true, the signature will be encoded in compact format instead of DER format
     */
    public var compact: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String, 
        /**
         * If true, the signature will be encoded in compact format instead of DER format
         */compact: Bool) {
        self.message = message
        self.compact = compact
    }
}



extension SignMessageRequest: Equatable, Hashable {
    public static func ==(lhs: SignMessageRequest, rhs: SignMessageRequest) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.compact != rhs.compact {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(compact)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageRequest {
        return
            try SignMessageRequest(
                message: FfiConverterString.read(from: &buf), 
                compact: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterBool.write(value.compact, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageRequest_lift(_ buf: RustBuffer) throws -> SignMessageRequest {
    return try FfiConverterTypeSignMessageRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageRequest_lower(_ value: SignMessageRequest) -> RustBuffer {
    return FfiConverterTypeSignMessageRequest.lower(value)
}


public struct SignMessageResponse {
    public var pubkey: String
    /**
     * The DER or compact hex encoded signature
     */
    public var signature: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pubkey: String, 
        /**
         * The DER or compact hex encoded signature
         */signature: String) {
        self.pubkey = pubkey
        self.signature = signature
    }
}



extension SignMessageResponse: Equatable, Hashable {
    public static func ==(lhs: SignMessageResponse, rhs: SignMessageResponse) -> Bool {
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pubkey)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignMessageResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageResponse {
        return
            try SignMessageResponse(
                pubkey: FfiConverterString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageResponse_lift(_ buf: RustBuffer) throws -> SignMessageResponse {
    return try FfiConverterTypeSignMessageResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignMessageResponse_lower(_ value: SignMessageResponse) -> RustBuffer {
    return FfiConverterTypeSignMessageResponse.lower(value)
}


public struct SilentPaymentAddressDetails {
    public var address: String
    public var network: BitcoinNetwork
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, network: BitcoinNetwork, source: PaymentRequestSource) {
        self.address = address
        self.network = network
        self.source = source
    }
}



extension SilentPaymentAddressDetails: Equatable, Hashable {
    public static func ==(lhs: SilentPaymentAddressDetails, rhs: SilentPaymentAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(network)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSilentPaymentAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SilentPaymentAddressDetails {
        return
            try SilentPaymentAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: SilentPaymentAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSilentPaymentAddressDetails_lift(_ buf: RustBuffer) throws -> SilentPaymentAddressDetails {
    return try FfiConverterTypeSilentPaymentAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSilentPaymentAddressDetails_lower(_ value: SilentPaymentAddressDetails) -> RustBuffer {
    return FfiConverterTypeSilentPaymentAddressDetails.lower(value)
}


public struct SparkAddressDetails {
    /**
     * The raw address string
     */
    public var address: String
    /**
     * The identity public key of the address owner
     */
    public var identityPublicKey: String
    public var network: BitcoinNetwork
    public var source: PaymentRequestSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The raw address string
         */address: String, 
        /**
         * The identity public key of the address owner
         */identityPublicKey: String, network: BitcoinNetwork, source: PaymentRequestSource) {
        self.address = address
        self.identityPublicKey = identityPublicKey
        self.network = network
        self.source = source
    }
}



extension SparkAddressDetails: Equatable, Hashable {
    public static func ==(lhs: SparkAddressDetails, rhs: SparkAddressDetails) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.identityPublicKey != rhs.identityPublicKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(identityPublicKey)
        hasher.combine(network)
        hasher.combine(source)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkAddressDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkAddressDetails {
        return
            try SparkAddressDetails(
                address: FfiConverterString.read(from: &buf), 
                identityPublicKey: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                source: FfiConverterTypePaymentRequestSource.read(from: &buf)
        )
    }

    public static func write(_ value: SparkAddressDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterString.write(value.identityPublicKey, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterTypePaymentRequestSource.write(value.source, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddressDetails_lift(_ buf: RustBuffer) throws -> SparkAddressDetails {
    return try FfiConverterTypeSparkAddressDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkAddressDetails_lower(_ value: SparkAddressDetails) -> RustBuffer {
    return FfiConverterTypeSparkAddressDetails.lower(value)
}


public struct SparkHtlcDetails {
    /**
     * The payment hash of the HTLC
     */
    public var paymentHash: String
    /**
     * The preimage of the HTLC. Empty until receiver has released it.
     */
    public var preimage: String?
    /**
     * The expiry time of the HTLC as a unix timestamp in seconds
     */
    public var expiryTime: UInt64
    /**
     * The HTLC status
     */
    public var status: SparkHtlcStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The payment hash of the HTLC
         */paymentHash: String, 
        /**
         * The preimage of the HTLC. Empty until receiver has released it.
         */preimage: String?, 
        /**
         * The expiry time of the HTLC as a unix timestamp in seconds
         */expiryTime: UInt64, 
        /**
         * The HTLC status
         */status: SparkHtlcStatus) {
        self.paymentHash = paymentHash
        self.preimage = preimage
        self.expiryTime = expiryTime
        self.status = status
    }
}



extension SparkHtlcDetails: Equatable, Hashable {
    public static func ==(lhs: SparkHtlcDetails, rhs: SparkHtlcDetails) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.expiryTime != rhs.expiryTime {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(preimage)
        hasher.combine(expiryTime)
        hasher.combine(status)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkHtlcDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkHtlcDetails {
        return
            try SparkHtlcDetails(
                paymentHash: FfiConverterString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                expiryTime: FfiConverterUInt64.read(from: &buf), 
                status: FfiConverterTypeSparkHtlcStatus.read(from: &buf)
        )
    }

    public static func write(_ value: SparkHtlcDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterUInt64.write(value.expiryTime, into: &buf)
        FfiConverterTypeSparkHtlcStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcDetails_lift(_ buf: RustBuffer) throws -> SparkHtlcDetails {
    return try FfiConverterTypeSparkHtlcDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcDetails_lower(_ value: SparkHtlcDetails) -> RustBuffer {
    return FfiConverterTypeSparkHtlcDetails.lower(value)
}


public struct SparkHtlcOptions {
    /**
     * The payment hash of the HTLC. The receiver will need to provide the associated preimage to claim it.
     */
    public var paymentHash: String
    /**
     * The duration of the HTLC in seconds.
     * After this time, the HTLC will be returned.
     */
    public var expiryDurationSecs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The payment hash of the HTLC. The receiver will need to provide the associated preimage to claim it.
         */paymentHash: String, 
        /**
         * The duration of the HTLC in seconds.
         * After this time, the HTLC will be returned.
         */expiryDurationSecs: UInt64) {
        self.paymentHash = paymentHash
        self.expiryDurationSecs = expiryDurationSecs
    }
}



extension SparkHtlcOptions: Equatable, Hashable {
    public static func ==(lhs: SparkHtlcOptions, rhs: SparkHtlcOptions) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.expiryDurationSecs != rhs.expiryDurationSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(expiryDurationSecs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkHtlcOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkHtlcOptions {
        return
            try SparkHtlcOptions(
                paymentHash: FfiConverterString.read(from: &buf), 
                expiryDurationSecs: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SparkHtlcOptions, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterUInt64.write(value.expiryDurationSecs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcOptions_lift(_ buf: RustBuffer) throws -> SparkHtlcOptions {
    return try FfiConverterTypeSparkHtlcOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcOptions_lower(_ value: SparkHtlcOptions) -> RustBuffer {
    return FfiConverterTypeSparkHtlcOptions.lower(value)
}


public struct SparkInvoiceDetails {
    /**
     * The raw invoice string
     */
    public var invoice: String
    /**
     * The identity public key of the invoice issuer
     */
    public var identityPublicKey: String
    public var network: BitcoinNetwork
    /**
     * Optional amount denominated in sats if `token_identifier` is absent, otherwise in the token base units
     */
    public var amount: U128?
    /**
     * The token identifier of the token payment. Absence indicates a Bitcoin payment.
     */
    public var tokenIdentifier: String?
    /**
     * Optional expiry time as a unix timestamp in seconds. If not provided, the invoice will never expire.
     */
    public var expiryTime: UInt64?
    /**
     * Optional description.
     */
    public var description: String?
    /**
     * If set, the invoice may only be fulfilled by a payer with this public key.
     */
    public var senderPublicKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The raw invoice string
         */invoice: String, 
        /**
         * The identity public key of the invoice issuer
         */identityPublicKey: String, network: BitcoinNetwork, 
        /**
         * Optional amount denominated in sats if `token_identifier` is absent, otherwise in the token base units
         */amount: U128?, 
        /**
         * The token identifier of the token payment. Absence indicates a Bitcoin payment.
         */tokenIdentifier: String?, 
        /**
         * Optional expiry time as a unix timestamp in seconds. If not provided, the invoice will never expire.
         */expiryTime: UInt64?, 
        /**
         * Optional description.
         */description: String?, 
        /**
         * If set, the invoice may only be fulfilled by a payer with this public key.
         */senderPublicKey: String?) {
        self.invoice = invoice
        self.identityPublicKey = identityPublicKey
        self.network = network
        self.amount = amount
        self.tokenIdentifier = tokenIdentifier
        self.expiryTime = expiryTime
        self.description = description
        self.senderPublicKey = senderPublicKey
    }
}



extension SparkInvoiceDetails: Equatable, Hashable {
    public static func ==(lhs: SparkInvoiceDetails, rhs: SparkInvoiceDetails) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.identityPublicKey != rhs.identityPublicKey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        if lhs.expiryTime != rhs.expiryTime {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.senderPublicKey != rhs.senderPublicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(identityPublicKey)
        hasher.combine(network)
        hasher.combine(amount)
        hasher.combine(tokenIdentifier)
        hasher.combine(expiryTime)
        hasher.combine(description)
        hasher.combine(senderPublicKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkInvoiceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkInvoiceDetails {
        return
            try SparkInvoiceDetails(
                invoice: FfiConverterString.read(from: &buf), 
                identityPublicKey: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeBitcoinNetwork.read(from: &buf), 
                amount: FfiConverterOptionTypeu128.read(from: &buf), 
                tokenIdentifier: FfiConverterOptionString.read(from: &buf), 
                expiryTime: FfiConverterOptionUInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                senderPublicKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparkInvoiceDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterString.write(value.identityPublicKey, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.network, into: &buf)
        FfiConverterOptionTypeu128.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.tokenIdentifier, into: &buf)
        FfiConverterOptionUInt64.write(value.expiryTime, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.senderPublicKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoiceDetails_lift(_ buf: RustBuffer) throws -> SparkInvoiceDetails {
    return try FfiConverterTypeSparkInvoiceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoiceDetails_lower(_ value: SparkInvoiceDetails) -> RustBuffer {
    return FfiConverterTypeSparkInvoiceDetails.lower(value)
}


public struct SparkInvoicePaymentDetails {
    /**
     * Represents the spark invoice description
     */
    public var description: String?
    /**
     * The raw spark invoice string
     */
    public var invoice: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Represents the spark invoice description
         */description: String?, 
        /**
         * The raw spark invoice string
         */invoice: String) {
        self.description = description
        self.invoice = invoice
    }
}



extension SparkInvoicePaymentDetails: Equatable, Hashable {
    public static func ==(lhs: SparkInvoicePaymentDetails, rhs: SparkInvoicePaymentDetails) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(invoice)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkInvoicePaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkInvoicePaymentDetails {
        return
            try SparkInvoicePaymentDetails(
                description: FfiConverterOptionString.read(from: &buf), 
                invoice: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SparkInvoicePaymentDetails, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterString.write(value.invoice, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoicePaymentDetails_lift(_ buf: RustBuffer) throws -> SparkInvoicePaymentDetails {
    return try FfiConverterTypeSparkInvoicePaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkInvoicePaymentDetails_lower(_ value: SparkInvoicePaymentDetails) -> RustBuffer {
    return FfiConverterTypeSparkInvoicePaymentDetails.lower(value)
}


/**
 * The status of the Spark network services relevant to the SDK.
 */
public struct SparkStatus {
    /**
     * The worst status across all relevant services.
     */
    public var status: ServiceStatus
    /**
     * The last time the status was updated, as a unix timestamp in seconds.
     */
    public var lastUpdated: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The worst status across all relevant services.
         */status: ServiceStatus, 
        /**
         * The last time the status was updated, as a unix timestamp in seconds.
         */lastUpdated: UInt64) {
        self.status = status
        self.lastUpdated = lastUpdated
    }
}



extension SparkStatus: Equatable, Hashable {
    public static func ==(lhs: SparkStatus, rhs: SparkStatus) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.lastUpdated != rhs.lastUpdated {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(lastUpdated)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkStatus {
        return
            try SparkStatus(
                status: FfiConverterTypeServiceStatus.read(from: &buf), 
                lastUpdated: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SparkStatus, into buf: inout [UInt8]) {
        FfiConverterTypeServiceStatus.write(value.status, into: &buf)
        FfiConverterUInt64.write(value.lastUpdated, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkStatus_lift(_ buf: RustBuffer) throws -> SparkStatus {
    return try FfiConverterTypeSparkStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkStatus_lower(_ value: SparkStatus) -> RustBuffer {
    return FfiConverterTypeSparkStatus.lower(value)
}


/**
 * Configuration for automatic conversion of Bitcoin to stable tokens.
 *
 * When configured, the SDK automatically monitors the Bitcoin balance after each
 * wallet sync. When the balance exceeds the configured threshold plus the reserved
 * amount, the SDK automatically converts the excess balance (above the reserve)
 * to the specified stable token.
 *
 * When the balance is held in a stable token, Bitcoin payments can still be sent.
 * The SDK automatically detects when there's not enough Bitcoin balance to cover a
 * payment and auto-populates the token-to-Bitcoin conversion options to facilitate
 * the payment.
 */
public struct StableBalanceConfig {
    /**
     * The token identifier to convert Bitcoin to (required).
     */
    public var tokenIdentifier: String
    /**
     * The minimum sats balance that triggers auto-conversion.
     *
     * If not provided, uses the minimum from conversion limits.
     * If provided but less than the conversion limit minimum, the limit minimum is used.
     */
    public var thresholdSats: UInt64?
    /**
     * Maximum slippage in basis points (1/100 of a percent).
     *
     * Defaults to 50 bps (0.5%) if not set.
     */
    public var maxSlippageBps: UInt32?
    /**
     * Amount of sats to keep as Bitcoin and not convert to stable tokens.
     *
     * This reserve ensures you can send Bitcoin payments without hitting
     * the minimum conversion limit. Defaults to the conversion minimum if not set.
     */
    public var reservedSats: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The token identifier to convert Bitcoin to (required).
         */tokenIdentifier: String, 
        /**
         * The minimum sats balance that triggers auto-conversion.
         *
         * If not provided, uses the minimum from conversion limits.
         * If provided but less than the conversion limit minimum, the limit minimum is used.
         */thresholdSats: UInt64? = nil, 
        /**
         * Maximum slippage in basis points (1/100 of a percent).
         *
         * Defaults to 50 bps (0.5%) if not set.
         */maxSlippageBps: UInt32? = nil, 
        /**
         * Amount of sats to keep as Bitcoin and not convert to stable tokens.
         *
         * This reserve ensures you can send Bitcoin payments without hitting
         * the minimum conversion limit. Defaults to the conversion minimum if not set.
         */reservedSats: UInt64? = nil) {
        self.tokenIdentifier = tokenIdentifier
        self.thresholdSats = thresholdSats
        self.maxSlippageBps = maxSlippageBps
        self.reservedSats = reservedSats
    }
}



extension StableBalanceConfig: Equatable, Hashable {
    public static func ==(lhs: StableBalanceConfig, rhs: StableBalanceConfig) -> Bool {
        if lhs.tokenIdentifier != rhs.tokenIdentifier {
            return false
        }
        if lhs.thresholdSats != rhs.thresholdSats {
            return false
        }
        if lhs.maxSlippageBps != rhs.maxSlippageBps {
            return false
        }
        if lhs.reservedSats != rhs.reservedSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(tokenIdentifier)
        hasher.combine(thresholdSats)
        hasher.combine(maxSlippageBps)
        hasher.combine(reservedSats)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStableBalanceConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StableBalanceConfig {
        return
            try StableBalanceConfig(
                tokenIdentifier: FfiConverterString.read(from: &buf), 
                thresholdSats: FfiConverterOptionUInt64.read(from: &buf), 
                maxSlippageBps: FfiConverterOptionUInt32.read(from: &buf), 
                reservedSats: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: StableBalanceConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.tokenIdentifier, into: &buf)
        FfiConverterOptionUInt64.write(value.thresholdSats, into: &buf)
        FfiConverterOptionUInt32.write(value.maxSlippageBps, into: &buf)
        FfiConverterOptionUInt64.write(value.reservedSats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStableBalanceConfig_lift(_ buf: RustBuffer) throws -> StableBalanceConfig {
    return try FfiConverterTypeStableBalanceConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStableBalanceConfig_lower(_ value: StableBalanceConfig) -> RustBuffer {
    return FfiConverterTypeStableBalanceConfig.lower(value)
}


/**
 * Settings for the symbol representation of a currency
 */
public struct Symbol {
    public var grapheme: String?
    public var template: String?
    public var rtl: Bool?
    public var position: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(grapheme: String?, template: String?, rtl: Bool?, position: UInt32?) {
        self.grapheme = grapheme
        self.template = template
        self.rtl = rtl
        self.position = position
    }
}



extension Symbol: Equatable, Hashable {
    public static func ==(lhs: Symbol, rhs: Symbol) -> Bool {
        if lhs.grapheme != rhs.grapheme {
            return false
        }
        if lhs.template != rhs.template {
            return false
        }
        if lhs.rtl != rhs.rtl {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(grapheme)
        hasher.combine(template)
        hasher.combine(rtl)
        hasher.combine(position)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSymbol: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Symbol {
        return
            try Symbol(
                grapheme: FfiConverterOptionString.read(from: &buf), 
                template: FfiConverterOptionString.read(from: &buf), 
                rtl: FfiConverterOptionBool.read(from: &buf), 
                position: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Symbol, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.grapheme, into: &buf)
        FfiConverterOptionString.write(value.template, into: &buf)
        FfiConverterOptionBool.write(value.rtl, into: &buf)
        FfiConverterOptionUInt32.write(value.position, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSymbol_lift(_ buf: RustBuffer) throws -> Symbol {
    return try FfiConverterTypeSymbol.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSymbol_lower(_ value: Symbol) -> RustBuffer {
    return FfiConverterTypeSymbol.lower(value)
}


/**
 * Request to sync the wallet with the Spark network
 */
public struct SyncWalletRequest {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension SyncWalletRequest: Equatable, Hashable {
    public static func ==(lhs: SyncWalletRequest, rhs: SyncWalletRequest) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncWalletRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncWalletRequest {
        return
            SyncWalletRequest()
    }

    public static func write(_ value: SyncWalletRequest, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletRequest_lift(_ buf: RustBuffer) throws -> SyncWalletRequest {
    return try FfiConverterTypeSyncWalletRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletRequest_lower(_ value: SyncWalletRequest) -> RustBuffer {
    return FfiConverterTypeSyncWalletRequest.lower(value)
}


/**
 * Response from synchronizing the wallet
 */
public struct SyncWalletResponse {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}



extension SyncWalletResponse: Equatable, Hashable {
    public static func ==(lhs: SyncWalletResponse, rhs: SyncWalletResponse) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncWalletResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncWalletResponse {
        return
            SyncWalletResponse()
    }

    public static func write(_ value: SyncWalletResponse, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletResponse_lift(_ buf: RustBuffer) throws -> SyncWalletResponse {
    return try FfiConverterTypeSyncWalletResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncWalletResponse_lower(_ value: SyncWalletResponse) -> RustBuffer {
    return FfiConverterTypeSyncWalletResponse.lower(value)
}


public struct TokenBalance {
    public var balance: U128
    public var tokenMetadata: TokenMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(balance: U128, tokenMetadata: TokenMetadata) {
        self.balance = balance
        self.tokenMetadata = tokenMetadata
    }
}



extension TokenBalance: Equatable, Hashable {
    public static func ==(lhs: TokenBalance, rhs: TokenBalance) -> Bool {
        if lhs.balance != rhs.balance {
            return false
        }
        if lhs.tokenMetadata != rhs.tokenMetadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balance)
        hasher.combine(tokenMetadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenBalance {
        return
            try TokenBalance(
                balance: FfiConverterTypeu128.read(from: &buf), 
                tokenMetadata: FfiConverterTypeTokenMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: TokenBalance, into buf: inout [UInt8]) {
        FfiConverterTypeu128.write(value.balance, into: &buf)
        FfiConverterTypeTokenMetadata.write(value.tokenMetadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalance_lift(_ buf: RustBuffer) throws -> TokenBalance {
    return try FfiConverterTypeTokenBalance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenBalance_lower(_ value: TokenBalance) -> RustBuffer {
    return FfiConverterTypeTokenBalance.lower(value)
}


public struct TokenMetadata {
    public var identifier: String
    /**
     * Hex representation of the issuer public key
     */
    public var issuerPublicKey: String
    public var name: String
    public var ticker: String
    /**
     * Number of decimals the token uses
     */
    public var decimals: UInt32
    public var maxSupply: U128
    public var isFreezable: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: String, 
        /**
         * Hex representation of the issuer public key
         */issuerPublicKey: String, name: String, ticker: String, 
        /**
         * Number of decimals the token uses
         */decimals: UInt32, maxSupply: U128, isFreezable: Bool) {
        self.identifier = identifier
        self.issuerPublicKey = issuerPublicKey
        self.name = name
        self.ticker = ticker
        self.decimals = decimals
        self.maxSupply = maxSupply
        self.isFreezable = isFreezable
    }
}



extension TokenMetadata: Equatable, Hashable {
    public static func ==(lhs: TokenMetadata, rhs: TokenMetadata) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.issuerPublicKey != rhs.issuerPublicKey {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.ticker != rhs.ticker {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.maxSupply != rhs.maxSupply {
            return false
        }
        if lhs.isFreezable != rhs.isFreezable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(issuerPublicKey)
        hasher.combine(name)
        hasher.combine(ticker)
        hasher.combine(decimals)
        hasher.combine(maxSupply)
        hasher.combine(isFreezable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenMetadata {
        return
            try TokenMetadata(
                identifier: FfiConverterString.read(from: &buf), 
                issuerPublicKey: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                ticker: FfiConverterString.read(from: &buf), 
                decimals: FfiConverterUInt32.read(from: &buf), 
                maxSupply: FfiConverterTypeu128.read(from: &buf), 
                isFreezable: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TokenMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterString.write(value.issuerPublicKey, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.ticker, into: &buf)
        FfiConverterUInt32.write(value.decimals, into: &buf)
        FfiConverterTypeu128.write(value.maxSupply, into: &buf)
        FfiConverterBool.write(value.isFreezable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenMetadata_lift(_ buf: RustBuffer) throws -> TokenMetadata {
    return try FfiConverterTypeTokenMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenMetadata_lower(_ value: TokenMetadata) -> RustBuffer {
    return FfiConverterTypeTokenMetadata.lower(value)
}


public struct TxStatus {
    public var confirmed: Bool
    public var blockHeight: UInt32?
    public var blockTime: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(confirmed: Bool, blockHeight: UInt32?, blockTime: UInt64?) {
        self.confirmed = confirmed
        self.blockHeight = blockHeight
        self.blockTime = blockTime
    }
}



extension TxStatus: Equatable, Hashable {
    public static func ==(lhs: TxStatus, rhs: TxStatus) -> Bool {
        if lhs.confirmed != rhs.confirmed {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.blockTime != rhs.blockTime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(confirmed)
        hasher.combine(blockHeight)
        hasher.combine(blockTime)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxStatus {
        return
            try TxStatus(
                confirmed: FfiConverterBool.read(from: &buf), 
                blockHeight: FfiConverterOptionUInt32.read(from: &buf), 
                blockTime: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TxStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.confirmed, into: &buf)
        FfiConverterOptionUInt32.write(value.blockHeight, into: &buf)
        FfiConverterOptionUInt64.write(value.blockTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lift(_ buf: RustBuffer) throws -> TxStatus {
    return try FfiConverterTypeTxStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxStatus_lower(_ value: TxStatus) -> RustBuffer {
    return FfiConverterTypeTxStatus.lower(value)
}


public struct UnfreezeIssuerTokenRequest {
    public var address: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String) {
        self.address = address
    }
}



extension UnfreezeIssuerTokenRequest: Equatable, Hashable {
    public static func ==(lhs: UnfreezeIssuerTokenRequest, rhs: UnfreezeIssuerTokenRequest) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnfreezeIssuerTokenRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnfreezeIssuerTokenRequest {
        return
            try UnfreezeIssuerTokenRequest(
                address: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UnfreezeIssuerTokenRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfreezeIssuerTokenRequest_lift(_ buf: RustBuffer) throws -> UnfreezeIssuerTokenRequest {
    return try FfiConverterTypeUnfreezeIssuerTokenRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfreezeIssuerTokenRequest_lower(_ value: UnfreezeIssuerTokenRequest) -> RustBuffer {
    return FfiConverterTypeUnfreezeIssuerTokenRequest.lower(value)
}


public struct UnfreezeIssuerTokenResponse {
    public var impactedOutputIds: [String]
    public var impactedTokenAmount: U128

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(impactedOutputIds: [String], impactedTokenAmount: U128) {
        self.impactedOutputIds = impactedOutputIds
        self.impactedTokenAmount = impactedTokenAmount
    }
}



extension UnfreezeIssuerTokenResponse: Equatable, Hashable {
    public static func ==(lhs: UnfreezeIssuerTokenResponse, rhs: UnfreezeIssuerTokenResponse) -> Bool {
        if lhs.impactedOutputIds != rhs.impactedOutputIds {
            return false
        }
        if lhs.impactedTokenAmount != rhs.impactedTokenAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(impactedOutputIds)
        hasher.combine(impactedTokenAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnfreezeIssuerTokenResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnfreezeIssuerTokenResponse {
        return
            try UnfreezeIssuerTokenResponse(
                impactedOutputIds: FfiConverterSequenceString.read(from: &buf), 
                impactedTokenAmount: FfiConverterTypeu128.read(from: &buf)
        )
    }

    public static func write(_ value: UnfreezeIssuerTokenResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.impactedOutputIds, into: &buf)
        FfiConverterTypeu128.write(value.impactedTokenAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfreezeIssuerTokenResponse_lift(_ buf: RustBuffer) throws -> UnfreezeIssuerTokenResponse {
    return try FfiConverterTypeUnfreezeIssuerTokenResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnfreezeIssuerTokenResponse_lower(_ value: UnfreezeIssuerTokenResponse) -> RustBuffer {
    return FfiConverterTypeUnfreezeIssuerTokenResponse.lower(value)
}


public struct UnversionedRecordChange {
    public var id: RecordId
    public var schemaVersion: String
    public var updatedFields: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: RecordId, schemaVersion: String, updatedFields: [String: String]) {
        self.id = id
        self.schemaVersion = schemaVersion
        self.updatedFields = updatedFields
    }
}



extension UnversionedRecordChange: Equatable, Hashable {
    public static func ==(lhs: UnversionedRecordChange, rhs: UnversionedRecordChange) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.schemaVersion != rhs.schemaVersion {
            return false
        }
        if lhs.updatedFields != rhs.updatedFields {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(schemaVersion)
        hasher.combine(updatedFields)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnversionedRecordChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnversionedRecordChange {
        return
            try UnversionedRecordChange(
                id: FfiConverterTypeRecordId.read(from: &buf), 
                schemaVersion: FfiConverterString.read(from: &buf), 
                updatedFields: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: UnversionedRecordChange, into buf: inout [UInt8]) {
        FfiConverterTypeRecordId.write(value.id, into: &buf)
        FfiConverterString.write(value.schemaVersion, into: &buf)
        FfiConverterDictionaryStringString.write(value.updatedFields, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnversionedRecordChange_lift(_ buf: RustBuffer) throws -> UnversionedRecordChange {
    return try FfiConverterTypeUnversionedRecordChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnversionedRecordChange_lower(_ value: UnversionedRecordChange) -> RustBuffer {
    return FfiConverterTypeUnversionedRecordChange.lower(value)
}


public struct UpdateUserSettingsRequest {
    public var sparkPrivateModeEnabled: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sparkPrivateModeEnabled: Bool?) {
        self.sparkPrivateModeEnabled = sparkPrivateModeEnabled
    }
}



extension UpdateUserSettingsRequest: Equatable, Hashable {
    public static func ==(lhs: UpdateUserSettingsRequest, rhs: UpdateUserSettingsRequest) -> Bool {
        if lhs.sparkPrivateModeEnabled != rhs.sparkPrivateModeEnabled {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sparkPrivateModeEnabled)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateUserSettingsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateUserSettingsRequest {
        return
            try UpdateUserSettingsRequest(
                sparkPrivateModeEnabled: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateUserSettingsRequest, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.sparkPrivateModeEnabled, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateUserSettingsRequest_lift(_ buf: RustBuffer) throws -> UpdateUserSettingsRequest {
    return try FfiConverterTypeUpdateUserSettingsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateUserSettingsRequest_lower(_ value: UpdateUserSettingsRequest) -> RustBuffer {
    return FfiConverterTypeUpdateUserSettingsRequest.lower(value)
}


public struct UrlSuccessActionData {
    /**
     * Contents description, up to 144 characters
     */
    public var description: String
    /**
     * URL of the success action
     */
    public var url: String
    /**
     * Indicates the success URL domain matches the LNURL callback domain.
     *
     * See <https://github.com/lnurl/luds/blob/luds/09.md>
     */
    public var matchesCallbackDomain: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Contents description, up to 144 characters
         */description: String, 
        /**
         * URL of the success action
         */url: String, 
        /**
         * Indicates the success URL domain matches the LNURL callback domain.
         *
         * See <https://github.com/lnurl/luds/blob/luds/09.md>
         */matchesCallbackDomain: Bool) {
        self.description = description
        self.url = url
        self.matchesCallbackDomain = matchesCallbackDomain
    }
}



extension UrlSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: UrlSuccessActionData, rhs: UrlSuccessActionData) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.matchesCallbackDomain != rhs.matchesCallbackDomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(matchesCallbackDomain)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUrlSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlSuccessActionData {
        return
            try UrlSuccessActionData(
                description: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                matchesCallbackDomain: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UrlSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterBool.write(value.matchesCallbackDomain, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrlSuccessActionData_lift(_ buf: RustBuffer) throws -> UrlSuccessActionData {
    return try FfiConverterTypeUrlSuccessActionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrlSuccessActionData_lower(_ value: UrlSuccessActionData) -> RustBuffer {
    return FfiConverterTypeUrlSuccessActionData.lower(value)
}


public struct UserSettings {
    public var sparkPrivateModeEnabled: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sparkPrivateModeEnabled: Bool) {
        self.sparkPrivateModeEnabled = sparkPrivateModeEnabled
    }
}



extension UserSettings: Equatable, Hashable {
    public static func ==(lhs: UserSettings, rhs: UserSettings) -> Bool {
        if lhs.sparkPrivateModeEnabled != rhs.sparkPrivateModeEnabled {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sparkPrivateModeEnabled)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserSettings {
        return
            try UserSettings(
                sparkPrivateModeEnabled: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UserSettings, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.sparkPrivateModeEnabled, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserSettings_lift(_ buf: RustBuffer) throws -> UserSettings {
    return try FfiConverterTypeUserSettings.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserSettings_lower(_ value: UserSettings) -> RustBuffer {
    return FfiConverterTypeUserSettings.lower(value)
}


public struct Utxo {
    public var txid: String
    public var vout: UInt32
    public var value: UInt64
    public var status: TxStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: String, vout: UInt32, value: UInt64, status: TxStatus) {
        self.txid = txid
        self.vout = vout
        self.value = value
        self.status = status
    }
}



extension Utxo: Equatable, Hashable {
    public static func ==(lhs: Utxo, rhs: Utxo) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(value)
        hasher.combine(status)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Utxo {
        return
            try Utxo(
                txid: FfiConverterString.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf), 
                value: FfiConverterUInt64.read(from: &buf), 
                status: FfiConverterTypeTxStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Utxo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterUInt64.write(value.value, into: &buf)
        FfiConverterTypeTxStatus.write(value.status, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lift(_ buf: RustBuffer) throws -> Utxo {
    return try FfiConverterTypeUtxo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lower(_ value: Utxo) -> RustBuffer {
    return FfiConverterTypeUtxo.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of decryption of [`AesSuccessActionData`] payload
 */

public enum AesSuccessActionDataResult {
    
    case decrypted(data: AesSuccessActionDataDecrypted
    )
    case errorStatus(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesSuccessActionDataResult: FfiConverterRustBuffer {
    typealias SwiftType = AesSuccessActionDataResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .decrypted(data: try FfiConverterTypeAesSuccessActionDataDecrypted.read(from: &buf)
        )
        
        case 2: return .errorStatus(reason: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AesSuccessActionDataResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .decrypted(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataDecrypted.write(data, into: &buf)
            
        
        case let .errorStatus(reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataResult_lift(_ buf: RustBuffer) throws -> AesSuccessActionDataResult {
    return try FfiConverterTypeAesSuccessActionDataResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesSuccessActionDataResult_lower(_ value: AesSuccessActionDataResult) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionDataResult.lower(value)
}



extension AesSuccessActionDataResult: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Amount {
    
    case bitcoin(amountMsat: UInt64
    )
    /**
     * An amount of currency specified using ISO 4712.
     */
    case currency(
        /**
         * The currency that the amount is denominated in.
         */iso4217Code: String, 
        /**
         * The amount in the currency unit adjusted by the ISO 4712 exponent (e.g., USD cents).
         */fractionalAmount: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin(amountMsat: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .currency(iso4217Code: try FfiConverterString.read(from: &buf), fractionalAmount: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoin(amountMsat):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amountMsat, into: &buf)
            
        
        case let .currency(iso4217Code,fractionalAmount):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(iso4217Code, into: &buf)
            FfiConverterUInt64.write(fractionalAmount, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ buf: RustBuffer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> RustBuffer {
    return FfiConverterTypeAmount.lower(value)
}



extension Amount: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A field of [`ListPaymentsRequest`] when listing payments filtered by asset
 */

public enum AssetFilter {
    
    case bitcoin
    case token(
        /**
         * Optional token identifier to filter by
         */tokenIdentifier: String?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAssetFilter: FfiConverterRustBuffer {
    typealias SwiftType = AssetFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .token(tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case let .token(tokenIdentifier):
            writeInt(&buf, Int32(2))
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetFilter_lift(_ buf: RustBuffer) throws -> AssetFilter {
    return try FfiConverterTypeAssetFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetFilter_lower(_ value: AssetFilter) -> RustBuffer {
    return FfiConverterTypeAssetFilter.lower(value)
}



extension AssetFilter: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BitcoinNetwork {
    
    /**
     * Mainnet
     */
    case bitcoin
    case testnet3
    case testnet4
    case signet
    case regtest
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinNetwork: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet3
        
        case 3: return .testnet4
        
        case 4: return .signet
        
        case 5: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinNetwork, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet3:
            writeInt(&buf, Int32(2))
        
        
        case .testnet4:
            writeInt(&buf, Int32(3))
        
        
        case .signet:
            writeInt(&buf, Int32(4))
        
        
        case .regtest:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinNetwork_lift(_ buf: RustBuffer) throws -> BitcoinNetwork {
    return try FfiConverterTypeBitcoinNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinNetwork_lower(_ value: BitcoinNetwork) -> RustBuffer {
    return FfiConverterTypeBitcoinNetwork.lower(value)
}



extension BitcoinNetwork: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ChainApiType {
    
    case esplora
    case mempoolSpace
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainApiType: FfiConverterRustBuffer {
    typealias SwiftType = ChainApiType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainApiType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .esplora
        
        case 2: return .mempoolSpace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChainApiType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .esplora:
            writeInt(&buf, Int32(1))
        
        
        case .mempoolSpace:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainApiType_lift(_ buf: RustBuffer) throws -> ChainApiType {
    return try FfiConverterTypeChainApiType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainApiType_lower(_ value: ChainApiType) -> RustBuffer {
    return FfiConverterTypeChainApiType.lower(value)
}



extension ChainApiType: Equatable, Hashable {}




public enum ChainServiceError {

    
    
    case InvalidAddress(String
    )
    case ServiceConnectivity(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainServiceError: FfiConverterRustBuffer {
    typealias SwiftType = ChainServiceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainServiceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidAddress(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ServiceConnectivity(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChainServiceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ServiceConnectivity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ChainServiceError: Equatable, Hashable {}

extension ChainServiceError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The purpose of the conversion, which is used to provide context for the conversion
 * if its related to an ongoing payment or a self-transfer.
 */

public enum ConversionPurpose {
    
    /**
     * Conversion is associated with an ongoing payment
     */
    case ongoingPayment(
        /**
         * The payment request of the ongoing payment
         */paymentRequest: String
    )
    /**
     * Conversion is for self-transfer
     */
    case selfTransfer
    /**
     * Conversion triggered automatically
     */
    case autoConversion
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversionPurpose: FfiConverterRustBuffer {
    typealias SwiftType = ConversionPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversionPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ongoingPayment(paymentRequest: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .selfTransfer
        
        case 3: return .autoConversion
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConversionPurpose, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ongoingPayment(paymentRequest):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(paymentRequest, into: &buf)
            
        
        case .selfTransfer:
            writeInt(&buf, Int32(2))
        
        
        case .autoConversion:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionPurpose_lift(_ buf: RustBuffer) throws -> ConversionPurpose {
    return try FfiConverterTypeConversionPurpose.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionPurpose_lower(_ value: ConversionPurpose) -> RustBuffer {
    return FfiConverterTypeConversionPurpose.lower(value)
}



extension ConversionPurpose: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The status of the conversion
 */

public enum ConversionStatus {
    
    /**
     * The conversion was successful
     */
    case completed
    /**
     * The conversion failed and no refund was made yet, which requires action by the SDK to
     * perform the refund. This can happen if there was a failure during the conversion process.
     */
    case refundNeeded
    /**
     * The conversion failed and a refund was made
     */
    case refunded
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversionStatus: FfiConverterRustBuffer {
    typealias SwiftType = ConversionStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversionStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .completed
        
        case 2: return .refundNeeded
        
        case 3: return .refunded
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConversionStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .completed:
            writeInt(&buf, Int32(1))
        
        
        case .refundNeeded:
            writeInt(&buf, Int32(2))
        
        
        case .refunded:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionStatus_lift(_ buf: RustBuffer) throws -> ConversionStatus {
    return try FfiConverterTypeConversionStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionStatus_lower(_ value: ConversionStatus) -> RustBuffer {
    return FfiConverterTypeConversionStatus.lower(value)
}



extension ConversionStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConversionType {
    
    /**
     * Converting from Bitcoin to a token
     */
    case fromBitcoin
    /**
     * Converting from a token to Bitcoin
     */
    case toBitcoin(fromTokenIdentifier: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConversionType: FfiConverterRustBuffer {
    typealias SwiftType = ConversionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConversionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fromBitcoin
        
        case 2: return .toBitcoin(fromTokenIdentifier: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConversionType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fromBitcoin:
            writeInt(&buf, Int32(1))
        
        
        case let .toBitcoin(fromTokenIdentifier):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(fromTokenIdentifier, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionType_lift(_ buf: RustBuffer) throws -> ConversionType {
    return try FfiConverterTypeConversionType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConversionType_lower(_ value: ConversionType) -> RustBuffer {
    return FfiConverterTypeConversionType.lower(value)
}



extension ConversionType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DepositClaimError {
    
    case maxDepositClaimFeeExceeded(tx: String, vout: UInt32, maxFee: Fee?, requiredFeeSats: UInt64, requiredFeeRateSatPerVbyte: UInt64
    )
    case missingUtxo(tx: String, vout: UInt32
    )
    case generic(message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositClaimError: FfiConverterRustBuffer {
    typealias SwiftType = DepositClaimError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositClaimError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .maxDepositClaimFeeExceeded(tx: try FfiConverterString.read(from: &buf), vout: try FfiConverterUInt32.read(from: &buf), maxFee: try FfiConverterOptionTypeFee.read(from: &buf), requiredFeeSats: try FfiConverterUInt64.read(from: &buf), requiredFeeRateSatPerVbyte: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .missingUtxo(tx: try FfiConverterString.read(from: &buf), vout: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .generic(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositClaimError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .maxDepositClaimFeeExceeded(tx,vout,maxFee,requiredFeeSats,requiredFeeRateSatPerVbyte):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            FfiConverterOptionTypeFee.write(maxFee, into: &buf)
            FfiConverterUInt64.write(requiredFeeSats, into: &buf)
            FfiConverterUInt64.write(requiredFeeRateSatPerVbyte, into: &buf)
            
        
        case let .missingUtxo(tx,vout):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            
        
        case let .generic(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositClaimError_lift(_ buf: RustBuffer) throws -> DepositClaimError {
    return try FfiConverterTypeDepositClaimError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositClaimError_lower(_ value: DepositClaimError) -> RustBuffer {
    return FfiConverterTypeDepositClaimError.lower(value)
}



extension DepositClaimError: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe representation of `spark_wallet::SecretSource`
 */

public enum ExternalSecretSource {
    
    /**
     * Private key derived from a tree node
     */
    case derived(nodeId: ExternalTreeNodeId
    )
    /**
     * Encrypted private key
     */
    case encrypted(key: ExternalEncryptedSecret
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalSecretSource: FfiConverterRustBuffer {
    typealias SwiftType = ExternalSecretSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalSecretSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .derived(nodeId: try FfiConverterTypeExternalTreeNodeId.read(from: &buf)
        )
        
        case 2: return .encrypted(key: try FfiConverterTypeExternalEncryptedSecret.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExternalSecretSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .derived(nodeId):
            writeInt(&buf, Int32(1))
            FfiConverterTypeExternalTreeNodeId.write(nodeId, into: &buf)
            
        
        case let .encrypted(key):
            writeInt(&buf, Int32(2))
            FfiConverterTypeExternalEncryptedSecret.write(key, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSecretSource_lift(_ buf: RustBuffer) throws -> ExternalSecretSource {
    return try FfiConverterTypeExternalSecretSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSecretSource_lower(_ value: ExternalSecretSource) -> RustBuffer {
    return FfiConverterTypeExternalSecretSource.lower(value)
}



extension ExternalSecretSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * FFI-safe representation of `spark_wallet::SecretToSplit`
 */

public enum ExternalSecretToSplit {
    
    /**
     * A secret source to split
     */
    case secretSource(source: ExternalSecretSource
    )
    /**
     * A preimage to split (32 bytes)
     */
    case preimage(data: Data
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExternalSecretToSplit: FfiConverterRustBuffer {
    typealias SwiftType = ExternalSecretToSplit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalSecretToSplit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secretSource(source: try FfiConverterTypeExternalSecretSource.read(from: &buf)
        )
        
        case 2: return .preimage(data: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExternalSecretToSplit, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secretSource(source):
            writeInt(&buf, Int32(1))
            FfiConverterTypeExternalSecretSource.write(source, into: &buf)
            
        
        case let .preimage(data):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(data, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSecretToSplit_lift(_ buf: RustBuffer) throws -> ExternalSecretToSplit {
    return try FfiConverterTypeExternalSecretToSplit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExternalSecretToSplit_lower(_ value: ExternalSecretToSplit) -> RustBuffer {
    return FfiConverterTypeExternalSecretToSplit.lower(value)
}



extension ExternalSecretToSplit: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Fee {
    
    case fixed(amount: UInt64
    )
    case rate(satPerVbyte: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFee: FfiConverterRustBuffer {
    typealias SwiftType = Fee

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fee {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fixed(amount: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .rate(satPerVbyte: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Fee, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fixed(amount):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amount, into: &buf)
            
        
        case let .rate(satPerVbyte):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(satPerVbyte, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lift(_ buf: RustBuffer) throws -> Fee {
    return try FfiConverterTypeFee.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lower(_ value: Fee) -> RustBuffer {
    return FfiConverterTypeFee.lower(value)
}



extension Fee: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Specifies how fees are handled in a payment.
 */

public enum FeePolicy {
    
    /**
     * Fees are added on top of the specified amount (default behavior).
     * The receiver gets the exact amount specified.
     */
    case feesExcluded
    /**
     * Fees are deducted from the specified amount.
     * The receiver gets the amount minus fees.
     */
    case feesIncluded
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeePolicy: FfiConverterRustBuffer {
    typealias SwiftType = FeePolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeePolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .feesExcluded
        
        case 2: return .feesIncluded
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeePolicy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .feesExcluded:
            writeInt(&buf, Int32(1))
        
        
        case .feesIncluded:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeePolicy_lift(_ buf: RustBuffer) throws -> FeePolicy {
    return try FfiConverterTypeFeePolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeePolicy_lower(_ value: FeePolicy) -> RustBuffer {
    return FfiConverterTypeFeePolicy.lower(value)
}



extension FeePolicy: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum InputType {
    
    case bitcoinAddress(BitcoinAddressDetails
    )
    case bolt11Invoice(Bolt11InvoiceDetails
    )
    case bolt12Invoice(Bolt12InvoiceDetails
    )
    case bolt12Offer(Bolt12OfferDetails
    )
    case lightningAddress(LightningAddressDetails
    )
    case lnurlPay(LnurlPayRequestDetails
    )
    case silentPaymentAddress(SilentPaymentAddressDetails
    )
    case lnurlAuth(LnurlAuthRequestDetails
    )
    case url(String
    )
    case bip21(Bip21Details
    )
    case bolt12InvoiceRequest(Bolt12InvoiceRequestDetails
    )
    case lnurlWithdraw(LnurlWithdrawRequestDetails
    )
    case sparkAddress(SparkAddressDetails
    )
    case sparkInvoice(SparkInvoiceDetails
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = InputType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(try FfiConverterTypeBitcoinAddressDetails.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(try FfiConverterTypeBolt11InvoiceDetails.read(from: &buf)
        )
        
        case 3: return .bolt12Invoice(try FfiConverterTypeBolt12InvoiceDetails.read(from: &buf)
        )
        
        case 4: return .bolt12Offer(try FfiConverterTypeBolt12OfferDetails.read(from: &buf)
        )
        
        case 5: return .lightningAddress(try FfiConverterTypeLightningAddressDetails.read(from: &buf)
        )
        
        case 6: return .lnurlPay(try FfiConverterTypeLnurlPayRequestDetails.read(from: &buf)
        )
        
        case 7: return .silentPaymentAddress(try FfiConverterTypeSilentPaymentAddressDetails.read(from: &buf)
        )
        
        case 8: return .lnurlAuth(try FfiConverterTypeLnurlAuthRequestDetails.read(from: &buf)
        )
        
        case 9: return .url(try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .bip21(try FfiConverterTypeBip21Details.read(from: &buf)
        )
        
        case 11: return .bolt12InvoiceRequest(try FfiConverterTypeBolt12InvoiceRequestDetails.read(from: &buf)
        )
        
        case 12: return .lnurlWithdraw(try FfiConverterTypeLnurlWithdrawRequestDetails.read(from: &buf)
        )
        
        case 13: return .sparkAddress(try FfiConverterTypeSparkAddressDetails.read(from: &buf)
        )
        
        case 14: return .sparkInvoice(try FfiConverterTypeSparkInvoiceDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InputType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressDetails.write(v1, into: &buf)
            
        
        case let .bolt11Invoice(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBolt11InvoiceDetails.write(v1, into: &buf)
            
        
        case let .bolt12Invoice(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBolt12InvoiceDetails.write(v1, into: &buf)
            
        
        case let .bolt12Offer(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBolt12OfferDetails.write(v1, into: &buf)
            
        
        case let .lightningAddress(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeLightningAddressDetails.write(v1, into: &buf)
            
        
        case let .lnurlPay(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLnurlPayRequestDetails.write(v1, into: &buf)
            
        
        case let .silentPaymentAddress(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeSilentPaymentAddressDetails.write(v1, into: &buf)
            
        
        case let .lnurlAuth(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeLnurlAuthRequestDetails.write(v1, into: &buf)
            
        
        case let .url(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .bip21(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeBip21Details.write(v1, into: &buf)
            
        
        case let .bolt12InvoiceRequest(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeBolt12InvoiceRequestDetails.write(v1, into: &buf)
            
        
        case let .lnurlWithdraw(v1):
            writeInt(&buf, Int32(12))
            FfiConverterTypeLnurlWithdrawRequestDetails.write(v1, into: &buf)
            
        
        case let .sparkAddress(v1):
            writeInt(&buf, Int32(13))
            FfiConverterTypeSparkAddressDetails.write(v1, into: &buf)
            
        
        case let .sparkInvoice(v1):
            writeInt(&buf, Int32(14))
            FfiConverterTypeSparkInvoiceDetails.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputType_lift(_ buf: RustBuffer) throws -> InputType {
    return try FfiConverterTypeInputType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputType_lower(_ value: InputType) -> RustBuffer {
    return FfiConverterTypeInputType.lower(value)
}



extension InputType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum KeySetType {
    
    case `default`
    case taproot
    case nativeSegwit
    case wrappedSegwit
    case legacy
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeySetType: FfiConverterRustBuffer {
    typealias SwiftType = KeySetType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySetType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .taproot
        
        case 3: return .nativeSegwit
        
        case 4: return .wrappedSegwit
        
        case 5: return .legacy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeySetType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .taproot:
            writeInt(&buf, Int32(2))
        
        
        case .nativeSegwit:
            writeInt(&buf, Int32(3))
        
        
        case .wrappedSegwit:
            writeInt(&buf, Int32(4))
        
        
        case .legacy:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySetType_lift(_ buf: RustBuffer) throws -> KeySetType {
    return try FfiConverterTypeKeySetType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySetType_lower(_ value: KeySetType) -> RustBuffer {
    return FfiConverterTypeKeySetType.lower(value)
}



extension KeySetType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The response from a LNURL-auth callback, indicating success or failure.
 */

public enum LnurlCallbackStatus {
    
    /**
     * On-wire format is: `{"status": "OK"}`
     */
    case ok
    /**
     * On-wire format is: `{"status": "ERROR", "reason": "error details..."}`
     */
    case errorStatus(errorDetails: LnurlErrorDetails
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLnurlCallbackStatus: FfiConverterRustBuffer {
    typealias SwiftType = LnurlCallbackStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnurlCallbackStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ok
        
        case 2: return .errorStatus(errorDetails: try FfiConverterTypeLnurlErrorDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnurlCallbackStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ok:
            writeInt(&buf, Int32(1))
        
        
        case let .errorStatus(errorDetails):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnurlErrorDetails.write(errorDetails, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlCallbackStatus_lift(_ buf: RustBuffer) throws -> LnurlCallbackStatus {
    return try FfiConverterTypeLnurlCallbackStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLnurlCallbackStatus_lower(_ value: LnurlCallbackStatus) -> RustBuffer {
    return FfiConverterTypeLnurlCallbackStatus.lower(value)
}



extension LnurlCallbackStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MaxFee {
    
    case fixed(amount: UInt64
    )
    case rate(satPerVbyte: UInt64
    )
    case networkRecommended(leewaySatPerVbyte: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMaxFee: FfiConverterRustBuffer {
    typealias SwiftType = MaxFee

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxFee {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fixed(amount: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .rate(satPerVbyte: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .networkRecommended(leewaySatPerVbyte: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxFee, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fixed(amount):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amount, into: &buf)
            
        
        case let .rate(satPerVbyte):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(satPerVbyte, into: &buf)
            
        
        case let .networkRecommended(leewaySatPerVbyte):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(leewaySatPerVbyte, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMaxFee_lift(_ buf: RustBuffer) throws -> MaxFee {
    return try FfiConverterTypeMaxFee.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMaxFee_lower(_ value: MaxFee) -> RustBuffer {
    return FfiConverterTypeMaxFee.lower(value)
}



extension MaxFee: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case mainnet
    case regtest
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .regtest:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



extension Network: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OnchainConfirmationSpeed {
    
    case fast
    case medium
    case slow
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnchainConfirmationSpeed: FfiConverterRustBuffer {
    typealias SwiftType = OnchainConfirmationSpeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainConfirmationSpeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fast
        
        case 2: return .medium
        
        case 3: return .slow
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OnchainConfirmationSpeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fast:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .slow:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainConfirmationSpeed_lift(_ buf: RustBuffer) throws -> OnchainConfirmationSpeed {
    return try FfiConverterTypeOnchainConfirmationSpeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainConfirmationSpeed_lower(_ value: OnchainConfirmationSpeed) -> RustBuffer {
    return FfiConverterTypeOnchainConfirmationSpeed.lower(value)
}



extension OnchainConfirmationSpeed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OptimizationEvent {
    
    /**
     * Optimization has started with the given number of rounds.
     */
    case started(totalRounds: UInt32
    )
    /**
     * A round has completed.
     */
    case roundCompleted(currentRound: UInt32, totalRounds: UInt32
    )
    /**
     * Optimization completed successfully.
     */
    case completed
    /**
     * Optimization was cancelled.
     */
    case cancelled
    /**
     * Optimization failed with an error.
     */
    case failed(error: String
    )
    /**
     * Optimization was skipped because leaves are already optimal.
     */
    case skipped
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOptimizationEvent: FfiConverterRustBuffer {
    typealias SwiftType = OptimizationEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OptimizationEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .started(totalRounds: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .roundCompleted(currentRound: try FfiConverterUInt32.read(from: &buf), totalRounds: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .completed
        
        case 4: return .cancelled
        
        case 5: return .failed(error: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .skipped
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OptimizationEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .started(totalRounds):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(totalRounds, into: &buf)
            
        
        case let .roundCompleted(currentRound,totalRounds):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(currentRound, into: &buf)
            FfiConverterUInt32.write(totalRounds, into: &buf)
            
        
        case .completed:
            writeInt(&buf, Int32(3))
        
        
        case .cancelled:
            writeInt(&buf, Int32(4))
        
        
        case let .failed(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        
        case .skipped:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOptimizationEvent_lift(_ buf: RustBuffer) throws -> OptimizationEvent {
    return try FfiConverterTypeOptimizationEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOptimizationEvent_lower(_ value: OptimizationEvent) -> RustBuffer {
    return FfiConverterTypeOptimizationEvent.lower(value)
}



extension OptimizationEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentDetails {
    
    case spark(
        /**
         * The invoice details if the payment fulfilled a spark invoice
         */invoiceDetails: SparkInvoicePaymentDetails?, 
        /**
         * The HTLC transfer details if the payment fulfilled an HTLC transfer
         */htlcDetails: SparkHtlcDetails?, 
        /**
         * The information for a conversion
         */conversionInfo: ConversionInfo?
    )
    case token(metadata: TokenMetadata, txHash: String, txType: TokenTransactionType, 
        /**
         * The invoice details if the payment fulfilled a spark invoice
         */invoiceDetails: SparkInvoicePaymentDetails?, 
        /**
         * The information for a conversion
         */conversionInfo: ConversionInfo?
    )
    case lightning(
        /**
         * Represents the invoice description
         */description: String?, 
        /**
         * Represents the Bolt11/Bolt12 invoice associated with a payment
         * In the case of a Send payment, this is the invoice paid by the user
         * In the case of a Receive payment, this is the invoice paid to the user
         */invoice: String, 
        /**
         * The invoice destination/payee pubkey
         */destinationPubkey: String, 
        /**
         * The HTLC transfer details
         */htlcDetails: SparkHtlcDetails, 
        /**
         * Lnurl payment information if this was an lnurl payment.
         */lnurlPayInfo: LnurlPayInfo?, 
        /**
         * Lnurl withdrawal information if this was an lnurl payment.
         */lnurlWithdrawInfo: LnurlWithdrawInfo?, 
        /**
         * Lnurl receive information if this was a received lnurl payment.
         */lnurlReceiveMetadata: LnurlReceiveMetadata?
    )
    case withdraw(txId: String
    )
    case deposit(txId: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .spark(invoiceDetails: try FfiConverterOptionTypeSparkInvoicePaymentDetails.read(from: &buf), htlcDetails: try FfiConverterOptionTypeSparkHtlcDetails.read(from: &buf), conversionInfo: try FfiConverterOptionTypeConversionInfo.read(from: &buf)
        )
        
        case 2: return .token(metadata: try FfiConverterTypeTokenMetadata.read(from: &buf), txHash: try FfiConverterString.read(from: &buf), txType: try FfiConverterTypeTokenTransactionType.read(from: &buf), invoiceDetails: try FfiConverterOptionTypeSparkInvoicePaymentDetails.read(from: &buf), conversionInfo: try FfiConverterOptionTypeConversionInfo.read(from: &buf)
        )
        
        case 3: return .lightning(description: try FfiConverterOptionString.read(from: &buf), invoice: try FfiConverterString.read(from: &buf), destinationPubkey: try FfiConverterString.read(from: &buf), htlcDetails: try FfiConverterTypeSparkHtlcDetails.read(from: &buf), lnurlPayInfo: try FfiConverterOptionTypeLnurlPayInfo.read(from: &buf), lnurlWithdrawInfo: try FfiConverterOptionTypeLnurlWithdrawInfo.read(from: &buf), lnurlReceiveMetadata: try FfiConverterOptionTypeLnurlReceiveMetadata.read(from: &buf)
        )
        
        case 4: return .withdraw(txId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .deposit(txId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .spark(invoiceDetails,htlcDetails,conversionInfo):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeSparkInvoicePaymentDetails.write(invoiceDetails, into: &buf)
            FfiConverterOptionTypeSparkHtlcDetails.write(htlcDetails, into: &buf)
            FfiConverterOptionTypeConversionInfo.write(conversionInfo, into: &buf)
            
        
        case let .token(metadata,txHash,txType,invoiceDetails,conversionInfo):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTokenMetadata.write(metadata, into: &buf)
            FfiConverterString.write(txHash, into: &buf)
            FfiConverterTypeTokenTransactionType.write(txType, into: &buf)
            FfiConverterOptionTypeSparkInvoicePaymentDetails.write(invoiceDetails, into: &buf)
            FfiConverterOptionTypeConversionInfo.write(conversionInfo, into: &buf)
            
        
        case let .lightning(description,invoice,destinationPubkey,htlcDetails,lnurlPayInfo,lnurlWithdrawInfo,lnurlReceiveMetadata):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterString.write(invoice, into: &buf)
            FfiConverterString.write(destinationPubkey, into: &buf)
            FfiConverterTypeSparkHtlcDetails.write(htlcDetails, into: &buf)
            FfiConverterOptionTypeLnurlPayInfo.write(lnurlPayInfo, into: &buf)
            FfiConverterOptionTypeLnurlWithdrawInfo.write(lnurlWithdrawInfo, into: &buf)
            FfiConverterOptionTypeLnurlReceiveMetadata.write(lnurlReceiveMetadata, into: &buf)
            
        
        case let .withdraw(txId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(txId, into: &buf)
            
        
        case let .deposit(txId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(txId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}



extension PaymentDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentDetailsFilter {
    
    case spark(
        /**
         * Filter specific Spark HTLC statuses
         */htlcStatus: [SparkHtlcStatus]?, 
        /**
         * Filter conversion payments with refund information
         */conversionRefundNeeded: Bool?
    )
    case token(
        /**
         * Filter conversion payments with refund information
         */conversionRefundNeeded: Bool?, 
        /**
         * Filter by transaction hash
         */txHash: String?, 
        /**
         * Filter by transaction type
         */txType: TokenTransactionType?
    )
    case lightning(
        /**
         * Filter specific Spark HTLC statuses
         */htlcStatus: [SparkHtlcStatus]?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentDetailsFilter: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetailsFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetailsFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .spark(htlcStatus: try FfiConverterOptionSequenceTypeSparkHtlcStatus.read(from: &buf), conversionRefundNeeded: try FfiConverterOptionBool.read(from: &buf)
        )
        
        case 2: return .token(conversionRefundNeeded: try FfiConverterOptionBool.read(from: &buf), txHash: try FfiConverterOptionString.read(from: &buf), txType: try FfiConverterOptionTypeTokenTransactionType.read(from: &buf)
        )
        
        case 3: return .lightning(htlcStatus: try FfiConverterOptionSequenceTypeSparkHtlcStatus.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDetailsFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .spark(htlcStatus,conversionRefundNeeded):
            writeInt(&buf, Int32(1))
            FfiConverterOptionSequenceTypeSparkHtlcStatus.write(htlcStatus, into: &buf)
            FfiConverterOptionBool.write(conversionRefundNeeded, into: &buf)
            
        
        case let .token(conversionRefundNeeded,txHash,txType):
            writeInt(&buf, Int32(2))
            FfiConverterOptionBool.write(conversionRefundNeeded, into: &buf)
            FfiConverterOptionString.write(txHash, into: &buf)
            FfiConverterOptionTypeTokenTransactionType.write(txType, into: &buf)
            
        
        case let .lightning(htlcStatus):
            writeInt(&buf, Int32(3))
            FfiConverterOptionSequenceTypeSparkHtlcStatus.write(htlcStatus, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetailsFilter_lift(_ buf: RustBuffer) throws -> PaymentDetailsFilter {
    return try FfiConverterTypePaymentDetailsFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetailsFilter_lower(_ value: PaymentDetailsFilter) -> RustBuffer {
    return FfiConverterTypePaymentDetailsFilter.lower(value)
}



extension PaymentDetailsFilter: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentMethod {
    
    case lightning
    case spark
    case token
    case deposit
    case withdraw
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = PaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .lightning
        
        case 2: return .spark
        
        case 3: return .token
        
        case 4: return .deposit
        
        case 5: return .withdraw
        
        case 6: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .lightning:
            writeInt(&buf, Int32(1))
        
        
        case .spark:
            writeInt(&buf, Int32(2))
        
        
        case .token:
            writeInt(&buf, Int32(3))
        
        
        case .deposit:
            writeInt(&buf, Int32(4))
        
        
        case .withdraw:
            writeInt(&buf, Int32(5))
        
        
        case .unknown:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lift(_ buf: RustBuffer) throws -> PaymentMethod {
    return try FfiConverterTypePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentMethod_lower(_ value: PaymentMethod) -> RustBuffer {
    return FfiConverterTypePaymentMethod.lower(value)
}



extension PaymentMethod: Equatable, Hashable {}




public enum PaymentObserverError {

    
    
    case ServiceConnectivity(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentObserverError: FfiConverterRustBuffer {
    typealias SwiftType = PaymentObserverError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentObserverError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ServiceConnectivity(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentObserverError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ServiceConnectivity(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension PaymentObserverError: Equatable, Hashable {}

extension PaymentObserverError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The status of a payment
 */

public enum PaymentStatus {
    
    /**
     * Payment is completed successfully
     */
    case completed
    /**
     * Payment is in progress
     */
    case pending
    /**
     * Payment has failed
     */
    case failed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .completed
        
        case 2: return .pending
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .completed:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}



extension PaymentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of payment
 */

public enum PaymentType {
    
    /**
     * Payment sent from this wallet
     */
    case send
    /**
     * Payment received to this wallet
     */
    case receive
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .send
        
        case 2: return .receive
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .send:
            writeInt(&buf, Int32(1))
        
        
        case .receive:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentType_lift(_ buf: RustBuffer) throws -> PaymentType {
    return try FfiConverterTypePaymentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentType_lower(_ value: PaymentType) -> RustBuffer {
    return FfiConverterTypePaymentType.lower(value)
}



extension PaymentType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Queue mode for the connection pool.
 *
 * Determines the order in which connections are retrieved from the pool.
 */

public enum PoolQueueMode {
    
    /**
     * First In, First Out (default).
     * Connections are used in the order they were returned to the pool.
     * Spreads load evenly across all connections.
     */
    case fifo
    /**
     * Last In, First Out.
     * Most recently returned connections are used first.
     * Keeps fewer connections "hot" and allows idle connections to close sooner.
     */
    case lifo
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePoolQueueMode: FfiConverterRustBuffer {
    typealias SwiftType = PoolQueueMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolQueueMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fifo
        
        case 2: return .lifo
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PoolQueueMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fifo:
            writeInt(&buf, Int32(1))
        
        
        case .lifo:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoolQueueMode_lift(_ buf: RustBuffer) throws -> PoolQueueMode {
    return try FfiConverterTypePoolQueueMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoolQueueMode_lower(_ value: PoolQueueMode) -> RustBuffer {
    return FfiConverterTypePoolQueueMode.lower(value)
}



extension PoolQueueMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProvisionalPaymentDetails {
    
    case bitcoin(
        /**
         * Onchain Bitcoin address
         */withdrawalAddress: String
    )
    case lightning(
        /**
         * BOLT11 invoice
         */invoice: String
    )
    case spark(
        /**
         * Spark pay request being paid (either a Spark address or a Spark invoice)
         */payRequest: String
    )
    case token(
        /**
         * Token identifier
         */tokenId: String, 
        /**
         * Spark pay request being paid (either a Spark address or a Spark invoice)
         */payRequest: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProvisionalPaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProvisionalPaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProvisionalPaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin(withdrawalAddress: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .lightning(invoice: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .spark(payRequest: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .token(tokenId: try FfiConverterString.read(from: &buf), payRequest: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProvisionalPaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoin(withdrawalAddress):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(withdrawalAddress, into: &buf)
            
        
        case let .lightning(invoice):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(invoice, into: &buf)
            
        
        case let .spark(payRequest):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(payRequest, into: &buf)
            
        
        case let .token(tokenId,payRequest):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(tokenId, into: &buf)
            FfiConverterString.write(payRequest, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPaymentDetails_lift(_ buf: RustBuffer) throws -> ProvisionalPaymentDetails {
    return try FfiConverterTypeProvisionalPaymentDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalPaymentDetails_lower(_ value: ProvisionalPaymentDetails) -> RustBuffer {
    return FfiConverterTypeProvisionalPaymentDetails.lower(value)
}



extension ProvisionalPaymentDetails: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ReceivePaymentMethod {
    
    case sparkAddress
    case sparkInvoice(
        /**
         * Amount to receive. Denominated in sats if token identifier is empty, otherwise in the token base units
         */amount: U128?, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?, 
        /**
         * The expiry time of the invoice as a unix timestamp in seconds
         */expiryTime: UInt64?, 
        /**
         * A description to embed in the invoice.
         */description: String?, 
        /**
         * If set, the invoice may only be fulfilled by a payer with this public key
         */senderPublicKey: String?
    )
    case bitcoinAddress
    case bolt11Invoice(description: String, amountSats: UInt64?, 
        /**
         * The expiry of the invoice as a duration in seconds
         */expirySecs: UInt32?, 
        /**
         * If set, creates a HODL invoice with this payment hash (hex-encoded).
         * The payer's HTLC will be held until the preimage is provided via
         * `claim_htlc_payment` or the HTLC expires.
         */paymentHash: String?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceivePaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = ReceivePaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sparkAddress
        
        case 2: return .sparkInvoice(amount: try FfiConverterOptionTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf), expiryTime: try FfiConverterOptionUInt64.read(from: &buf), description: try FfiConverterOptionString.read(from: &buf), senderPublicKey: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 3: return .bitcoinAddress
        
        case 4: return .bolt11Invoice(description: try FfiConverterString.read(from: &buf), amountSats: try FfiConverterOptionUInt64.read(from: &buf), expirySecs: try FfiConverterOptionUInt32.read(from: &buf), paymentHash: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceivePaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sparkAddress:
            writeInt(&buf, Int32(1))
        
        
        case let .sparkInvoice(amount,tokenIdentifier,expiryTime,description,senderPublicKey):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeu128.write(amount, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            FfiConverterOptionUInt64.write(expiryTime, into: &buf)
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterOptionString.write(senderPublicKey, into: &buf)
            
        
        case .bitcoinAddress:
            writeInt(&buf, Int32(3))
        
        
        case let .bolt11Invoice(description,amountSats,expirySecs,paymentHash):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(description, into: &buf)
            FfiConverterOptionUInt64.write(amountSats, into: &buf)
            FfiConverterOptionUInt32.write(expirySecs, into: &buf)
            FfiConverterOptionString.write(paymentHash, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentMethod_lift(_ buf: RustBuffer) throws -> ReceivePaymentMethod {
    return try FfiConverterTypeReceivePaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceivePaymentMethod_lower(_ value: ReceivePaymentMethod) -> RustBuffer {
    return FfiConverterTypeReceivePaymentMethod.lower(value)
}



extension ReceivePaymentMethod: Equatable, Hashable {}




/**
 * Error type for the `BreezSdk`
 */
public enum SdkError {

    
    
    case SparkError(String
    )
    case InsufficientFunds
    case InvalidUuid(String
    )
    /**
     * Invalid input error
     */
    case InvalidInput(String
    )
    /**
     * Network error
     */
    case NetworkError(String
    )
    /**
     * Storage error
     */
    case StorageError(String
    )
    case ChainServiceError(String
    )
    case MaxDepositClaimFeeExceeded(tx: String, vout: UInt32, maxFee: Fee?, requiredFeeSats: UInt64, requiredFeeRateSatPerVbyte: UInt64
    )
    case MissingUtxo(tx: String, vout: UInt32
    )
    case LnurlError(String
    )
    case Signer(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkError: FfiConverterRustBuffer {
    typealias SwiftType = SdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SparkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InsufficientFunds
        case 3: return .InvalidUuid(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .InvalidInput(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .NetworkError(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .StorageError(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .ChainServiceError(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .MaxDepositClaimFeeExceeded(
            tx: try FfiConverterString.read(from: &buf), 
            vout: try FfiConverterUInt32.read(from: &buf), 
            maxFee: try FfiConverterOptionTypeFee.read(from: &buf), 
            requiredFeeSats: try FfiConverterUInt64.read(from: &buf), 
            requiredFeeRateSatPerVbyte: try FfiConverterUInt64.read(from: &buf)
            )
        case 9: return .MissingUtxo(
            tx: try FfiConverterString.read(from: &buf), 
            vout: try FfiConverterUInt32.read(from: &buf)
            )
        case 10: return .LnurlError(
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .Signer(
            try FfiConverterString.read(from: &buf)
            )
        case 12: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SparkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InsufficientFunds:
            writeInt(&buf, Int32(2))
        
        
        case let .InvalidUuid(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidInput(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NetworkError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .StorageError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ChainServiceError(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .MaxDepositClaimFeeExceeded(tx,vout,maxFee,requiredFeeSats,requiredFeeRateSatPerVbyte):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            FfiConverterOptionTypeFee.write(maxFee, into: &buf)
            FfiConverterUInt64.write(requiredFeeSats, into: &buf)
            FfiConverterUInt64.write(requiredFeeRateSatPerVbyte, into: &buf)
            
        
        case let .MissingUtxo(tx,vout):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(tx, into: &buf)
            FfiConverterUInt32.write(vout, into: &buf)
            
        
        case let .LnurlError(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Signer(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension SdkError: Equatable, Hashable {}

extension SdkError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Events emitted by the SDK
 */

public enum SdkEvent {
    
    /**
     * Emitted when the wallet has been synchronized with the network
     */
    case synced
    /**
     * Emitted when the SDK was unable to claim deposits
     */
    case unclaimedDeposits(unclaimedDeposits: [DepositInfo]
    )
    case claimedDeposits(claimedDeposits: [DepositInfo]
    )
    case paymentSucceeded(payment: Payment
    )
    case paymentPending(payment: Payment
    )
    case paymentFailed(payment: Payment
    )
    case optimization(optimizationEvent: OptimizationEvent
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdkEvent: FfiConverterRustBuffer {
    typealias SwiftType = SdkEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .synced
        
        case 2: return .unclaimedDeposits(unclaimedDeposits: try FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
        
        case 3: return .claimedDeposits(claimedDeposits: try FfiConverterSequenceTypeDepositInfo.read(from: &buf)
        )
        
        case 4: return .paymentSucceeded(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        case 5: return .paymentPending(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        case 6: return .paymentFailed(payment: try FfiConverterTypePayment.read(from: &buf)
        )
        
        case 7: return .optimization(optimizationEvent: try FfiConverterTypeOptimizationEvent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .synced:
            writeInt(&buf, Int32(1))
        
        
        case let .unclaimedDeposits(unclaimedDeposits):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeDepositInfo.write(unclaimedDeposits, into: &buf)
            
        
        case let .claimedDeposits(claimedDeposits):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeDepositInfo.write(claimedDeposits, into: &buf)
            
        
        case let .paymentSucceeded(payment):
            writeInt(&buf, Int32(4))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        
        case let .paymentPending(payment):
            writeInt(&buf, Int32(5))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        
        case let .paymentFailed(payment):
            writeInt(&buf, Int32(6))
            FfiConverterTypePayment.write(payment, into: &buf)
            
        
        case let .optimization(optimizationEvent):
            writeInt(&buf, Int32(7))
            FfiConverterTypeOptimizationEvent.write(optimizationEvent, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkEvent_lift(_ buf: RustBuffer) throws -> SdkEvent {
    return try FfiConverterTypeSdkEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdkEvent_lower(_ value: SdkEvent) -> RustBuffer {
    return FfiConverterTypeSdkEvent.lower(value)
}



extension SdkEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the seed for wallet generation, either as a mnemonic phrase with an optional
 * passphrase or as raw entropy bytes.
 */

public enum Seed {
    
    /**
     * A BIP-39 mnemonic phrase with an optional passphrase.
     */
    case mnemonic(
        /**
         * The mnemonic phrase. 12 or 24 words.
         */mnemonic: String, 
        /**
         * An optional passphrase for the mnemonic.
         */passphrase: String?
    )
    /**
     * Raw entropy bytes.
     */
    case entropy(Data
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSeed: FfiConverterRustBuffer {
    typealias SwiftType = Seed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Seed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mnemonic(mnemonic: try FfiConverterString.read(from: &buf), passphrase: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 2: return .entropy(try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Seed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .mnemonic(mnemonic,passphrase):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(mnemonic, into: &buf)
            FfiConverterOptionString.write(passphrase, into: &buf)
            
        
        case let .entropy(v1):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeed_lift(_ buf: RustBuffer) throws -> Seed {
    return try FfiConverterTypeSeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeed_lower(_ value: Seed) -> RustBuffer {
    return FfiConverterTypeSeed.lower(value)
}



extension Seed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendPaymentMethod {
    
    case bitcoinAddress(address: BitcoinAddressDetails, feeQuote: SendOnchainFeeQuote
    )
    case bolt11Invoice(invoiceDetails: Bolt11InvoiceDetails, sparkTransferFeeSats: UInt64?, lightningFeeSats: UInt64
    )
    case sparkAddress(address: String, 
        /**
         * Fee to pay for the transaction
         * Denominated in sats if token identifier is empty, otherwise in the token base units
         */fee: U128, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?
    )
    case sparkInvoice(sparkInvoiceDetails: SparkInvoiceDetails, 
        /**
         * Fee to pay for the transaction
         * Denominated in sats if token identifier is empty, otherwise in the token base units
         */fee: U128, 
        /**
         * The presence of this field indicates that the payment is for a token
         * If empty, it is a Bitcoin payment
         */tokenIdentifier: String?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentMethod: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(address: try FfiConverterTypeBitcoinAddressDetails.read(from: &buf), feeQuote: try FfiConverterTypeSendOnchainFeeQuote.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(invoiceDetails: try FfiConverterTypeBolt11InvoiceDetails.read(from: &buf), sparkTransferFeeSats: try FfiConverterOptionUInt64.read(from: &buf), lightningFeeSats: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .sparkAddress(address: try FfiConverterString.read(from: &buf), fee: try FfiConverterTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .sparkInvoice(sparkInvoiceDetails: try FfiConverterTypeSparkInvoiceDetails.read(from: &buf), fee: try FfiConverterTypeu128.read(from: &buf), tokenIdentifier: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(address,feeQuote):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressDetails.write(address, into: &buf)
            FfiConverterTypeSendOnchainFeeQuote.write(feeQuote, into: &buf)
            
        
        case let .bolt11Invoice(invoiceDetails,sparkTransferFeeSats,lightningFeeSats):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBolt11InvoiceDetails.write(invoiceDetails, into: &buf)
            FfiConverterOptionUInt64.write(sparkTransferFeeSats, into: &buf)
            FfiConverterUInt64.write(lightningFeeSats, into: &buf)
            
        
        case let .sparkAddress(address,fee,tokenIdentifier):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(address, into: &buf)
            FfiConverterTypeu128.write(fee, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        
        case let .sparkInvoice(sparkInvoiceDetails,fee,tokenIdentifier):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSparkInvoiceDetails.write(sparkInvoiceDetails, into: &buf)
            FfiConverterTypeu128.write(fee, into: &buf)
            FfiConverterOptionString.write(tokenIdentifier, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentMethod_lift(_ buf: RustBuffer) throws -> SendPaymentMethod {
    return try FfiConverterTypeSendPaymentMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentMethod_lower(_ value: SendPaymentMethod) -> RustBuffer {
    return FfiConverterTypeSendPaymentMethod.lower(value)
}



extension SendPaymentMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendPaymentOptions {
    
    case bitcoinAddress(
        /**
         * Confirmation speed for the on-chain transaction.
         */confirmationSpeed: OnchainConfirmationSpeed
    )
    case bolt11Invoice(preferSpark: Bool, 
        /**
         * If set, the function will return the payment if it is still pending after this
         * number of seconds. If unset, the function will return immediately after initiating the payment.
         */completionTimeoutSecs: UInt32?
    )
    case sparkAddress(
        /**
         * Can only be provided for Bitcoin payments. If set, a Spark HTLC transfer will be created.
         * The receiver will need to provide the preimage to claim it.
         */htlcOptions: SparkHtlcOptions?
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendPaymentOptions: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoinAddress(confirmationSpeed: try FfiConverterTypeOnchainConfirmationSpeed.read(from: &buf)
        )
        
        case 2: return .bolt11Invoice(preferSpark: try FfiConverterBool.read(from: &buf), completionTimeoutSecs: try FfiConverterOptionUInt32.read(from: &buf)
        )
        
        case 3: return .sparkAddress(htlcOptions: try FfiConverterOptionTypeSparkHtlcOptions.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bitcoinAddress(confirmationSpeed):
            writeInt(&buf, Int32(1))
            FfiConverterTypeOnchainConfirmationSpeed.write(confirmationSpeed, into: &buf)
            
        
        case let .bolt11Invoice(preferSpark,completionTimeoutSecs):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(preferSpark, into: &buf)
            FfiConverterOptionUInt32.write(completionTimeoutSecs, into: &buf)
            
        
        case let .sparkAddress(htlcOptions):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypeSparkHtlcOptions.write(htlcOptions, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentOptions_lift(_ buf: RustBuffer) throws -> SendPaymentOptions {
    return try FfiConverterTypeSendPaymentOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendPaymentOptions_lower(_ value: SendPaymentOptions) -> RustBuffer {
    return FfiConverterTypeSendPaymentOptions.lower(value)
}



extension SendPaymentOptions: Equatable, Hashable {}




public enum ServiceConnectivityError {

    
    
    case Builder(String
    )
    case Redirect(String
    )
    case Status(status: UInt16, body: String
    )
    case Timeout(String
    )
    case Request(String
    )
    case Connect(String
    )
    case Body(String
    )
    case Decode(String
    )
    case Json(String
    )
    case Other(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServiceConnectivityError: FfiConverterRustBuffer {
    typealias SwiftType = ServiceConnectivityError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServiceConnectivityError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Builder(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Redirect(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Status(
            status: try FfiConverterUInt16.read(from: &buf), 
            body: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Timeout(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Request(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .Connect(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .Body(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .Decode(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .Json(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .Other(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ServiceConnectivityError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Builder(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Redirect(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Status(status,body):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(status, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        
        case let .Timeout(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Request(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Connect(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Body(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Decode(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Json(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Other(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension ServiceConnectivityError: Equatable, Hashable {}

extension ServiceConnectivityError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The operational status of a Spark service.
 */

public enum ServiceStatus {
    
    /**
     * Service is fully operational.
     */
    case operational
    /**
     * Service is experiencing degraded performance.
     */
    case degraded
    /**
     * Service is partially unavailable.
     */
    case partial
    /**
     * Service status is unknown.
     */
    case unknown
    /**
     * Service is experiencing a major outage.
     */
    case major
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServiceStatus: FfiConverterRustBuffer {
    typealias SwiftType = ServiceStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServiceStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .operational
        
        case 2: return .degraded
        
        case 3: return .partial
        
        case 4: return .unknown
        
        case 5: return .major
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ServiceStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .operational:
            writeInt(&buf, Int32(1))
        
        
        case .degraded:
            writeInt(&buf, Int32(2))
        
        
        case .partial:
            writeInt(&buf, Int32(3))
        
        
        case .unknown:
            writeInt(&buf, Int32(4))
        
        
        case .major:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServiceStatus_lift(_ buf: RustBuffer) throws -> ServiceStatus {
    return try FfiConverterTypeServiceStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServiceStatus_lower(_ value: ServiceStatus) -> RustBuffer {
    return FfiConverterTypeServiceStatus.lower(value)
}



extension ServiceStatus: Equatable, Hashable {}




/**
 * Error type for signer operations
 */
public enum SignerError {

    
    
    case KeyDerivation(String
    )
    case Signing(String
    )
    case Encryption(String
    )
    case Decryption(String
    )
    case Frost(String
    )
    case InvalidInput(String
    )
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignerError: FfiConverterRustBuffer {
    typealias SwiftType = SignerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .KeyDerivation(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Signing(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Encryption(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Decryption(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Frost(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .InvalidInput(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .KeyDerivation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Signing(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Encryption(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Decryption(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Frost(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidInput(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Generic(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension SignerError: Equatable, Hashable {}

extension SignerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparkHtlcStatus {
    
    /**
     * The HTLC is waiting for the preimage to be shared by the receiver
     */
    case waitingForPreimage
    /**
     * The HTLC preimage has been shared and the transfer can be or has been claimed by the receiver
     */
    case preimageShared
    /**
     * The HTLC has been returned to the sender due to expiry
     */
    case returned
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSparkHtlcStatus: FfiConverterRustBuffer {
    typealias SwiftType = SparkHtlcStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparkHtlcStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .waitingForPreimage
        
        case 2: return .preimageShared
        
        case 3: return .returned
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparkHtlcStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .waitingForPreimage:
            writeInt(&buf, Int32(1))
        
        
        case .preimageShared:
            writeInt(&buf, Int32(2))
        
        
        case .returned:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcStatus_lift(_ buf: RustBuffer) throws -> SparkHtlcStatus {
    return try FfiConverterTypeSparkHtlcStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSparkHtlcStatus_lower(_ value: SparkHtlcStatus) -> RustBuffer {
    return FfiConverterTypeSparkHtlcStatus.lower(value)
}



extension SparkHtlcStatus: Equatable, Hashable {}




/**
 * Errors that can occur during storage operations
 */
public enum StorageError {

    
    
    /**
     * Connection-related errors (pool exhaustion, timeouts, connection refused).
     * These are often transient and may be retried.
     */
    case Connection(String
    )
    case Implementation(String
    )
    /**
     * Database initialization error
     */
    case InitializationError(String
    )
    case Serialization(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageError: FfiConverterRustBuffer {
    typealias SwiftType = StorageError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Connection(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Implementation(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InitializationError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Connection(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Implementation(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InitializationError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension StorageError: Equatable, Hashable {}

extension StorageError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported success action types
 *
 * Receiving any other (unsupported) success action type will result in a failed parsing,
 * which will abort the LNURL-pay workflow, as per LUD-09.
 */

public enum SuccessAction {
    
    /**
     * AES type, described in LUD-10
     */
    case aes(data: AesSuccessActionData
    )
    /**
     * Message type, described in LUD-09
     */
    case message(data: MessageSuccessActionData
    )
    /**
     * URL type, described in LUD-09
     */
    case url(data: UrlSuccessActionData
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSuccessAction: FfiConverterRustBuffer {
    typealias SwiftType = SuccessAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .aes(data: try FfiConverterTypeAesSuccessActionData.read(from: &buf)
        )
        
        case 2: return .message(data: try FfiConverterTypeMessageSuccessActionData.read(from: &buf)
        )
        
        case 3: return .url(data: try FfiConverterTypeUrlSuccessActionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .aes(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionData.write(data, into: &buf)
            
        
        case let .message(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(data, into: &buf)
            
        
        case let .url(data):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(data, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessAction_lift(_ buf: RustBuffer) throws -> SuccessAction {
    return try FfiConverterTypeSuccessAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessAction_lower(_ value: SuccessAction) -> RustBuffer {
    return FfiConverterTypeSuccessAction.lower(value)
}



extension SuccessAction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * [`SuccessAction`] where contents are ready to be consumed by the caller
 *
 * Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
 */

public enum SuccessActionProcessed {
    
    /**
     * See [`SuccessAction::Aes`] for received payload
     *
     * See [`AesSuccessActionDataDecrypted`] for decrypted payload
     */
    case aes(result: AesSuccessActionDataResult
    )
    /**
     * See [`SuccessAction::Message`]
     */
    case message(data: MessageSuccessActionData
    )
    /**
     * See [`SuccessAction::Url`]
     */
    case url(data: UrlSuccessActionData
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessActionProcessed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .aes(result: try FfiConverterTypeAesSuccessActionDataResult.read(from: &buf)
        )
        
        case 2: return .message(data: try FfiConverterTypeMessageSuccessActionData.read(from: &buf)
        )
        
        case 3: return .url(data: try FfiConverterTypeUrlSuccessActionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessActionProcessed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .aes(result):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataResult.write(result, into: &buf)
            
        
        case let .message(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(data, into: &buf)
            
        
        case let .url(data):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(data, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessActionProcessed_lift(_ buf: RustBuffer) throws -> SuccessActionProcessed {
    return try FfiConverterTypeSuccessActionProcessed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessActionProcessed_lower(_ value: SuccessActionProcessed) -> RustBuffer {
    return FfiConverterTypeSuccessActionProcessed.lower(value)
}



extension SuccessActionProcessed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TokenTransactionType {
    
    case transfer
    case mint
    case burn
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TokenTransactionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenTransactionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .transfer
        
        case 2: return .mint
        
        case 3: return .burn
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TokenTransactionType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .transfer:
            writeInt(&buf, Int32(1))
        
        
        case .mint:
            writeInt(&buf, Int32(2))
        
        
        case .burn:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenTransactionType_lift(_ buf: RustBuffer) throws -> TokenTransactionType {
    return try FfiConverterTypeTokenTransactionType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenTransactionType_lower(_ value: TokenTransactionType) -> RustBuffer {
    return FfiConverterTypeTokenTransactionType.lower(value)
}



extension TokenTransactionType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UpdateDepositPayload {
    
    case claimError(error: DepositClaimError
    )
    case refund(refundTxid: String, refundTx: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateDepositPayload: FfiConverterRustBuffer {
    typealias SwiftType = UpdateDepositPayload

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateDepositPayload {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .claimError(error: try FfiConverterTypeDepositClaimError.read(from: &buf)
        )
        
        case 2: return .refund(refundTxid: try FfiConverterString.read(from: &buf), refundTx: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UpdateDepositPayload, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .claimError(error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDepositClaimError.write(error, into: &buf)
            
        
        case let .refund(refundTxid,refundTx):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(refundTxid, into: &buf)
            FfiConverterString.write(refundTx, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateDepositPayload_lift(_ buf: RustBuffer) throws -> UpdateDepositPayload {
    return try FfiConverterTypeUpdateDepositPayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateDepositPayload_lower(_ value: UpdateDepositPayload) -> RustBuffer {
    return FfiConverterTypeUpdateDepositPayload.lower(value)
}



extension UpdateDepositPayload: Equatable, Hashable {}






/**
 * Trait for event listeners
 */
public protocol EventListener : AnyObject {
    
    /**
     * Called when an event occurs
     */
    func onEvent(event: SdkEvent) async 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEventListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEventListener = UniffiVTableCallbackInterfaceEventListener(
        onEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEventListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.onEvent(
                     event: try FfiConverterTypeSdkEvent.lift(event)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceEventListener.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EventListener: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEventListener() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(&UniffiCallbackInterfaceEventListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceEventListener {
    fileprivate static var handleMap = UniffiHandleMap<EventListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceEventListener : FfiConverter {
    typealias SwiftType = EventListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol Logger : AnyObject {
    
    func log(l: LogEntry) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogger {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLogger = UniffiVTableCallbackInterfaceLogger(
        log: { (
            uniffiHandle: UInt64,
            l: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.log(
                     l: try FfiConverterTypeLogEntry.lift(l)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Logger: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLogger() {
    uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(&UniffiCallbackInterfaceLogger.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLogger {
    fileprivate static var handleMap = UniffiHandleMap<Logger>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLogger : FfiConverter {
    typealias SwiftType = Logger
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeConversionDetails: FfiConverterRustBuffer {
    typealias SwiftType = ConversionDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConversionDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConversionDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeConversionEstimate: FfiConverterRustBuffer {
    typealias SwiftType = ConversionEstimate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConversionEstimate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConversionEstimate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeConversionInfo: FfiConverterRustBuffer {
    typealias SwiftType = ConversionInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConversionInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConversionInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeConversionOptions: FfiConverterRustBuffer {
    typealias SwiftType = ConversionOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConversionOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConversionOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCredentials: FfiConverterRustBuffer {
    typealias SwiftType = Credentials?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredentials.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredentials.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeKeySetConfig: FfiConverterRustBuffer {
    typealias SwiftType = KeySetConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKeySetConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKeySetConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLightningAddressInfo: FfiConverterRustBuffer {
    typealias SwiftType = LightningAddressInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLightningAddressInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLightningAddressInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlPayInfo: FfiConverterRustBuffer {
    typealias SwiftType = LnurlPayInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlPayInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlPayInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlReceiveMetadata: FfiConverterRustBuffer {
    typealias SwiftType = LnurlReceiveMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlReceiveMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlReceiveMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeLnurlWithdrawInfo: FfiConverterRustBuffer {
    typealias SwiftType = LnurlWithdrawInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnurlWithdrawInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnurlWithdrawInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeOutgoingChange: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingChange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutgoingChange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutgoingChange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = Payment?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePayment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePayment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRecord: FfiConverterRustBuffer {
    typealias SwiftType = Record?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRecord.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRecord.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkHtlcDetails: FfiConverterRustBuffer {
    typealias SwiftType = SparkHtlcDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkHtlcDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkHtlcDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkHtlcOptions: FfiConverterRustBuffer {
    typealias SwiftType = SparkHtlcOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkHtlcOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkHtlcOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSparkInvoicePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = SparkInvoicePaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSparkInvoicePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSparkInvoicePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeStableBalanceConfig: FfiConverterRustBuffer {
    typealias SwiftType = StableBalanceConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStableBalanceConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStableBalanceConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSymbol: FfiConverterRustBuffer {
    typealias SwiftType = Symbol?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSymbol.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSymbol.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTokenMetadata: FfiConverterRustBuffer {
    typealias SwiftType = TokenMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTokenMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTokenMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAssetFilter: FfiConverterRustBuffer {
    typealias SwiftType = AssetFilter?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAssetFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAssetFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeConversionPurpose: FfiConverterRustBuffer {
    typealias SwiftType = ConversionPurpose?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConversionPurpose.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConversionPurpose.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDepositClaimError: FfiConverterRustBuffer {
    typealias SwiftType = DepositClaimError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDepositClaimError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDepositClaimError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFee: FfiConverterRustBuffer {
    typealias SwiftType = Fee?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFee.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFee.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFeePolicy: FfiConverterRustBuffer {
    typealias SwiftType = FeePolicy?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeePolicy.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeePolicy.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMaxFee: FfiConverterRustBuffer {
    typealias SwiftType = MaxFee?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMaxFee.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMaxFee.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSendPaymentOptions: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendPaymentOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendPaymentOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessAction: FfiConverterRustBuffer {
    typealias SwiftType = SuccessAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessActionProcessed.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessActionProcessed.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTokenTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TokenTransactionType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTokenTransactionType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTokenTransactionType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceLogger: FfiConverterRustBuffer {
    typealias SwiftType = Logger?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceLogger.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceLogger.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeExternalInputParser: FfiConverterRustBuffer {
    typealias SwiftType = [ExternalInputParser]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeExternalInputParser.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeExternalInputParser.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePaymentDetailsFilter: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentDetailsFilter]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePaymentDetailsFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePaymentDetailsFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentStatus]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePaymentStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePaymentStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentType]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePaymentType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePaymentType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeSparkHtlcStatus: FfiConverterRustBuffer {
    typealias SwiftType = [SparkHtlcStatus]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeSparkHtlcStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeSparkHtlcStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeu128: FfiConverterRustBuffer {
    typealias SwiftType = U128?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeu128.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeu128.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBip21Extra: FfiConverterRustBuffer {
    typealias SwiftType = [Bip21Extra]

    public static func write(_ value: [Bip21Extra], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBip21Extra.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip21Extra] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip21Extra]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBip21Extra.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt11RouteHint: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt11RouteHint]

    public static func write(_ value: [Bolt11RouteHint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt11RouteHint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt11RouteHint] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt11RouteHint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt11RouteHint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt11RouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt11RouteHintHop]

    public static func write(_ value: [Bolt11RouteHintHop], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt11RouteHintHop.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt11RouteHintHop] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt11RouteHintHop]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt11RouteHintHop.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBolt12OfferBlindedPath: FfiConverterRustBuffer {
    typealias SwiftType = [Bolt12OfferBlindedPath]

    public static func write(_ value: [Bolt12OfferBlindedPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBolt12OfferBlindedPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bolt12OfferBlindedPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bolt12OfferBlindedPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBolt12OfferBlindedPath.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDepositInfo: FfiConverterRustBuffer {
    typealias SwiftType = [DepositInfo]

    public static func write(_ value: [DepositInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDepositInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DepositInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [DepositInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDepositInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeExternalInputParser: FfiConverterRustBuffer {
    typealias SwiftType = [ExternalInputParser]

    public static func write(_ value: [ExternalInputParser], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExternalInputParser.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ExternalInputParser] {
        let len: Int32 = try readInt(&buf)
        var seq = [ExternalInputParser]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeExternalInputParser.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeExternalVerifiableSecretShare: FfiConverterRustBuffer {
    typealias SwiftType = [ExternalVerifiableSecretShare]

    public static func write(_ value: [ExternalVerifiableSecretShare], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExternalVerifiableSecretShare.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ExternalVerifiableSecretShare] {
        let len: Int32 = try readInt(&buf)
        var seq = [ExternalVerifiableSecretShare]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeExternalVerifiableSecretShare.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = [FiatCurrency]

    public static func write(_ value: [FiatCurrency], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFiatCurrency.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FiatCurrency] {
        let len: Int32 = try readInt(&buf)
        var seq = [FiatCurrency]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFiatCurrency.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIdentifierCommitmentPair: FfiConverterRustBuffer {
    typealias SwiftType = [IdentifierCommitmentPair]

    public static func write(_ value: [IdentifierCommitmentPair], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentifierCommitmentPair.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentifierCommitmentPair] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentifierCommitmentPair]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIdentifierCommitmentPair.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIdentifierPublicKeyPair: FfiConverterRustBuffer {
    typealias SwiftType = [IdentifierPublicKeyPair]

    public static func write(_ value: [IdentifierPublicKeyPair], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentifierPublicKeyPair.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentifierPublicKeyPair] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentifierPublicKeyPair]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIdentifierPublicKeyPair.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIdentifierSignaturePair: FfiConverterRustBuffer {
    typealias SwiftType = [IdentifierSignaturePair]

    public static func write(_ value: [IdentifierSignaturePair], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentifierSignaturePair.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentifierSignaturePair] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentifierSignaturePair]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIdentifierSignaturePair.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIncomingChange: FfiConverterRustBuffer {
    typealias SwiftType = [IncomingChange]

    public static func write(_ value: [IncomingChange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIncomingChange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IncomingChange] {
        let len: Int32 = try readInt(&buf)
        var seq = [IncomingChange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIncomingChange.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]

    public static func write(_ value: [LocaleOverrides], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocaleOverrides.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocaleOverrides] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocaleOverrides]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocaleOverrides.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]

    public static func write(_ value: [LocalizedName], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalizedName.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalizedName] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalizedName]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalizedName.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOutgoingChange: FfiConverterRustBuffer {
    typealias SwiftType = [OutgoingChange]

    public static func write(_ value: [OutgoingChange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutgoingChange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutgoingChange] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutgoingChange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutgoingChange.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeProvisionalPayment: FfiConverterRustBuffer {
    typealias SwiftType = [ProvisionalPayment]

    public static func write(_ value: [ProvisionalPayment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProvisionalPayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProvisionalPayment] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProvisionalPayment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeProvisionalPayment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRate: FfiConverterRustBuffer {
    typealias SwiftType = [Rate]

    public static func write(_ value: [Rate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Rate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Rate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRecord: FfiConverterRustBuffer {
    typealias SwiftType = [Record]

    public static func write(_ value: [Record], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Record] {
        let len: Int32 = try readInt(&buf)
        var seq = [Record]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRecord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSetLnurlMetadataItem: FfiConverterRustBuffer {
    typealias SwiftType = [SetLnurlMetadataItem]

    public static func write(_ value: [SetLnurlMetadataItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSetLnurlMetadataItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SetLnurlMetadataItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [SetLnurlMetadataItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSetLnurlMetadataItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTokenMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [TokenMetadata]

    public static func write(_ value: [TokenMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTokenMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TokenMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [TokenMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTokenMetadata.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [Utxo]

    public static func write(_ value: [Utxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUtxo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Utxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [Utxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUtxo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = [InputType]

    public static func write(_ value: [InputType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInputType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [InputType] {
        let len: Int32 = try readInt(&buf)
        var seq = [InputType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInputType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentDetailsFilter: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentDetailsFilter]

    public static func write(_ value: [PaymentDetailsFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentDetailsFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentDetailsFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentDetailsFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentDetailsFilter.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentStatus]

    public static func write(_ value: [PaymentStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentStatus.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentStatus] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentStatus]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentStatus.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentType]

    public static func write(_ value: [PaymentType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentType] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSparkHtlcStatus: FfiConverterRustBuffer {
    typealias SwiftType = [SparkHtlcStatus]

    public static func write(_ value: [SparkHtlcStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparkHtlcStatus.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparkHtlcStatus] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparkHtlcStatus]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparkHtlcStatus.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeTokenBalance: FfiConverterRustBuffer {
    public static func write(_ value: [String: TokenBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeTokenBalance.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: TokenBalance] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: TokenBalance]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeTokenBalance.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringSequenceTypePayment: FfiConverterRustBuffer {
    public static func write(_ value: [String: [Payment]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypePayment.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [Payment]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [Payment]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypePayment.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}




/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias U128 = BInt


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeu128: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U128 {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return BInt(builtinValue)!
    }

    public static func write(_ value: U128, into buf: inout [UInt8]) {
        let builtinValue = value.asString(radix: 10)
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> U128 {
        let builtinValue = try FfiConverterString.lift(value)
        return BInt(builtinValue)!
    }

    public static func lower(_ value: U128) -> RustBuffer {
        let builtinValue = value.asString(radix: 10)
        return FfiConverterString.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeu128_lift(_ value: RustBuffer) throws -> U128 {
    return try FfiConverterTypeu128.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeu128_lower(_ value: U128) -> RustBuffer {
    return FfiConverterTypeu128.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountBreezSdkSpark() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
/**
 * Connects to the Spark network using the provided configuration and mnemonic.
 *
 * # Arguments
 *
 * * `request` - The connection request object
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */
public func connect(request: ConnectRequest)async throws  -> BreezSdk {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_func_connect(FfiConverterTypeConnectRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBreezSdk.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
/**
 * Connects to the Spark network using an external signer.
 *
 * This method allows using a custom signer implementation instead of providing
 * a seed directly.
 *
 * # Arguments
 *
 * * `request` - The connection request object with external signer
 *
 * # Returns
 *
 * Result containing either the initialized `BreezSdk` or an `SdkError`
 */
public func connectWithSigner(request: ConnectWithSignerRequest)async throws  -> BreezSdk {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_func_connect_with_signer(FfiConverterTypeConnectWithSignerRequest.lower(request)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeBreezSdk.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
/**
 * Creates a `PostgreSQL` storage instance for use with the SDK builder.
 *
 * Returns a `Storage` trait object backed by the `PostgreSQL` connection pool.
 *
 * # Arguments
 *
 * * `config` - Configuration for the `PostgreSQL` connection pool
 *
 * # Example
 *
 * ```ignore
 * use breez_sdk_core::{create_postgres_storage, default_postgres_storage_config};
 *
 * let storage = create_postgres_storage(default_postgres_storage_config(
 * "host=localhost user=postgres dbname=spark".to_string()
 * )).await?;
 *
 * let sdk = SdkBuilder::new(config, seed)
 * .with_storage(storage)
 * .build()
 * .await?;
 * ```
 */
public func createPostgresStorage(config: PostgresStorageConfig)async throws  -> Storage {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_func_create_postgres_storage(FfiConverterTypePostgresStorageConfig.lower(config)
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_pointer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_pointer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_pointer,
            liftFunc: FfiConverterTypeStorage.lift,
            errorHandler: FfiConverterTypeStorageError.lift
        )
}
public func defaultConfig(network: Network) -> Config {
    return try!  FfiConverterTypeConfig.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_func_default_config(
        FfiConverterTypeNetwork.lower(network),$0
    )
})
}
/**
 * Creates a default external signer from a mnemonic.
 *
 * This is a convenience factory method for creating a signer that can be used
 * with `connect_with_signer` or `SdkBuilder::new_with_signer`.
 *
 * # Arguments
 *
 * * `mnemonic` - BIP39 mnemonic phrase (12 or 24 words)
 * * `passphrase` - Optional passphrase for the mnemonic
 * * `network` - Network to use (Mainnet or Regtest)
 * * `key_set_config` - Optional key set configuration. If None, uses default configuration.
 *
 * # Returns
 *
 * Result containing the signer as `Arc<dyn ExternalSigner>`
 */
public func defaultExternalSigner(mnemonic: String, passphrase: String?, network: Network, keySetConfig: KeySetConfig?)throws  -> ExternalSigner {
    return try  FfiConverterTypeExternalSigner.lift(try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_func_default_external_signer(
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterTypeNetwork.lower(network),
        FfiConverterOptionTypeKeySetConfig.lower(keySetConfig),$0
    )
})
}
/**
 * Creates a `PostgresStorageConfig` with the given connection string and default pool settings.
 *
 * This is a convenience function for creating a config with sensible defaults from deadpool.
 * Use this instead of manually constructing `PostgresStorageConfig` when you want defaults.
 *
 * Default values:
 * - `max_pool_size`: `num_cpus * 4`
 * - `wait_timeout_secs`: `None` (wait indefinitely)
 * - `create_timeout_secs`: `None` (no timeout)
 * - `recycle_timeout_secs`: `None` (no timeout)
 * - `queue_mode`: FIFO
 * - `root_ca_pem`: `None` (uses Mozilla's root certificate store)
 */
public func defaultPostgresStorageConfig(connectionString: String) -> PostgresStorageConfig {
    return try!  FfiConverterTypePostgresStorageConfig.lift(try! rustCall() {
    uniffi_breez_sdk_spark_fn_func_default_postgres_storage_config(
        FfiConverterString.lower(connectionString),$0
    )
})
}
/**
 * Fetches the current status of Spark network services relevant to the SDK.
 *
 * This function queries the Spark status API and returns the worst status
 * across the Spark Operators and SSP services.
 */
public func getSparkStatus()async throws  -> SparkStatus {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_breez_sdk_spark_fn_func_get_spark_status(
                )
            },
            pollFunc: ffi_breez_sdk_spark_rust_future_poll_rust_buffer,
            completeFunc: ffi_breez_sdk_spark_rust_future_complete_rust_buffer,
            freeFunc: ffi_breez_sdk_spark_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparkStatus.lift,
            errorHandler: FfiConverterTypeSdkError.lift
        )
}
public func initLogging(logDir: String?, appLogger: Logger?, logFilter: String?)throws  {try rustCallWithError(FfiConverterTypeSdkError.lift) {
    uniffi_breez_sdk_spark_fn_func_init_logging(
        FfiConverterOptionString.lower(logDir),
        FfiConverterOptionCallbackInterfaceLogger.lower(appLogger),
        FfiConverterOptionString.lower(logFilter),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_breez_sdk_spark_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_connect() != 40345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_connect_with_signer() != 1399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_create_postgres_storage() != 17676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_config() != 62194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_external_signer() != 40694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_default_postgres_storage_config() != 11839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_get_spark_status() != 62888) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_func_init_logging() != 8518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos() != 20959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status() != 23018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex() != 59376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction() != 65179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_recommended_fees() != 43230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener() != 37737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_buy_bitcoin() != 32150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_cancel_leaf_optimization() != 56996) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available() != 31624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message() != 4385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit() != 43529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_htlc_payment() != 57587) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address() != 44132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect() != 330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_fetch_conversion_limits() != 50958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info() != 6771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_leaf_optimization_progress() != 38008) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address() != 36552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment() != 11540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_token_issuer() != 26649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata() != 40125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_get_user_settings() != 38537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies() != 63366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates() != 5904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments() != 39170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits() != 22486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_auth() != 125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay() != 10147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw() != 45652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_parse() != 14285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay() != 37691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment() != 34185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment() != 36984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_recommended_fees() != 16947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit() != 33646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address() != 530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener() != 41066) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment() != 54349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message() != 57563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_start_leaf_optimization() != 22827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet() != 30368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_breezsdk_update_user_settings() != 1721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_identity_public_key() != 62941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_derive_public_key() != 23137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa() != 37648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_ecdsa_recoverable() != 3107) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_ecies() != 60224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_decrypt_ecies() != 59601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_hash_schnorr() != 57220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_hmac_sha256() != 57517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_signing_commitment() != 31862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_get_public_key_for_node() != 37434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_generate_random_secret() != 26114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_secret_encrypted() != 38925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_secret() != 45280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_static_deposit_signing_key() != 62519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_subtract_secrets() != 45969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_split_secret_with_proofs() != 19489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_encrypt_secret_for_receiver() != 51627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_public_key_from_secret() != 53055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_sign_frost() != 20635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_externalsigner_aggregate_frost() != 53544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_currencies() != 19092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_fiatservice_fetch_fiat_rates() != 11512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send() != 30686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_restclient_get_request() != 8260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_restclient_post_request() != 24889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_restclient_delete_request() != 51072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build() != 8126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service() != 2848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage() != 14543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service() != 37854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set() != 50052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client() != 51060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer() != 21617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service() != 63155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage() != 59400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item() != 6883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item() != 30248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item() != 7970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_list_payments() != 19728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_insert_payment() != 28075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_insert_payment_metadata() != 32757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id() != 35394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice() != 57075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_payments_by_parent_ids() != 10948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_add_deposit() != 13181) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit() != 28477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_list_deposits() != 62636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_update_deposit() != 18714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_set_lnurl_metadata() != 64210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_add_outgoing_change() != 50774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_complete_outgoing_sync() != 8796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_pending_outgoing_changes() != 20314) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_last_revision() != 48442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_insert_incoming_records() != 38174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_delete_incoming_record() != 26412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_incoming_records() != 13705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_get_latest_outgoing_change() != 41859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_storage_update_record_from_incoming() != 54499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_burn_issuer_token() != 56056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_create_issuer_token() != 33277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_freeze_issuer_token() != 32344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_balance() != 9758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_get_issuer_token_metadata() != 57707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_mint_issuer_token() != 36459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_tokenissuer_unfreeze_issuer_token() != 65025) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new() != 65435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event() != 24807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_breez_sdk_spark_checksum_method_logger_log() != 11839) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitBitcoinChainService()
    uniffiCallbackInitExternalSigner()
    uniffiCallbackInitFiatService()
    uniffiCallbackInitPaymentObserver()
    uniffiCallbackInitRestClient()
    uniffiCallbackInitStorage()
    uniffiCallbackInitEventListener()
    uniffiCallbackInitLogger()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all